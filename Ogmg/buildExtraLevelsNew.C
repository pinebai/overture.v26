// This file automatically generated from buildExtraLevelsNew.bC with bpp.
#include "Ogmg.h"
#include "display.h"
#include "Ogen.h"
#include "ParallelUtility.h"
#include "ParallelGridUtility.h"
#include "InterpolationData.h"
#include "CanInterpolate.h"
#include "LoadBalancer.h"
#include <algorithm>

int checkGrid( CompositeGrid & cg, GenericGraphicsInterface *ps =0, int debug=0 );

int 
displayMaskLaTeX( const intArray & mask, 
              		  const aString & label =nullString,
              		  FILE *file = NULL ,
              		  const DisplayParameters *displayParameters = NULL );

#define  FOR_3(i1,i2,i3,I1,I2,I3)I1Base=I1.getBase(); I2Base=I2.getBase(); I3Base=I3.getBase();I1Bound=I1.getBound(); I2Bound=I2.getBound(); I3Bound=I3.getBound();for( i3=I3Base; i3<=I3Bound; i3++ )  for( i2=I2Base; i2<=I2Bound; i2++ )  for( i1=I1Base; i1<=I1Bound; i1++ )

#define  FOR_3D(i1,i2,i3,I1,I2,I3)int I1Base,I2Base,I3Base;int I1Bound,I2Bound,I3Bound;I1Base=I1.getBase(); I2Base=I2.getBase(); I3Base=I3.getBase();I1Bound=I1.getBound(); I2Bound=I2.getBound(); I3Bound=I3.getBound();for( i3=I3Base; i3<=I3Bound; i3++ )  for( i2=I2Base; i2<=I2Bound; i2++ )  for( i1=I1Base; i1<=I1Bound; i1++ )

// ========================================================================================
/// \brief: Limit the bounds of Iv to lie within the bounds of the array mask
// ========================================================================================
bool 
getLocalBounds( const intSerialArray & mask, Index Iv[3] )
{
    bool ok=true;
    for( int axis=0; axis<3; axis++ )
    {
        int ia=max( mask.getBase(axis) ,Iv[axis].getBase()  );  // *note* -1
        int ib=min( mask.getBound(axis),Iv[axis].getBound() );  // *note* +1

        if( ib>=ia )
        {
            Iv[axis]= Range(ia,ib);
        }
        else
        {
            return false;
        }
    }

    return true;
}


// ========================================================================================
// class use to sort the interpolationPoint array
// 
// In 2d: we sort into ascending order of a(i,0) and secondarily in ascending order of a(i,1)
//   i.e. we sort on  a(i,1)+n*a(i,0) where n=a.getLength(0)
// In 3d: we also sort thirdly on a(i,2)
// ========================================================================================
namespace{
    struct SortCmp2d {
        SortCmp2d(const IntegerArray &a_) : a(a_) { n=a.getLength(0); }
        bool operator() ( int i, int j )
            { return a(i,1)+n*a(i,0) < a(j,1)+n*a(j,0); }
        const IntegerArray &a;
        int n;
    };
    struct SortCmp3d {
    SortCmp3d(const IntegerArray &a_) : a(a_) { n=a.getLength(0); n2=n*n; }
        bool operator() ( int i, int j )
            { return a(i,2)+n*a(i,1)+n2*a(i,0) < a(j,2)+n*a(j,1)+n2*a(j,0); }
        const IntegerArray &a;
        int n,n2;
    };
}

// moved to ParallelGridUtility:
// namespace
// {
// void
// sortLocalInterpolationPoints( CompositeGrid & cg )
// // ============================================================================================
// //  /Description:
// //     Sort the local interpolation points by donor grid and build the interpolationStartEndIndex
// //
// // ============================================================================================
// {
//   const int numberOfComponentGrids=cg.numberOfComponentGrids();
//   const int numberOfDimensions=cg.numberOfDimensions();

//   if( Ogmg::debug & 4 )
//     printF(" ---> sortLocalInterpolationPoints numberOfComponentGrids=%i <---- \n",numberOfComponentGrids);

// //   interpolationStartEndIndex.redim(4,numberOfComponentGrids,numberOfComponentGrids);
// //   interpolationStartEndIndex = -1;

//   IntegerArray & interpolationStartEndIndex = cg.interpolationStartEndIndex;
//   interpolationStartEndIndex=-1;

//   IntegerArray gridStart(numberOfComponentGrids), ng(numberOfComponentGrids);
//   for( int grid=0; grid<numberOfComponentGrids; grid++ )
//   {
//     const int nig=cg->numberOfInterpolationPointsLocal(grid);

//     if( nig > 0 )
//     {
//       intSerialArray & interpoleeGrid             = cg->interpoleeGridLocal[grid]; 
//       intSerialArray & interpolationPoint         = cg->interpolationPointLocal[grid];
//       intSerialArray & interpoleeLocation         = cg->interpoleeLocationLocal[grid];
//       intSerialArray & variableInterpolationWidth = cg->variableInterpolationWidthLocal[grid];
//       realSerialArray & interpolationCoordinates  = cg->interpolationCoordinatesLocal[grid];


//       int *interpoleeLocationp = interpoleeLocation.Array_Descriptor.Array_View_Pointer1;
//       const int interpoleeLocationDim0=interpoleeLocation.getRawDataSize(0);
// #define INTERPOLEELOCATION(i0,i1) interpoleeLocationp[i0+interpoleeLocationDim0*(i1)]
        	  
//       int *interpolationPointp = interpolationPoint.Array_Descriptor.Array_View_Pointer1;
//       const int interpolationPointDim0=interpolationPoint.getRawDataSize(0);
// #define INTERPOLATIONPOINT(i0,i1) interpolationPointp[i0+interpolationPointDim0*(i1)]
        	  
//       real *interpolationCoordinatesp = interpolationCoordinates.Array_Descriptor.Array_View_Pointer1;
//       const int interpolationCoordinatesDim0=interpolationCoordinates.getRawDataSize(0);
// #define INTERPOLATIONCOORDINATES(i0,i1) interpolationCoordinatesp[i0+interpolationCoordinatesDim0*(i1)]
        	  
//       int * interpoleeGridp = interpoleeGrid.Array_Descriptor.Array_View_Pointer0;
// #define INTERPOLEEGRID(i0) interpoleeGridp[i0]

//       int * variableInterpolationWidthp = variableInterpolationWidth.Array_Descriptor.Array_View_Pointer0;
// #define VARIABLEINTERPOLATIONWIDTH(i0) variableInterpolationWidthp[i0]

        	  
//       // temp arrays to hold sorted arrays:
//       intSerialArray interpoleeGrid1(nig);
//       intSerialArray interpolationPoint1(nig,numberOfDimensions);
//       intSerialArray interpoleeLocation1(nig, numberOfDimensions);
//       intSerialArray variableInterpolationWidth1(nig);
//       realSerialArray interpolationCoordinates1(nig,numberOfDimensions);

//       int *interpoleeLocation1p = interpoleeLocation1.Array_Descriptor.Array_View_Pointer1;
//       const int interpoleeLocation1Dim0=interpoleeLocation1.getRawDataSize(0);
// #define INTERPOLEELOCATION1(i0,i1) interpoleeLocation1p[i0+interpoleeLocation1Dim0*(i1)]
        	  
//       int *interpolationPoint1p = interpolationPoint1.Array_Descriptor.Array_View_Pointer1;
//       const int interpolationPoint1Dim0=interpolationPoint1.getRawDataSize(0);
// #define INTERPOLATIONPOINT1(i0,i1) interpolationPoint1p[i0+interpolationPoint1Dim0*(i1)]
        	  
//       real *interpolationCoordinates1p = interpolationCoordinates1.Array_Descriptor.Array_View_Pointer1;
//       const int interpolationCoordinates1Dim0=interpolationCoordinates1.getRawDataSize(0);
// #define INTERPOLATIONCOORDINATES1(i0,i1) interpolationCoordinates1p[i0+interpolationCoordinates1Dim0*(i1)]
        	  
//       int * interpoleeGrid1p = interpoleeGrid1.Array_Descriptor.Array_View_Pointer0;
// #define INTERPOLEEGRID1(i0) interpoleeGrid1p[i0]

//       int * variableInterpolationWidth1p = variableInterpolationWidth1.Array_Descriptor.Array_View_Pointer0;
// #define VARIABLEINTERPOLATIONWIDTH1(i0) variableInterpolationWidth1p[i0]

//       int * ngp = ng.Array_Descriptor.Array_View_Pointer0;
// #define NG(i0) ngp[i0]

//       int * gridStartp = gridStart.Array_Descriptor.Array_View_Pointer0;
// #define GRIDSTART(i0) gridStartp[i0]
    
//       if( false )
//       {
//         printF(" grid=%i, nig=%i\n",grid,nig);
// 	::display(interpolationPoint,"interpolationPoint");
// 	::display(interpoleeGrid,"interpoleeGrid");
//       }
            

//       // order the interpolation points by interpolee grid.
//       ng=0;
//       const int ia=interpolationPoint.getBase(0), ib=interpolationPoint.getBound(0);
//       assert( ia==0 );
//       for( int i=ia; i<=ib; i++ )
// 	NG(INTERPOLEEGRID(i))++;

//       //	  ng.display("NG");

//       GRIDSTART(0)=0;
//       int grid2;
//       for( grid2=1; grid2<numberOfComponentGrids; grid2++ )
// 	GRIDSTART(grid2)=GRIDSTART(grid2-1)+NG(grid2-1);
        	  
//       //	  gridStart.display("GRIDSTART");
//       // ***** we need to assign the interpolationStartEndIndex 
//       // **** this needs to be set on multigridLevel[0] too ********
        	  
//       // for now we assume that the interpolation is implicit on coarser levels *** fix this ***
        	  
//       //kkc left over from ogmg	  cg1.interpolationIsAllExplicit()=false;
//       //kkc left over from ogmg	  cg1.interpolationIsAllImplicit()=true;

//       //kkc left over from ogmg :
//       for( grid2=0; grid2<numberOfComponentGrids; grid2++ )
//       {
// 	//interpolationStartEndIndex(0,grid,grid2)=-1;
// 	//interpolationStartEndIndex(1,grid,grid2)=-1;
// 	//interpolationStartEndIndex(2,grid,grid2)=-1;
// 	//interpolationStartEndIndex(3,grid,grid2)=-1;
      	
// 	if( NG(grid2)>0 )
// 	{
// 	  interpolationStartEndIndex(0,grid,grid2)=GRIDSTART(grid2);              // start value
// 	  interpolationStartEndIndex(1,grid,grid2)=GRIDSTART(grid2)+NG(grid2)-1;  // end value
// 	  if( true || cg.interpolationIsImplicit(grid,grid2,0) )
// 	    interpolationStartEndIndex(2,grid,grid2)= interpolationStartEndIndex(1,grid,grid2);
// 	  // fix this: put any implicit points first
// 	  // 	   else if( ngi(grid2)>0 )
// 	  // 	     interpolationStartEndIndex(2,grid,grid2)=GRIDSTART(grid2)+ngi(grid2)-1; // end value for implicit pts.
// 	}
//       }
        	  
//       if( numberOfDimensions==2 )
//       {
// 	for( int i=ia; i<=ib; i++ )
// 	{
// 	  grid2=INTERPOLEEGRID(i);
// 	  int j=GRIDSTART(grid2);

// 	  INTERPOLEEGRID1(j)=grid2;
// 	  INTERPOLATIONPOINT1(j,0)=INTERPOLATIONPOINT(i,0);
// 	  INTERPOLATIONPOINT1(j,1)=INTERPOLATIONPOINT(i,1);
// 	  INTERPOLEELOCATION1(j,0)=INTERPOLEELOCATION(i,0);
// 	  INTERPOLEELOCATION1(j,1)=INTERPOLEELOCATION(i,1);
// 	  INTERPOLATIONCOORDINATES1(j,0)=INTERPOLATIONCOORDINATES(i,0);
// 	  INTERPOLATIONCOORDINATES1(j,1)=INTERPOLATIONCOORDINATES(i,1);
// 	  VARIABLEINTERPOLATIONWIDTH1(j)=VARIABLEINTERPOLATIONWIDTH(i);
              		  
// 	  GRIDSTART(grid2)++;
// 	}
//       }
//       else
//       {
// 	for( int i=ia; i<=ib; i++ )
// 	{
// 	  grid2=INTERPOLEEGRID(i);
// 	  int j=GRIDSTART(grid2);
// 	  INTERPOLEEGRID1(j)=grid2;
// 	  INTERPOLATIONPOINT1(j,0)=INTERPOLATIONPOINT(i,0);
// 	  INTERPOLATIONPOINT1(j,1)=INTERPOLATIONPOINT(i,1);
// 	  INTERPOLATIONPOINT1(j,2)=INTERPOLATIONPOINT(i,2);
// 	  INTERPOLEELOCATION1(j,0)=INTERPOLEELOCATION(i,0);
// 	  INTERPOLEELOCATION1(j,1)=INTERPOLEELOCATION(i,1);
// 	  INTERPOLEELOCATION1(j,2)=INTERPOLEELOCATION(i,2);
// 	  INTERPOLATIONCOORDINATES1(j,0)=INTERPOLATIONCOORDINATES(i,0);
// 	  INTERPOLATIONCOORDINATES1(j,1)=INTERPOLATIONCOORDINATES(i,1);
// 	  INTERPOLATIONCOORDINATES1(j,2)=INTERPOLATIONCOORDINATES(i,2);
// 	  VARIABLEINTERPOLATIONWIDTH1(j)=VARIABLEINTERPOLATIONWIDTH(i);
              		  
// 	  GRIDSTART(grid2)++;
// 	}
//       }
        	  
//       //      interpoleeLocation1.display("IL after");

//       interpoleeGrid.reference(interpoleeGrid1);
//       interpolationPoint.reference(interpolationPoint1);
//       interpoleeLocation.reference(interpoleeLocation1);
//       variableInterpolationWidth.reference(variableInterpolationWidth1);
//       interpolationCoordinates.reference(interpolationCoordinates1);
            

//     } // if nig>0
        
//   }
//   //  interpolationStartEndIndex.display("ISTARTEND");
        	  
// }
// }


//=======================================================================
// Mark coarse grid mask at interp points outside bc=0 boundaries 
//=======================================================================


// ====================================================================================
// Macro: Evaluate the x-coordinates of the interpolation points
//   IA(i,0:3) (input) : index locations of interp points
// ====================================================================================

// =======================================================================================
//  Macro: Evaluate the "r" coordinates of a list of points
//  ib(i,*) (input) : list of points 
//  xa(i,*) (input) : x-coords of the points  
// =======================================================================================


//\begin{>>OgmgInclude.tex}{\subsection{buildExtraLevels}}
int Ogmg::
buildExtraLevelsNew(CompositeGrid & mg)
// ========================================================================================
//     *** NEW parallel version *** 091203 
//  /Description: 
//       Build extra multigrid levels. This routine will create coarser levels automatically.
// The tricky part is to determine how to interpolate on the new coarser levels.
// After a grid is coarsened it may no longer have enough interpolation points. We add new interpolation
// points to fill in the gaps. The width of the interpolation stencil is reduced, on a point by point
// basis, if necessary.
//
// /mg (input/output): 
//\end{OgmgInclude.tex} 
// =========================================================================================
{
    real time0=getCPU();
    const int np= max(1,Communication_Manager::numberOfProcessors());
    CompositeGrid & mgcg = multigridCompositeGrid();
    
    int debugSave=debug;

  // debug=7;  // ***
    int debugb=debug; // 7; // debug

  // printF("\n ********************** buildExtraLevels debugb=%i **************************\n",debugb);

  // --- The CompositeGrid mg is supplied by the USER and we do not want to change it.
  //      Instead we build another copy, mgcg that will contain the extra multigrid levels.


    if( parameters.saveGridCheckFile && myid==0 )
    {
        printF(" buildExtraLevelsNew: parameters.saveGridCheckFile=%i\n",(int)parameters.saveGridCheckFile);
    // save a check file containing information about the coarse grid levels
        if( gridCheckFile==NULL )
        {
            aString name="ogmg";
            if( numberOfInstances>1 )
            {
	// Give different names to the grid check file if we have more than 1 instance of Ogmg:
      	sPrintF(name,"ogmg%i",numberOfInstances);
            }
            aString gridCheckFileName;
            sPrintF(gridCheckFileName,"%s.%s.coarseGrids.NP%i.check",(const char*)name,(const char*)gridName,np);
            gridCheckFile = fopen((const char*)gridCheckFileName,"w" );     
            printF("Saving the check file %s\n",(const char*)gridCheckFileName);
        }
    }

  // *NOTE* For moving grid do the following; otherwise the statement "mgcg=mg" seems to over-write
  //    the MappedGrids in the version of "mg" that was used in the previous call!
  // mgcg.destroy(CompositeGrid::EVERYTHING);  // trouble with this
    if( mgcg.numberOfComponentGrids()>0 )
    {
        for( int grid=0; grid<mgcg.numberOfComponentGrids(); grid++ )
        {
            mgcg[grid].breakReference();
        }
    }
    

    int grid;
    if( false )
    {
        
        mgcg=mg;  // deep copy for now *******************************************************************************

    }
    else if( true )
    {
    // mgcg.reference(mg);  // problems with this, mg seems to get changed below

    // mgcg.destroy(CompositeGrid::EVERYTHING);  // *wdh* 040831 -- added to fix bug with moving grids ---
        
        mgcg=mg;
    // now reference the grids so we don't keep two copies of the big arrays.
        
        for( grid=0; grid<mg.numberOfComponentGrids(); grid++ )
        {
            mgcg[grid].reference(mg[grid]);
        }
    
    // we could also reference interpolation arrays.

        mgcg.updateReferences();

        if( false )
        {
            mg.interpolationStartEndIndex.display("buildExtraLevels: mg.interpolationStartEndIndex");
            mgcg.interpolationStartEndIndex.display("buildExtraLevels: mgcg.interpolationStartEndIndex");
        }
        
    }
    else
    { 
    // we need to reference MappedGrids and Interpolation info.


    // this does not work
    // mgcg.setNumberOfDimensionsAndGrids(mg.numberOfDimensions(),mg.numberOfComponentGrids());

        for( grid=0; grid<mg.numberOfComponentGrids(); grid++ )
        {
      // mgcg[grid].reference(mg[grid].mapping());
      // mgcg[grid].reference(mg[grid]);
            mgcg.add(mg[grid]);           // add will make a reference
        }
        mgcg.updateReferences();
    // ** mgcg.update(MappedGrid::THEcenter);
    
    // mgcg.update(CompositeGrid::THElists | CompositeGrid::THEmultigridLevel);
    // mgcg.update(CompositeGrid::THElists | CompositeGrid::THEmultigridLevel);
    }
    mgcg.update(CompositeGrid::THEmultigridLevel);


    if( false )
        mgcg.multigridLevel[0].interpolationStartEndIndex.display("buildExtraLevels: after mgcg.update(CompositeGrid::THEmultigridLevel): mgcg.multigridLevel[0].interpolationStartEndIndex");
    
  // ***** fix this in CompositeGrid ****
    mgcg.multigridLevel[0].interpolationStartEndIndex=mgcg.interpolationStartEndIndex;
    

    const int numberOfDimensions = mgcg.numberOfDimensions();
    IntegerArray factor(3);
    factor=2;

    const int level0=mg.numberOfMultigridLevels()-1;
    int l, level;
    Range Rx=mgcg.numberOfDimensions();

    for( grid=0; grid<mgcg.numberOfComponentGrids(); grid++ )
    {
        for( int axis=0; axis<numberOfDimensions; axis++ )
        {
            for( int side=Start; side<=End; side++ )
            {
      	if( mgcg[grid].boundaryCondition()(side,axis) > 0 && mgcg[grid].numberOfGhostPoints()(side,axis)<2 )
      	{
        	  printF("Ogmg::buildExtraLevels:ERROR: The grid must be made with numberOfGhostPoints>=2 "
                                    "on all physical boundaries\n");
                    Overture::abort();
      	}
            }
        }
    }



  // --- determine the maximum number of levels we can add. For now we must be able to coarsen by
  //     a factor of two along each axis.

    IntegerArray maxLevels(mgcg.numberOfComponentGrids()); // number of levels we can add to each grid
    maxLevels=0;
    const int minimumNumberOfPointsOnCoarseGrid=orderOfAccuracy/2;
    for( grid=0; grid<mgcg.numberOfComponentGrids(); grid++ )
    {
        const IntegerArray & gridIndexRange = mgcg.multigridLevel[level0][grid].gridIndexRange();

    // display((gridIndexRange(End,Rx)-gridIndexRange(Start,Rx)),"gridIndexRange(End,Rx)-gridIndexRange(Start,Rx)");

        for( int m=0; m<parameters.maximumNumberOfExtraLevels; m++ )
        {
            const int pow2 = (int)pow(2,m+1);

      // printF("pow2 = %i\n",pow2);
            
//       display(((gridIndexRange(End,Rx)-gridIndexRange(Start,Rx)) % pow2),
//            "(gridIndexRange(End,Rx)-gridIndexRange(Start,Rx)) % pow2 )");
            
            bool powerOfTwo=TRUE;
            for( int axis=0; axis<numberOfDimensions; axis++ )
            {
      	if( (((gridIndexRange(End,axis)-gridIndexRange(Start,axis)) % pow2 )!=0)  || // not divisible by 2
          	    (((gridIndexRange(End,axis)-gridIndexRange(Start,axis))/pow2) 
                                                        <=minimumNumberOfPointsOnCoarseGrid ) )// at least this many points on coarse grid
      	{
        	  powerOfTwo=FALSE;
                    break;
      	}
            }
            if( !powerOfTwo )
                break;

// A++ bug:
//       if( (max( (gridIndexRange(End,Rx)-gridIndexRange(Start,Rx)) % pow2 )!=0)  || // divisible by 2
//           (min( (gridIndexRange(End,Rx)-gridIndexRange(Start,Rx))/pow2) <2 ) ) // at least 1 points on coarse grid
//       {
// 	// this grid cannot be coarsened anymore
// 	break;
//       }
            maxLevels(grid)=m+1;
        }
        
    }
  // display(maxLevels,"Maximum number of extra levels per grid");
    if( debugb & 2 )
    {
        for( int grid=0; grid<mgcg.numberOfComponentGrids(); grid++ )
        {
            printF("Ogmg:INFO: %i multigrid levels could be built on grid %i (%s)\n",maxLevels(grid),grid,
           	     (const char*)mgcg[grid].getName());
        }
    }
    
    numberOfExtraLevels=min(maxLevels);

    if( debugb & 2 )
    {
        printF("**** Ogmg::buildExtraLevels: this grid supports %i extra MG levels (numberOfExtraLevels). *****\n"
                      "**** At most %i levels will be made (maximumNumberOfExtraLevels).                         *****\n",
                  numberOfExtraLevels, parameters.maximumNumberOfExtraLevels);
        fPrintF(debugFile,
                      "**** Ogmg::buildExtraLevels: this grid supports %i extra MG levels (numberOfExtraLevels). *****\n"
                      "**** At most %i levels will be made (maximumNumberOfExtraLevels).                         *****\n",
                  numberOfExtraLevels, parameters.maximumNumberOfExtraLevels);
    }
    
  // --- Here we add the grids for the extra levels
    for( l=level0; l<level0+numberOfExtraLevels; l++ )
    {
        level=l+1;
        for( grid=0; grid<mgcg.numberOfComponentGrids(); grid++ )
            mgcg.addMultigridCoarsening(factor,level,grid);
    }
    
  // mgcg.update(CompositeGrid::THElists | CompositeGrid::THEmultigridLevel);
  // mgcg.update();
    //  Tell the CompositeGrid that the interpolation data have been computed:

  // *wdh* 061123
  // mgcg.makeCompleteMultigridLevels();
    

// *wdh* 061123  
    bool newWay=true;  // *wdh* 061123  -- make sure the interp data lists are consistent between mgcg and levels
    if( newWay )
    {
    // update the MG level and make all interpolation arrays the correct length
        if( mgcg.numberOfBaseGrids()>1 )
        {
      // trouble here if there are no interp pts: (--fix this---)
            mgcg.update( CompositeGrid::THEmultigridLevel | 
               		   CompositeGrid::THEinterpolationPoint       |
               		   CompositeGrid::THEinterpoleeGrid           |
               		   CompositeGrid::THEinterpoleeLocation       |
               		   CompositeGrid::THEinterpolationCoordinates);

            if( debug & 2 )
            {
      	printF("@@@ Ogmg:BuildExtraLevels: after adding extra grids for MG levels : mgcg.numberOfGrids()=%i, "
             	       "mgcg.numberOfComponentGrids()=%i, "
             	       "mgcg.interpolationPoint.getLength=%i\n",
             	       mgcg.numberOfGrids(),mgcg.numberOfComponentGrids(),mgcg.interpolationPoint.getLength());
            }
        }
        else
        {
            mgcg.update( CompositeGrid::THEmultigridLevel );
        }
        
    }
    else
    {
        mgcg.update( CompositeGrid::THEmultigridLevel);
    }
    
  // Assign work-loads and load balance the CompositeGrid and all multigrid levels.
    loadBalance( mg, mgcg );
    

//   bool loadBalanceGrids=false;
//   #ifdef USE_PPP
//     loadBalanceGrids=true;
//   #endif
//   if( loadBalanceGrids )
//   {
//     // From GridCollection.C : 

//     if( parameters.loadBalancer==NULL )
//     {
//       parameters.loadBalancer = new LoadBalancer;
//       // NOTE: when there is only 1 grid then the default load-balancer will always use all-to-all
//       parameters.loadBalancer->setLoadBalancer(LoadBalancer::KernighanLin);
//     }
        
//     // --- Make the master gridDistributionList (GDL) be consistent with the MG level GDL's -- *wdh* 2013/08/29 
//     GridDistributionList & masterGDL = mgcg->gridDistributionList;
//     masterGDL.resize(mgcg.numberOfGrids(),GridDistribution());

//     LoadBalancer & loadBalancer = *parameters.loadBalancer; // could there already be a load balancer with cg ? 

//     // Level 0 : set gridDistribution equal to those in the incoming CompositeGrid
//     int level=0;
//     CompositeGrid & cg = mgcg.multigridLevel[level];
//     GridDistributionList & gridDistributionList = cg->gridDistributionList;
//     gridDistributionList.resize(cg.numberOfComponentGrids());
//     for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
//     {
//       gridDistributionList[grid]=mg->gridDistributionList[grid];
//     }
        
//     // load balance levels 1...
//     for( int l=1; l<mgcg.numberOfMultigridLevels(); l++ )
//     {
//       int level=l;
//       CompositeGrid & cg = mgcg.multigridLevel[level];

//       GridDistributionList & gridDistributionList = cg->gridDistributionList;
//       // GridDistributionList gridDistributionList;
        
//       // work-loads per grid are based on the number of grid points by default:
//       loadBalancer.assignWorkLoads( cg,gridDistributionList );

//       loadBalancer.determineLoadBalance( gridDistributionList );

//       // From GenericGridCollection.C: get: 
//       // Assign parallel distribution (if the info is there)
//       for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
//       {
// 	int pStart=-1,pEnd=0;
// 	gridDistributionList[grid].getProcessorRange(pStart,pEnd);
// 	if( Ogmg::debug & 2  )
// 	{
// 	  printF("Ogmg:buildExtraLevelsNew:assignLoadBalance: assign level=%i grid=%i to processors=[%i,%i]\n",
// 		 level,grid,pStart,pEnd);
// 	}
// 	if( false )
//           printF(" level=%i grid=%i gridNumber=%i componentGridNumber=%i\n",level,grid,cg.gridNumber(grid),
// 		 cg.componentGridNumber(grid));
        	  
// 	cg[grid].specifyProcesses(Range(pStart,pEnd));

//         // Also set the distribution in the master GDL:
//         const int masterGridNumber = cg.gridNumber(grid); // here is the grid number in the master list of grids
//         masterGDL[masterGridNumber]=gridDistributionList[grid]; 
      	
//       } // end for grid

//     } // end for l 



//   }


    mgcg.update( MappedGrid::THEmask ); // ********** no need to build center for rectangular grids
  // mgcg.update( MappedGrid::THEmask | MappedGrid::THEcenter | CompositeGrid::THEinterpolationPoint );

    if( np >1 )
    { // display the parallel distribution
        mgcg.displayDistribution("Top-level mgcg grid",infoFile);
        if( false )
        {
            for( int grid=0; grid<mgcg.numberOfComponentGrids(); grid++ )
            {
      	intArray & mask = mgcg[grid].mask();
      	intSerialArray maskLocal; getLocalArrayWithGhostBoundaries(mask,maskLocal);
      	printf("mgcg: myid=%i grid=%i maskLocal=[%i,%i][%i,%i]\n",myid,grid,maskLocal.getBase(0),maskLocal.getBound(0),
             	       maskLocal.getBase(1),maskLocal.getBound(1));
            }
        }
        
        for( int l=0; l<mgcg.numberOfMultigridLevels(); l++ )
            mgcg.multigridLevel[l].displayDistribution(sPrintF("multigrid level %i",l),infoFile);
    }

    if( true )
    {
    // For coarser level grids we do NOT share the vertex array in the grid with the mapping grid
    // used by the inverse (Otherwise the mapping inverse may get an extremely coarse grid) *wdh* 100424
        for( int level=1; level<mgcg.numberOfMultigridLevels(); level++ )
        {
            CompositeGrid & cg = mgcg.multigridLevel[level]; 
            for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
            {
      	cg[grid].setShareGridWithMapping(false);
            }
        }
    }

    if( mgcg.numberOfComponentGrids()<=1 ||
            mgcg.numberOfMultigridLevels()==1 )
    {
    // ****** return here if there is only one component grid  or one MG level ******

        if( FALSE && level0==0 )
        {
      // now test out the validity of the newly created levels.
            for( l=level0; l<level0+numberOfExtraLevels; l++ )
            {
      	level=l+1;
      	printf("\n\n **************** check extra level %i ******************* \n\n",level);
      	checkGrid( mgcg.multigridLevel[level],ps,debugb );
            }
        }


        tm[timeForBuildExtraLevels]+=getCPU()-time0;
        return 0;
    }
    
    Range Rg=mgcg.numberOfComponentGrids();

  // update interpolation data on multigrid level 0  -- why is this needed ?
    if( newWay )
    {

    //    CompositeGrid & cg = mgcg.multigridLevel[0];
    //     ::display(mgcg.numberOfInterpolationPoints,"buildExtra: mgcg.numberOfInterpolationPoints");
    //     ::display(cg.numberOfInterpolationPoints,"buildExtra: cg.numberOfInterpolationPoints (level=0)");
    //     for( grid=0; grid<cg.numberOfComponentGrids(); grid++ )
    //     {
    //       ::display(cg.interpoleeGrid[grid],"cg.interpoleeGrid[grid]");
    //       ::display(cg.variableInterpolationWidth[grid],"cg.variableInterpolationWidth[grid]");
    //       ::display(cg.interpolationPoint[grid],"cg.interpolationPoint[grid]");        
    //       ::display(cg.interpoleeLocation[grid],"cg.interpoleeLocation[grid]");        
    //       ::display(cg.interpolationCoordinates[grid],"cg.interpolationCoordinates[grid]");  
    //     }
    }
    else // try turning this off 061123
    {
        CompositeGrid & cg = mgcg.multigridLevel[0];

    //     ::display(mgcg.numberOfInterpolationPoints,"buildExtra: mgcg.numberOfInterpolationPoints");
    //     ::display(cg.numberOfInterpolationPoints,"buildExtra: cg.numberOfInterpolationPoints (level=0)");
            

        cg.numberOfInterpolationPoints(Rg)=mgcg.numberOfInterpolationPoints(Rg);
    
        cg.update(
            CompositeGrid::THEinterpolationPoint       |
            CompositeGrid::THEinterpoleeGrid           |
            CompositeGrid::THEinterpoleeLocation       |
            CompositeGrid::THEinterpolationCoordinates ,
            CompositeGrid::COMPUTEnothing);

        for( grid=0; grid<cg.numberOfComponentGrids(); grid++ )
        {
            cg.interpoleeGrid[grid]            =mgcg.interpoleeGrid[grid];
            cg.variableInterpolationWidth[grid]=mgcg.variableInterpolationWidth[grid];
            cg.interpolationPoint[grid]        =mgcg.interpolationPoint[grid];
            cg.interpoleeLocation[grid]        =mgcg.interpoleeLocation[grid];
            cg.interpolationCoordinates[grid]  =mgcg.interpolationCoordinates[grid];
        }

    //  Tell the CompositeGrid that the interpolation data have been computed:
        mgcg->computedGeometry |=
            CompositeGrid::THEmask                     |
            CompositeGrid::THEinterpolationCoordinates |
            CompositeGrid::THEinterpolationPoint       |
            CompositeGrid::THEinterpoleeLocation       |
            CompositeGrid::THEinterpoleeGrid;

        cg->computedGeometry |=
            CompositeGrid::THEmask                     |
            CompositeGrid::THEinterpolationCoordinates |
            CompositeGrid::THEinterpolationPoint       |
            CompositeGrid::THEinterpoleeLocation       |
            CompositeGrid::THEinterpoleeGrid;

    // we also need to mark each MappedGrid (or else we lose the mask if we put/get to a file)
        for( grid=0; grid<cg.numberOfComponentGrids(); grid++ )
            cg[grid]->computedGeometry |= MappedGrid::THEmask;     // added 030829 *wdh*
    }
    
  // mgcg.update();
  // display(mgcg.interpolationPoint[0],"mgcg.interpolationPoint[0]");
  // displayMask(mgcg.multigridLevel[0][0].mask(),"mgcg.multigridLevel[0][0].mask");
  // display(mgcg.multigridLevel[0].interpolationPoint[0],"mgcg.multigridLevel[level].interpolationPoint[0]");
    
    
      CompositeGrid & cg00 = mgcg.multigridLevel[0];
   // cg00.update();
      if( debugb & 8 )
      {
          for( grid=0; grid<cg00.numberOfComponentGrids(); grid++ )
          {
              display(mgcg.variableInterpolationWidth[grid],"mgcg.variableInterpolationWidth[grid]",debugFile);
              display(cg00.variableInterpolationWidth[grid],"cg00.variableInterpolationWidth[grid]",debugFile);
          }
      }
      
      
    intSerialArray *iaA = new intSerialArray [mgcg.numberOfComponentGrids()];                 
    intSerialArray *interpoleeGridA = new intSerialArray [mgcg.numberOfComponentGrids()];     
    intSerialArray *interpolationPointA = new intSerialArray [mgcg.numberOfComponentGrids()]; 
    intSerialArray *interpoleeLocationA = new intSerialArray [mgcg.numberOfComponentGrids()]; 
    intSerialArray *variableInterpolationWidthA = new intSerialArray [mgcg.numberOfComponentGrids()]; 
    realSerialArray *interpolationCoordinatesA = new realSerialArray [mgcg.numberOfComponentGrids()]; 


    Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
    Index Jv[3], &J1=Jv[0], &J2=Jv[1], &J3=Jv[2];

    Index Igv[3], &Ig1=Igv[0], &Ig2=Igv[1], &Ig3=Igv[2];

    int iv[3], &i1=iv[0], &i2=iv[1], &i3=iv[2];
    int jv[3], &j1=jv[0], &j2=jv[1], &j3=jv[2];      
    int kv[3], &k1=kv[0], &k2=kv[1], &k3=kv[2];      
    int kpv[3], &kp1=kpv[0], &kp2=kpv[1], &kp3=kpv[2];      
    int isv[3], &is1=isv[0], &is2=isv[1], &is3=isv[2];
    int I1Base,I2Base,I3Base;
    int I1Bound,I2Bound,I3Bound;

    Range all;

  // --------------------------------------------------------------------------------
  // ---- Now update the mask and interpolation equations for the extra levels. -----
  // --------------------------------------------------------------------------------

    real timeForBuildMask=0., timeForBuildInterpolation=0., timeForValidStencil=0.;

    intSerialArray *pMask1=NULL;

    const int numberOfComponentGrids = mgcg.numberOfComponentGrids();

  // allocate space for local index arrays on the fine and coarse grid 
    IntegerArray *pGridIndexRange0     = new IntegerArray [numberOfComponentGrids];
  // IntegerArray *pDimension0          = new IntegerArray [numberOfComponentGrids];
  // IntegerArray *pIndexRange0         = new IntegerArray [numberOfComponentGrids];
  // IntegerArray *pExtendedIndexRange0 = new IntegerArray [numberOfComponentGrids];
    IntegerArray *pBoundaryCondition0  = new IntegerArray [numberOfComponentGrids];

    IntegerArray *pGridIndexRange1     = new IntegerArray [numberOfComponentGrids];
    IntegerArray *pDimension1          = new IntegerArray [numberOfComponentGrids];
  // IntegerArray *pIndexRange1         = new IntegerArray [numberOfComponentGrids];
    IntegerArray *pExtendedIndexRange1 = new IntegerArray [numberOfComponentGrids];
    IntegerArray *pBoundaryCondition1  = new IntegerArray [numberOfComponentGrids];

    for( int grid=0; grid<mgcg.numberOfComponentGrids(); grid++ )
    {
        pGridIndexRange0[grid].redim(2,3);     pGridIndexRange0[grid]=0;
    // pDimension0[grid].redim(2,3);          pDimension0[grid]=0;
    // pIndexRange0[grid].redim(2,3);         pIndexRange0[grid]=0;
    // pExtendedIndexRange0[grid].redim(2,3); pExtendedIndexRange0[grid]=0;
        pBoundaryCondition0[grid].redim(2,3);  pBoundaryCondition0[grid]=0;

        pGridIndexRange1[grid].redim(2,3);     pGridIndexRange1[grid]=0;
        pDimension1[grid].redim(2,3);          pDimension1[grid]=0;
    // pIndexRange1[grid].redim(2,3);         pIndexRange1[grid]=0;
        pExtendedIndexRange1[grid].redim(2,3); pExtendedIndexRange1[grid]=0;
        pBoundaryCondition1[grid].redim(2,3);  pBoundaryCondition1[grid]=0;
        
    }
    
  // NOTE: we must update the boundingBox here since may require communication.
  // NOTE: for some reason we should use the bounding box in mgcg.multigridLevel[0], otherwise
  //  there is an error in computing the box.
  // mgcg.update(MappedGrid::THEboundingBox);  // for donor searches *wdh* 2012/06/07

  // Note: creating the bounding box does NOT require the vertex array for Cartesian grids
    mgcg.multigridLevel[0].update(MappedGrid::THEboundingBox);  // for donor searches *wdh* 2012/06/07
  //   if( true )
  //   {
  //     printF("***mgcg.multigridLevel[0] AFTER update THEboundingBox \n");
  //     for( int grid=0; grid<mgcg.multigridLevel[0].numberOfComponentGrids(); grid++ )
  //       mgcg.multigridLevel[0][grid].displayComputedGeometry();
  //   }

  // ------------------------------------------------------------------------------------------------
  // ------------------------------- START LOOP OVER LEVELS -----------------------------------------
  // ------------------------------------------------------------------------------------------------
    const int lastLevel=level0+numberOfExtraLevels;
    for( l=level0; l<lastLevel; l++ )
    {
        CompositeGrid & cg0 = l==0 ? mgcg : mgcg.multigridLevel[l];  // finer grid  ***********

        level=l+1;
        CompositeGrid & cg1 = mgcg.multigridLevel[level]; // coarser grid
        
    // cg1.update(MappedGrid::THEmask | MappedGrid::THEcenter);   // *********
        cg1.update(MappedGrid::THEmask );
        
        cg1->multigridLevelNumber=0; // *wdh* 091207  -- this is needed for cgCanInterp
      	

        IntegerArray numberOfInterpolationPoints(cg1.numberOfComponentGrids());
        numberOfInterpolationPoints=0;
        
        
        if( debugb & 2 )
        {
            printF("=========================== build level %i ================================\n",level);
            fprintf(pDebugFile,"\n=========================== build level %i ================================\n",level);
        }

        if( pMask1==NULL )
            pMask1= new intSerialArray [cg1.numberOfComponentGrids()];

        real timea=getCPU();
        for( int grid=0; grid<cg1.numberOfComponentGrids(); grid++ )
        {

            const IntegerArray & coarseningRatio = mgcg.multigridCoarseningRatio(Range(0,2),grid,level0);
            int cf[3], &cf1=cf[0], &cf2=cf[1], &cf3=cf[2];
            cf1=coarseningRatio(axis1);  // coarsening factor
            cf2=coarseningRatio(axis2);
            cf3=coarseningRatio(axis3);  
            assert(cf1==2 && (cf2==2 || numberOfDimensions<2) && (cf3==2 || numberOfDimensions<3));

            MappedGrid & mg0 = cg0[grid];
            intArray & mask0g = mg0.mask();

            MappedGrid & mg1 = cg1[grid];
            intArray & mask1g = mg1.mask();

            #ifdef USE_PPP
                intSerialArray mask0; getLocalArrayWithGhostBoundaries(mask0g,mask0);
                intSerialArray mask1s; getLocalArrayWithGhostBoundaries(mask1g,mask1s);
            #else
                intSerialArray & mask0 = mask0g;
                intSerialArray & mask1s = mask1g;
            #endif

      // --- NOTE: mask0g and mask1g may have different parallel distributions ---
      //       -> Thus the local masks : mask0 and mask1 may not overlap as in serial
      //       -> Therefore we make a temporary local coarse mask to match the local fine mask 

      //  Here is a local coarse mask that is a coarsening of the local fine mask
            intSerialArray & mask1 = pMask1[grid];

            mask1.redim(0);

            int extra=0;
      // getIndex(mg0.extendedIndexRange(),I1,I2,I3,extra); // what should this be ??
            getIndex(mg0.gridIndexRange(),I1,I2,I3,extra); // what should this be ??
            int includeGhost=0;  // include ghost or not???
            bool ok = ParallelUtility::getLocalArrayBounds(mask0g,mask0,I1,I2,I3,includeGhost);

            bool thisProcessorHasPoints=ok;
//       if( !ok ) 
//       {
//         fprintf(pDebugFile,"\n ==== Start coarse grid=%i level=%i ======\n"
//             		   "  *** this processor has no points on the mask ***\n",grid,level);
// 	continue;   // there must be no communication after this point
//       }

            assert( (numberOfDimensions==2 && cf[2]==1) || numberOfDimensions==3 );

            halfWidth1 = mg1.discretizationWidth(axis1)/2;
            halfWidth2 = numberOfDimensions>1 ? mg1.discretizationWidth(axis2)/2 : 0;
            halfWidth3 = numberOfDimensions>2 ? mg1.discretizationWidth(axis3)/2 : 0;
            const int hw[3] = { halfWidth1,halfWidth2,halfWidth3};  
        
      // -----------------------------------------------------------------------------------------
      // ------------------------- check the number of parallel ghost ----------------------------
      // For the algorithm we use: to mark extra interp points:  (hw=stencil half-width)
      //   The coarse grid mask needs hw parallel ghost, hw=(dw-1)/2, hw=(1,2) (2nd, 4th order), 
      //   THUS the fine grid needs 2*hw parallel ghost hw=(2,4) for (2nd, 4th order)
      //
      // NOTE: We could avoid this restriction by extra communication to mark the coarse grid mask
      //    values that we need. 
      // ----------------------------------------------------------------------------------------

      // Coarse mask: To mark point i with extra interp pts we need hw points to the right
      //              To mark point j with extra interp pts we need hw points to the left 
      //                   i   j 
      //     p=0   0   0   0   1   1   1   1   : eir marks which points belong to which processor
      //    ---+---+---+---+---+---+---+---+---+---+
      //    ---+---+---+---+---+---+
      //               +---+---+---+---+---+---+---+---+---+---
      // THUS we need 2*hw points off overlap on the fine mask 

            const int numParallelGhostNeeded=2*hw[0];
            for( int axis=0; axis<numberOfDimensions; axis++ )
            {
      	if( mask0g.getGhostBoundaryWidth(axis)<numParallelGhostNeeded )
      	{
        	  printF("Ogmg::buildExtraLevels: ERROR: the number of parallel ghost points must be at least %i if the "
                                  "discretization width=%i.\n"
                                  "  mask0g.getGhostBoundaryWidth(%i) = %i,\n"
                                  "  You should set the number of parallel ghost to %i or use the option -numParallelGhost=%i .\n",
             		 numParallelGhostNeeded,mg1.discretizationWidth(axis),
                                  axis,mask0g.getGhostBoundaryWidth(axis),
                                  numParallelGhostNeeded,numParallelGhostNeeded);
        	  OV_ABORT("ERROR");
      	}
            }

            for( int axis=0; axis<numberOfDimensions; axis++ )
            {
      	if( mg1.numberOfGhostPoints(0,axis)<hw[axis] ||
                        mg1.numberOfGhostPoints(1,axis)<hw[axis] )
      	{
        	  printF("Ogmg::ERROR: the number of ghost points must be at least %i if the discretization width =%i\n",
             		 hw[axis],mg1.discretizationWidth(axis));
        	  OV_ABORT("ERROR");
      	}
            }


      // -----------------------------------------
      // -------- Define index ranges ------------
      // -----------------------------------------

      // ---- NOTE:  ------------------
      //    eirLocal1 : partitions coarse grid points into non-overlapping sets
      //    Thus a given coarse point (i1,i2,i3) should belong to ONE AND ONLY ONE processor according to eir1Local

            const IntegerArray & gid0 = mg0.gridIndexRange();
            const IntegerArray & bc0 = mg0.boundaryCondition();

            const IntegerArray & ir1 = mg1.indexRange();
            const IntegerArray & gid1 = mg1.gridIndexRange();
            const IntegerArray & bc1 = mg1.boundaryCondition();

            const IntegerArray & extendedIndexRange = mg1.extendedIndexRange();

      // Determine local index bounds and boundary conditions

            IntegerArray & gidLocal0 =     pGridIndexRange0[grid];
      // IntegerArray & dimLocal0 =          pDimension0[grid];
      // IntegerArray &  irLocal0 =         pIndexRange0[grid];
      // IntegerArray & eirLocal0 = pExtendedIndexRange0[grid];
            IntegerArray &  bcLocal0 =  pBoundaryCondition0[grid];

            IntegerArray & gidLocal1 =     pGridIndexRange1[grid];
            IntegerArray & dimLocal1 =          pDimension1[grid];
      // IntegerArray &  irLocal1 =         pIndexRange1[grid];
            IntegerArray & eirLocal1 = pExtendedIndexRange1[grid];
            IntegerArray &  bcLocal1 =  pBoundaryCondition1[grid];

            const int numGhost=2; // fix me -- what should this be ? 
            for( int axis=0; axis<numberOfDimensions; axis++ )
            {
        //          p=0              p=1
        //  ...+--+--+--+--+--+  +--+--+--+--+  fine
        //                    n n+1
        //  ...   +-----+-----+     +-----+---   coarse (case I: m==n)
        //                    m     m+1 
        //     +-----+-----+     +-----+-----+--  coarse (case II, m<n)
        //                 m     m+1
      	if( mask0.getLength(axis)==0 )
      	{
	  // no points on this processor
                    thisProcessorHasPoints=false;
        	  for( int side=0; side<=1; side++ )
        	  {
          	    gidLocal0(side,axis) = -side;
          	    bcLocal0(side,axis)  = 0;

          	    gidLocal1(side,axis) = -side;
          	    dimLocal1(side,axis) = -side;
          	    bcLocal1(side,axis)  = 0;
	    // irLocal1(side,axis)  = -side;
          	    eirLocal1(side,axis) = -side;
        	  }
        	  continue;
      	}

      	if( mask0g.getLocalBase(axis) == mask0g.getBase(axis) ) 
      	{
        	  gidLocal0(0,axis) = gid0(0,axis); 
                    bcLocal0(0,axis)  = bc0(0,axis);

        	  gidLocal1(0,axis) = gid1(0,axis); 
                    dimLocal1(0,axis) = gidLocal1(0,axis)-numGhost;
                    bcLocal1(0,axis)  = bc1(0,axis);
	  // irLocal1(0,axis)  = ir1(0,axis); 
                    eirLocal1(0,axis) = extendedIndexRange(0,axis);
      	}
      	else
      	{ // this side is an internal parallel boundary
          // choose gidLocal0 to match the coarse grid pt 
                    int ia =  mask0g.getLocalBase(axis)+mask0g.getGhostBoundaryWidth(axis); // index-bound, no ghost
        	  int ja = (ia-gid0(0,axis)+cf[axis]-1)/cf[axis]+gid1(0,axis);   // coarse grid pt >=ia 
                    int ia0 = (ja-gid1(0,axis))*cf[axis]+gid0(0,axis);  // fine grid pt that matches ja 
        	  
// 	     gidLocal0(0,axis) = ia0-cf[axis];  // needs to match gidLocal1 below
//           bcLocal0(0,axis)  = -1; // parallel boundary gets a periodic BC

//           gidLocal1(0,axis) = ja-1;    // what should this be ? 
//           dimLocal1(0,axis) = gidLocal1(0,axis)-hw[axis];
//           bcLocal1(0,axis)  = -1; // parallel boundary gets a periodic BC
// 	  // irLocal1(0,axis)  = ja;
//           eirLocal1(0,axis) = ja; // ja-1; // ja; *wdh* 2012/06/10

          // ------ *wdh* 2012/06/10 -- fix for fourth-order 
        	  gidLocal0(0,axis) = ia0-cf[axis]*hw[axis];  // needs to match gidLocal1 below
                    bcLocal0(0,axis)  = -1; // parallel boundary gets a periodic BC

          // We need to mark extra interp points on line ja, thus  gidLocal1 must be offset by hw:
                    gidLocal1(0,axis) = ja-hw[axis];    
                    dimLocal1(0,axis) = gidLocal1(0,axis)-hw[axis];
                    bcLocal1(0,axis)  = -1; // parallel boundary gets a periodic BC
	  // irLocal1(0,axis)  = ja;
                    eirLocal1(0,axis) = ja; // ja-1; // ja; *wdh* 2012/06/10

      	}
        // --- side=1 ---
      	if( mask0g.getLocalBound(axis) == mask0g.getBound(axis) ) 
      	{
        	  gidLocal0(1,axis) = gid0(1,axis); 
                    bcLocal0(1,axis)  = bc0(1,axis);

	  // irLocal1(1,axis)  = ir1(1,axis); 
        	  gidLocal1(1,axis) = gid1(1,axis); 
        	  dimLocal1(1,axis) = gidLocal1(1,axis)+hw[axis]; 
                    bcLocal1(1,axis)  = bc1(1,axis);
                    eirLocal1(1,axis) = extendedIndexRange(1,axis);
      	}
      	else
      	{ // this side is an internal parallel boundary
                    int ia = mask0g.getLocalBound(axis)-mask0g.getGhostBoundaryWidth(axis);  // last pt (no parallel ghost)
        	  int ja = (ia-gid0(0,axis))/cf[axis]+gid1(0,axis);   // coarse grid pt <=ia 
                    int ia0 = (ja-gid1(0,axis))*cf[axis]+gid0(0,axis);  // fine grid pt that matches ja 

// 	  gidLocal0(1,axis) = ia0+cf[axis];  // needs to match gidLocal1 below
//           bcLocal0(1,axis)  = -1;  // parallel boundary gets a periodic BC

//           gidLocal1(1,axis) = ja+1;  // what should this be ? 
//           dimLocal1(1,axis) = gidLocal1(1,axis)+hw[axis];
//           bcLocal1(1,axis)  = -1;  // parallel boundary gets a periodic BC
// 	  // irLocal1(1,axis)  = ja;
//           eirLocal1(1,axis) = ja; // ja+1;  // =ja; *wdh* 2012/06/10 

          // ------ *wdh* 2012/06/10 -- fix for fourth-order 

          	  gidLocal0(1,axis) = ia0+cf[axis]*hw[axis];  // needs to match gidLocal1 below
        	  bcLocal0(1,axis)  = -1;  // parallel boundary gets a periodic BC

          // We need to mark extra interp points on line ja, thus  gidLocal1 must be offset by hw:
        	  gidLocal1(1,axis) = ja+hw[axis];  
        	  dimLocal1(1,axis) = gidLocal1(1,axis)+hw[axis];
        	  bcLocal1(1,axis)  = -1;  // parallel boundary gets a periodic BC
 	  // irLocal1(1,axis)  = ja;
        	  eirLocal1(1,axis) = ja; // ja+1;  // =ja; *wdh* 2012/06/10 

      	} 
      	
            } // end for axis
            
            if( !thisProcessorHasPoints )
            {
      	if( debug & 2 )
        	  fprintf(pDebugFile,"\n ==== Start coarse grid=%i level=%i ======\n"
              		  "  *** this processor has no points on the mask ***\n",grid,level);
      	continue;   // there must be no communication after this point
            }
            
            if( debug & 2 )
            {
      	const IntegerArray & dim0 = mg0.dimension();
      	const IntegerArray & dim1 = mg1.dimension();
      	fprintf(pDebugFile,
            		"\n ==== Start coarse grid=%i level=%i ======\n"
                                " Global bounds:\n"
            		"  fine  : gid=[%i,%i][%i,%i][%i,%i] dim=[%i,%i][%i,%i][%i,%i]\n"
            		"  coarse: gid=[%i,%i][%i,%i][%i,%i] dim=[%i,%i][%i,%i][%i,%i]\n"
            		" Local bounds: \n"
            		"  fine  : gid=[%i,%i][%i,%i][%i,%i] mask0=[%i,%i][%i,%i][%i,%i] \n"
            		"  coarse: gid=[%i,%i][%i,%i][%i,%i] dim=[%i,%i][%i,%i][%i,%i] eir=[%i,%i][%i,%i][%i,%i]\n",
                                grid,level,
                                gid0(0,0),gid0(1,0),gid0(0,1),gid0(1,1),gid0(0,2),gid0(1,2),
                                dim0(0,0),dim0(1,0),dim0(0,1),dim0(1,1),dim0(0,2),dim0(1,2),
                                gid1(0,0),gid1(1,0),gid1(0,1),gid1(1,1),gid1(0,2),gid1(1,2),
                                dim1(0,0),dim1(1,0),dim1(0,1),dim1(1,1),dim1(0,2),dim1(1,2),
                                gidLocal0(0,0),gidLocal0(1,0),gidLocal0(0,1),gidLocal0(1,1),gidLocal0(0,2),gidLocal0(1,2),
                                mask0.getBase(0),mask0.getBound(0),
                                mask0.getBase(1),mask0.getBound(1),
                                mask0.getBase(2),mask0.getBound(2),
                                gidLocal1(0,0),gidLocal1(1,0),gidLocal1(0,1),gidLocal1(1,1),gidLocal1(0,2),gidLocal1(1,2),
                                dimLocal1(0,0),dimLocal1(1,0),dimLocal1(0,1),dimLocal1(1,1),dimLocal1(0,2),dimLocal1(1,2),
                                eirLocal1(0,0),eirLocal1(1,0),eirLocal1(0,1),eirLocal1(1,1),eirLocal1(0,2),eirLocal1(1,2));
            }
            
//       J3=0;
//       for( int axis=0; axis<numberOfDimensions; axis++ )
//       {
//         int ia=Iv[axis].getBase(), ib=Iv[axis].getBound();

//         assert(  gid0(0,axis)==0 && gid1(0,axis)==0 );  // we probably assume this elsewhere in the code *************

//         assert( gid0(0,axis)==gid1(0,axis) ); // Do we need this ? 
// 	int ja = (ia-cf[axis]+1-gid0(0,axis))/cf[axis]+gid1(0,axis) -numGhost;  // coarse grid pt <= ia 
//         int jb = (ib+cf[axis]-1-gid0(0,axis))/cf[axis]+gid1(0,axis) +numGhost;  // coarse grid pt >= ib 
// 	Jv[axis]=Range(ja,jb);
//       }
            

            getIndex(dimLocal1,J1,J2,J3);
            mask1.redim(J1,J2,J3);


            int * mask0p = mask0.Array_Descriptor.Array_View_Pointer2;
            const int mask0Dim0=mask0.getRawDataSize(0);
            const int mask0Dim1=mask0.getRawDataSize(1);
#define MASK0(i0,i1,i2) mask0p[i0+mask0Dim0*(i1+mask0Dim1*(i2))]	
            
            int * mask1p = mask1.Array_Descriptor.Array_View_Pointer2;
            const int mask1Dim0=mask1.getRawDataSize(0);
            const int mask1Dim1=mask1.getRawDataSize(1);
#define MASK1(i0,i1,i2) mask1p[i0+mask1Dim0*(i1+mask1Dim1*(i2))]	
            
//        printF("------------mg0 from level %i, mg1 from level %i\n",l,level);
//        ::display(mgcg[grid].boundaryCondition(),"mgcg[grid].boundaryCondition()");
//        ::display(mg0.boundaryCondition(),"mg0.boundaryCondition()");
//        ::display(mg1.boundaryCondition(),"mg1.boundaryCondition()");
            

            if( debugb & 4 )
            {
                displayMask(mask0,sPrintF(buff,"Ogmg::buildExtraLevels: mask0 from level %i grid %i ",level-1,grid),pDebugFile);
      	if( debugb & 16 )
          	  displayMask(mask1,sPrintF("Ogmg::buildExtraLevels: mask1 for level %i (BEFORE)",level),pDebugFile);

                fflush(pDebugFile);
            }
            if( debugb & 16 )
            {
                Index J1,J2,J3;
                getIndex(mg0.gridIndexRange(),J1,J2,J3);   // Index's for coarse grid, one ghost line.
                displayMaskLaTeX(mask0g(J1,J2,J3),sPrintF(buff,"Ogmg::buildExtraLevels: mask0 from level %i grid %i ",
                                        level-1,grid),debugFile);

                getIndex(mg1.gridIndexRange(),J1,J2,J3);   // Index's for coarse grid, one ghost line.
                displayMaskLaTeX(mask1g(J1,J2,J3),sPrintF("Ogmg::buildExtraLevels: mask1 for level %i (BEFORE)",level),debugFile);
            }
            
            
      // **** here I need 2 ghost lines **** is this really necessary ??
      // *wdh* const int nGhostCoarse = orderOfAccuracy/4;
            const int nGhostCoarse = 0; // try this *wdh* 100111
            const int nGhostFine   = nGhostCoarse*2;

      // *** wdh 091204 ?? should we assign more pts in the periodic direction now ???

            getIndex(gidLocal0,I1,I2,I3,nGhostFine);   // Index's for fine grid -- include ghost lines
            I1=IndexBB(I1,cf[0]);  I2=IndexBB(I2,cf[1]);  I3=IndexBB(I3,cf[2]);  // set stride
    
            getIndex(gidLocal1,J1,J2,J3,nGhostCoarse);   // Index's for coarse grid, one ghost line.


      // ***************************************************************
      // ******** Copy fine mask to coarse mask ************************
      // ***************************************************************

            mask1=0;
            mask1(J1,J2,J3)=mask0(I1,I2,I3);


            if( debugb & 4 )
                displayMask(mask1,"Ogmg::buildExtraLevels: After initial copy: mask1=mask0 (stride 2)",pDebugFile);
            if( debugb & 16 )
            {
                displayMaskLaTeX(mask1g(J1,J2,J3),"Ogmg::buildExtraLevels: After initial copy: mask1=mask0 (stride 2)",debugFile);
            }
            

      // -----------------------------------------------------------
      // --- Mark mask at interp points outside bc=0 boundaries ----
      // -----------------------------------------------------------

      // markCoarseMaskAtBoundaries();
       // We are going to mark new interpolation points as those with mask==0 but neighbours mask>0
       // We do not want the ghost values to play a role in this marking so set mask==0 at ghost points.
       //        set mask==0 at on both ghost lines outside bc!=0 boundaries
       // ****** set mask==0 at 2nd ghost line outside interp boundaries.!
            for( int axis=0; axis<numberOfDimensions; axis++ )
            {
                for( int side=Start; side<=End; side++ )
                {
                    if( bcLocal1(side,axis)==0 )
                    {
            // *new* way : explicitly mark ghost points  -- now we don't need extra ghost points
                        if( orderOfAccuracy==2 )
                        {
      	// If the point on the boundary is a discretization point then we need to mark the
      	// the first ghost line as interpolation 
      	// const IntegerArray & gir = c.gridIndexRange();
                  	const IntegerArray & gir = gidLocal1;
                  	getBoundaryIndex(gidLocal1,side,axis,I1,I2,I3); // boundary
                  	int i1,i2,i3;
                  	is1=is2=is3=0;
                  	isv[axis]=1-2*side;
                  	FOR_3(i1,i2,i3,I1,I2,I3)
                  	{
                    	  if( MASK1(i1,i2,i3)>0 )
                      	    MASK1(i1-is1,i2-is2,i3-is3)=MappedGrid::ISinterpolationPoint;
                    	  else
                      	    MASK1(i1-is1,i2-is2,i3-is3)=0;
                  	}
      	// **** Now mark corners and edges **** 030829
      	//
      	//      |
      	//      +
      	//      |       bc=0 
      	//      +--+--+--+--+--+
      	//   X  I  I  I  I
      	//
      	//      Some points are marked twice
      	// (we cannot include this in the above loop since the mask is zero at ghost points)
                  	const int axisp1 = (axis+1) % numberOfDimensions;
                  	if( true)
                  	{
                    	  for( int side2=0; side2<=1; side2++ )
                    	  {
      	    // corner in 2D, or edge 3D   ----------------------- CHECK ME 091204 -------------------------
                      	    if( bcLocal1(side2,axisp1)>=0 ) // *wdh* 100101 -- do not set internal parallel sides 
                      	    {
                        	      Iv[axisp1]= gidLocal1(side2,axisp1); 
                        	      isv[axisp1]=1-2*side2;
                        	      FOR_3(i1,i2,i3,I1,I2,I3)
                        	      {
                        		if( MASK1(i1,i2,i3)>0 )
                          		  MASK1(i1-is1,i2-is2,i3-is3)=MappedGrid::ISinterpolationPoint;
                        		else
                          		  MASK1(i1-is1,i2-is2,i3-is3)=0;
                        	      }
                      	    }
                      	    if( numberOfDimensions==3 )
                      	    {
      	      // corners in 3D
                        	      const int axisp2=(axis+2) % numberOfDimensions;
                        	      for( int side3=0; side3<=1; side3++ )
                        	      {
                        		if( bcLocal1(side3,axisp2)>=0 ) // *wdh* 100101 -- do not set internal parallel sides
                        		{
                          		  Iv[axisp2]= gidLocal1(side3,axisp2);
                          		  isv[axisp2]=1-2*side3;
                          		  FOR_3(i1,i2,i3,I1,I2,I3)
                          		  {
                            		    if( MASK1(i1,i2,i3)>0 )
                              		      MASK1(i1-is1,i2-is2,i3-is3)=MappedGrid::ISinterpolationPoint;
                            		    else
                              		      MASK1(i1-is1,i2-is2,i3-is3)=0;
                          		  }
                        		}
                        	      }
                      	    }
                    	  }
                  	} // end if false
                  	if( numberOfDimensions==3 )
                  	{
      	  // other edge in 3D
                    	  Iv[axisp1]=Range(gidLocal1(0,axisp1),gidLocal1(1,axisp1)); // reset
                    	  isv[axisp1]=0;
                    	  const int axisp2=(axis+2) % numberOfDimensions;
                    	  for( int side3=0; side3<=1; side3++ )
                    	  {
                      	    if( bcLocal1(side3,axisp2)>=0 ) // *wdh* 100101 -- do not set internal parallel sides
                      	    {
                        	      Iv[axisp2]= gidLocal1(side3,axisp2);
                        	      isv[axisp2]=1-2*side3;
                        	      FOR_3(i1,i2,i3,I1,I2,I3)
                        	      {
                        		if( MASK1(i1,i2,i3)>0 )
                          		  MASK1(i1-is1,i2-is2,i3-is3)=MappedGrid::ISinterpolationPoint;
                        		else
                          		  MASK1(i1-is1,i2-is2,i3-is3)=0;
                        	      }
                      	    }
                    	  }
                  	}
                        }
                        else if( orderOfAccuracy==4 )
                        {
      	// If the point on the 1st ghost line is a discretization point then we need to mark the
      	// the second ghost line as interpolation 
                  	getGhostIndex(gidLocal1,side,axis,I1,I2,I3,1,2); // ghost line 1, 2 extra
                  	getGhostIndex(gidLocal1,side,axis,Ig1,Ig2,Ig3,2,2);  // ghost line 2, 2 extra
                  	where( mask1(I1,I2,I3)!=0 )
                  	{
                    	  mask1(Ig1,Ig2,Ig3)=MappedGrid::ISinterpolationPoint;
                  	}
                  	otherwise()
                  	{
                    	  mask1(Ig1,Ig2,Ig3)=0;
                  	}
      	// *wdh* added 030614
      	// If a point on the boundary is interpolation then we need to mark the first ghost line
      	// as interpolation
                  	getBoundaryIndex(gidLocal1,side,axis,I1,I2,I3,2); // boundary, 1 or 2 extra
                  	getGhostIndex(gidLocal1,side,axis,Ig1,Ig2,Ig3,1,2);  // ghost line, 1 or 2 extra
                  	where( mask1(I1,I2,I3)<0 )
                  	{
                    	  mask1(Ig1,Ig2,Ig3)=MappedGrid::ISinterpolationPoint;
                  	}
                        }
                    }
                    else  // mg1.bc !=0 : 
                    {
                        if( false )
                        {
      	// --- needs to be fixed for parallel ghost --
      	// this not needed in parallel I think 
                  	getGhostIndex(gidLocal1,side,axis,I1,I2,I3,2,2); // ghost line 2, 2 extra
                  	mask1(I1,I2,I3)=0;
                  	getGhostIndex(gidLocal1,side,axis,I1,I2,I3,1,2); // ghost line 1, 2 extra
                  	mask1(I1,I2,I3)=0;
                        }
                    }
                }
              } // end for axis 

            
            if( debugb & 4 )
                displayMask(mask1,sPrintF(buff,"Ogmg::buildExtraLevels: mask1 for level %i grid %i"
                          " (Before marking extra interp)",level,grid),pDebugFile);


      // ***********************************************************
      // ***  mark any extra interpolation points on coarse grid  **
      // ***********************************************************
      // Mark a point with mask==0 but with a neighbour mask>0
      // The number of neighbours we check depends on how wide the discretization width is.

            getIndex(gidLocal1,I1,I2,I3); 

            const int * peir = &eirLocal1(0,0);
            #define eir(side,axis) peir[(side)+2*(axis)]

            if( debugb & 4 )
      	fprintf(pDebugFile,">>>>level=%i grid=%i isPeriodic=%i,%i,%i I1=[%i,%i] I2=[%i,%i] I2=[%i,%i] "
                                "hw=[%i,%i,%i] eir=[%i,%i][%i,%i][%i,%i]\n",
            		level,grid,mg1.isPeriodic(0),mg1.isPeriodic(1),mg1.isPeriodic(2),
                                I1.getBase(),I1.getBound(),I2.getBase(),I2.getBound(),I3.getBase(),I3.getBound(),
                                halfWidth1,halfWidth2,halfWidth3,
                                eir(0,0),eir(1,0),eir(0,1),eir(1,1),eir(0,2),eir(1,2));
            
      // NOTE: We should not count "interp" points at periodic images 
            FOR_3D(i1,i2,i3,I1,I2,I3)
            {
      	if( MASK1(i1,i2,i3)>0 ) // discretization point
      	{
        	  for( int m3=-halfWidth3; m3<=halfWidth3; m3++ )      
        	  {
          	    for( int m2=-halfWidth2; m2<=halfWidth2; m2++ )
          	    {
            	      for( int m1=-halfWidth1; m1<=halfWidth1; m1++ )
            	      {
            		if( MASK1(i1+m1,i2+m2,i3+m3)==0 )
            		{
                                    j1=i1+m1;
              		  j2=i2+m2;
              		  j3=i3+m3;
              		  if( j1>=eir(0,0) && j1<=eir(1,0) &&
                                            j2>=eir(0,1) && j2<=eir(1,1) &&
                                            j3>=eir(0,2) && j3<=eir(1,2) )
              		  {
                		    MASK1(i1+m1,i2+m2,i3+m3)= MappedGrid::ISinterpolationPoint;
              		  }
            		}
            	      }
          	    }
        	  }
      	}
            }
            
            
      // ******** communication here :  THIS DOES NOT WORK IN PARALLEL
      // mg1.mask().periodicUpdate(); // *wdh* 021006 needed for stir.mg.hdf for example

            if( debugb & 4 )
                displayMask(pMask1[grid],sPrintF(buff,"Ogmg::buildExtraLevels: mask1 for level %i grid %i"
                      " (AFTER marking extra interp)",level,grid),
                                        pDebugFile);
        
            if( debugb & 16 )
            {
                Index J1,J2,J3;
                getIndex(mg1.gridIndexRange(),J1,J2,J3);   // Index's for coarse grid, one ghost line.
                intArray & mask1g = mg1.mask();
                displayMaskLaTeX(mask1g(J1,J2,J3),
                            sPrintF(buff,"Ogmg::buildExtraLevels: mask1 for level %i grid %i (AFTER)",level,grid),debugFile);
            }
        
            
        } // end for grid 


    // -------------------------------------------------------------
    // ---- copy local mask1's into the mask1g distributed array ---
    // -------------------------------------------------------------
        for( int grid=0; grid<cg1.numberOfComponentGrids(); grid++ )
        {

            MappedGrid & mg0 = cg0[grid];
            intArray & mask0g = mg0.mask();
            MappedGrid & mg1 = cg1[grid];
            intArray & mask1g = mg1.mask();
            #ifdef USE_PPP
                intSerialArray mask0; getLocalArrayWithGhostBoundaries(mask0g,mask0);
                intSerialArray & mask1 = pMask1[grid];
            #else
                intSerialArray & mask0 = mask0g;
                intSerialArray & mask1 = mask1g;
            #endif
            const IntegerArray & eirLocal1 = pExtendedIndexRange1[grid];

      //  mask1SerialProcessorSet : list of processors where the local mask1's are found, this happens
      //                            to be the same as the list of processors for mask0g:
            const intSerialArray & mask1SerialProcessorSet = mask0g.getPartition().getProcessorSet();

      // Jv : copy these points from mask1 
      // Iv : total set of points we mean to fill in mask1g 
        
            const IntegerArray & egid = extendedGridIndexRange(mg1);
            getIndex(egid,I1,I2,I3);
            bool thisProcessorHasPoints = eirLocal1(0,0) <= eirLocal1(1,0);
            if( thisProcessorHasPoints )
            {
      	getIndex(eirLocal1,J1,J2,J3);
            }
            else
            {
      	J1=all; J2=all; J3=all;
            }
      	
            CopyArray::copyArray( mask1,Jv,mask1SerialProcessorSet, mask1g, Iv );

            mg1.mask().periodicUpdate();
            mask1g.updateGhostBoundaries();  

            if( debug & 4 )
            {
      	intSerialArray mask1Local; getLocalArrayWithGhostBoundaries(mask1g,mask1Local);
      	displayMask(mask1Local,sPrintF("Ogmg::buildExtraLevels: level=%i, grid=%i, mask1Local "
                               				       "after serial-to-distributed copy",level,grid),pDebugFile);
            }
        } // end for grid



        if( false )
        {
            OV_ABORT("Ogmg:buildExtraLevelsNew: stop here for now");
        }
            

        real timeb=getCPU();
        timeForBuildMask+=timeb-timea;

    // ***********************************************************************
    // The coarse grid mask has now been defined and all interpolation points 
    // have been marked on the coarse grid.
    // Determine the interpolation information for each interpolation point.
    // ***********************************************************************


        realSerialArray r(1,3),x(1,3);
        real *xp = x.Array_Descriptor.Array_View_Pointer1;
        const int xDim0=x.getRawDataSize(0);
#define X(i0,i1) xp[i0+xDim0*(i1)]
        real *rp = r.Array_Descriptor.Array_View_Pointer1;
        int rDim0=r.getRawDataSize(0);
#define R(i0,i1) rp[i0+rDim0*(i1)]

        r=-1.; x=0.;

    // arrays for rectangular grids:
        real dx0[3],xab0[2][3];
        real dx1[3],xab1[2][3];
        int iv0[3], iv1[3];
#define CENTER00(i0,i1,i2) (xab0[0][0]+dx0[0]*(i0-iv0[0]))
#define CENTER01(i0,i1,i2) (xab0[0][1]+dx0[1]*(i1-iv0[1]))
#define CENTER02(i0,i1,i2) (xab0[0][2]+dx0[2]*(i2-iv0[2]))

#define CENTER10(i0,i1,i2) (xab1[0][0]+dx1[0]*(i0-iv1[0]))
#define CENTER11(i0,i1,i2) (xab1[0][1]+dx1[1]*(i1-iv1[1]))
#define CENTER12(i0,i1,i2) (xab1[0][2]+dx1[2]*(i2-iv1[2]))

        for( int grid=0; grid<cg1.numberOfComponentGrids(); grid++ )
        {
      // only create the center (vertices) for non-rectangular grids
            if( !cg1[grid].isRectangular() )
            {
                if( l==level0 ) cg0[grid].update(MappedGrid::THEvertex | MappedGrid::THEcenter );	
                cg1[grid].update(MappedGrid::THEvertex | MappedGrid::THEcenter );
            }
        }
        
    // ---- Get a copy of the interpolation data arrays from the fine grid that live on this processor:
        InterpolationData *interpData=NULL;
        ParallelGridUtility::getLocalInterpolationData( cg0, interpData );

        for( int grid=0; grid<cg1.numberOfComponentGrids(); grid++ )
        {

      // const IntegerArray & numberOfInterpolationPoints0 =cg0.numberOfInterpolationPoints;
            InterpolationData & ipd = interpData[grid];
            
            #ifdef USE_PPP
                const int numberOfInterpolationPoints0 = ipd.numberOfInterpolationPoints;  // number of fine grid interp pts on this proc.
                intSerialArray & interpoleeGrid0 = ipd.interpoleeGrid;
                intSerialArray & interpolationPoint0 = ipd.interpolationPoint;
                realSerialArray & interpolationCoordinates0 = ipd.interpolationCoordinates;
            #else
                const int numberOfInterpolationPoints0 =cg0.numberOfInterpolationPoints(grid);
                const intArray & interpoleeGrid0 =cg0.interpoleeGrid[grid];  // ************ should use cg0 ****
                const intArray & interpolationPoint0 =cg0.interpolationPoint[grid];
                const realArray & interpolationCoordinates0 =cg0.interpolationCoordinates[grid];
            #endif    

            const int * interpoleeGrid0p = interpoleeGrid0.Array_Descriptor.Array_View_Pointer0;
#define ig0(i0) interpoleeGrid0p[i0]

            const int *interpolationPoint0p = interpolationPoint0.Array_Descriptor.Array_View_Pointer1;
            const int interpolationPoint0Dim0=interpolationPoint0.getRawDataSize(0);
#define ip0(i0,i1) interpolationPoint0p[i0+interpolationPoint0Dim0*(i1)]

            const real *interpolationCoordinates0p = interpolationCoordinates0.Array_Descriptor.Array_View_Pointer1;
            const int interpolationCoordinates0Dim0=interpolationCoordinates0.getRawDataSize(0);
#define ci0(i0,i1) interpolationCoordinates0p[i0+interpolationCoordinates0Dim0*(i1)]

            MappedGrid & mg0 = cg0[grid];
            intArray & mask0g = mg0.mask();

            MappedGrid & mg1 = cg1[grid];
            MappedGrid & c = mg1;
            const bool isRectangular=mg1.isRectangular();

            intArray & mask1g = mg1.mask();

            #ifdef USE_PPP
                intSerialArray mask0; getLocalArrayWithGhostBoundaries(mask0g,mask0);
                intSerialArray & mask1 = pMask1[grid];
        // intSerialArray mask1; getLocalArrayWithGhostBoundaries(mask1g,mask1);
                realSerialArray center;  if( !isRectangular ) getLocalArrayWithGhostBoundaries(mg1.center(),center);
            #else
                intSerialArray & mask0 = mask0g;
                intSerialArray & mask1 = mask1g;
                const realArray & center = mg1.center();
            #endif

            int * mask1p = mask1.Array_Descriptor.Array_View_Pointer2;
            const int mask1Dim0=mask1.getRawDataSize(0);
            const int mask1Dim1=mask1.getRawDataSize(1);

            real *centerp;
            int centerDim0,centerDim1,centerDim2;
            if( !isRectangular )
            {
      	centerp = center.Array_Descriptor.Array_View_Pointer3;
      	centerDim0=center.getRawDataSize(0);
      	centerDim1=center.getRawDataSize(1);
      	centerDim2=center.getRawDataSize(2);
            }
            
#define CENTER(i0,i1,i2,i3) centerp[i0+centerDim0*(i1+centerDim1*(i2+centerDim2*(i3)))]	

            if( isRectangular )
            {
      	mg0.getRectangularGridParameters( dx0, xab0 );
      	mg1.getRectangularGridParameters( dx1, xab1 );
      	iv0[0]=mg0.gridIndexRange(0,0);
      	iv0[1]=mg0.gridIndexRange(0,1);
      	iv0[2]=mg0.gridIndexRange(0,2);
      	iv1[0]=mg1.gridIndexRange(0,0);
      	iv1[1]=mg1.gridIndexRange(0,1);
      	iv1[2]=mg1.gridIndexRange(0,2);
      	if( mg1.isAllCellCentered() )
      	{
        	  xab0[0][0]+=dx0[0]*.5;
        	  xab0[0][1]+=dx0[1]*.5;
        	  xab0[0][2]+=dx0[2]*.5;

        	  xab1[0][0]+=dx1[0]*.5;
        	  xab1[0][1]+=dx1[1]*.5;
        	  xab1[0][2]+=dx1[2]*.5;
      	}     
            }
            
            const IntegerArray & gidLocal0 =     pGridIndexRange0[grid];
      // const IntegerArray & dimLocal0 =          pDimension0[grid];
      // const IntegerArray &  irLocal0 =         pIndexRange0[grid];
      // const IntegerArray & eirLocal0 = pExtendedIndexRange0[grid];
            const IntegerArray &  bcLocal0 =  pBoundaryCondition0[grid];

            const IntegerArray & gidLocal1 =     pGridIndexRange1[grid];
            const IntegerArray & dimLocal1 =          pDimension1[grid];
      // const IntegerArray &  irLocal1 =         pIndexRange1[grid];
            const IntegerArray & eirLocal1 = pExtendedIndexRange1[grid];
            const IntegerArray &  bcLocal1 =  pBoundaryCondition1[grid];


            const int *peir = &eirLocal1(0,0);
            #define eir(side,axis) peir[(side)+2*(axis)]


            const int *pir = mg0.indexRange().getDataPointer();  // this is used for offsets
#define INDEXRANGE(side,axis) pir[(side)+2*(axis)]

            bool thisProcessorHasPoints = eirLocal1(0,0) <= eirLocal1(1,0);

            intSerialArray inverseGrid;
            if( thisProcessorHasPoints )
            {
        // *wdh* 2012/07/07 -- add one more for 4th order (avoid ABR on line 2035, INVERSEGRID(j1,j2,j3)==-1 )
                const int extrai = orderOfAccuracy==2 ? 1 : 2;
      	getIndex(eirLocal1,I1,I2,I3,extrai);   
	// *wdh* 2012/07/07 getIndex(eirLocal1,I1,I2,I3,1); 
      	inverseGrid.redim(I1,I2,I3);  // allocate here to include extra on periodic edges 030617
            
	// const int extra=orderOfAccuracy==2 ? 1 : 0; // need one extra (ellipsoid)
      	const int extra=0;  // *wdh* turn off 030830 -- no longer needed after other changes.
      	getIndex(eirLocal1,I1,I2,I3,extra);   
            }
            else
            {
	// If there are no points on the mask on this processor then: 
      	assert( numberOfInterpolationPoints0==0 );
            }
            

      //        printF(">>>>> grid=%i gid=%i %i eir+1=%i %i \n",grid,c.gridIndexRange(0,0),c.gridIndexRange(1,0),
      //  	     I1.getBase(),I1.getBound());

      // We should not count "interp" points at periodic images *wdh* 021006
      // This is needed after we added the mask.periodicUpdate above
            if( false )
            { // *wdh* 091204 -- turn off for now --
      	for( int axis=0; axis<c.numberOfDimensions(); axis++ )
      	{
        	  if( c.isPeriodic(axis) )
          	    Iv[axis]=Range(INDEXRANGE(0,axis),INDEXRANGE(1,axis));
      	}
            }
            
      // printF("*** I1,I2,I3 for counting interp: [%i,%i][%i,%i][%i,%i]\n",
      //      I1.getBase(),I1.getBound(),I2.getBase(),I2.getBound(),I3.getBase(),I3.getBound());
            

      // ****** set mask==0 at 2nd ghost line outside interp boundaries.!

      // ------------------------------------------
      // -- make a list of interpolation points. --
      // ------------------------------------------

            int maxNumberOfInterpolationPoints=numberOfInterpolationPoints0*2+100;
            Range R; 
      // NOTE:  ia(i,.) holds ALL interp. pts on the coarse grid 
      //  (i.e. pts that coincide and do not coincide with fine grid interp. pts)
      //
      //  ia(i,0:2) = (i1,i2,i3) : interpolation point on the coarse grid
      //  ia(i,3) = interpolation quality, current best quality (*new* 2012/06/03)
      //  ia(i,4) = interpolation quality of the new possible donor grid 
            const int iaNumberOfComponents=5;
            intSerialArray & ia =iaA[grid];
            realSerialArray donorDist;     // holds the distance to the current donor -- for choosing closest donor
            if( thisProcessorHasPoints )
            {
                R=maxNumberOfInterpolationPoints;
      	ia.redim(R,iaNumberOfComponents);
                donorDist.redim(R,2);
            }
            else
            {
      	ia.redim(0);
            }
            
            int *iap = ia.Array_Descriptor.Array_View_Pointer1;
            const int iaDim0=ia.getRawDataSize(0);
#define IA(i0,i1) iap[i0+iaDim0*(i1)]

            int i=0;
            if( thisProcessorHasPoints )
            {
      	FOR_3(i1,i2,i3,I1,I2,I3)
      	{
        	  if( MASK1(i1,i2,i3) & MappedGrid::ISinterpolationPoint )
        	  {                                
          	    IA(i,0)=i1;
          	    IA(i,1)=i2;
          	    IA(i,2)=i3;
            // initialize quality: 
          	    IA(i,3)=canNotInterpolate;         // interp. quality (current best donor)
          	    IA(i,4)=canInterpolateQuality1;    // interp. coordinates quality (i.e. quality of "r" coords)
          	    donorDist(i,0)=REAL_MAX;           // distance to current best donor
          	    donorDist(i,1)=REAL_MAX;           // holds distance to potential new donor
          	    
                        MASK1(i1,i2,i3) = -(i+1);        // mask holds the index "i" 

          	    i++;

        	  }
      	}
            }
            assert( i<=maxNumberOfInterpolationPoints );
            
            int ni=i;
            numberOfInterpolationPoints(grid)=ni;
            if( debugb & 4 )
            {
                fprintf(pDebugFile,"*** grid=%i level=%i : find interp pts on mask1 : numberOfInterpolationPoints =%i \n",grid,level,ni);
                fprintf(pDebugFile," mask0=[%i,%i][%i,%i][%i,%i]\n",
            		mask0.getBase(0),mask0.getBound(0),
            		mask0.getBase(1),mask0.getBound(1),
            		mask0.getBase(2),mask0.getBound(2));
      	for( int i=interpolationPoint0.getBase(0); i<=interpolationPoint0.getBound(0); i++ )
      	{
        	  int ip3 = numberOfDimensions==2 ? 0 : ip0(i,2); 
                    fprintf(pDebugFile," fine-grid interp: i=%i ip=(%i,%i,%i) mask0(ip)=%i\n",i,
              		  ip0(i,0),ip0(i,1),ip3, mask0(ip0(i,0),ip0(i,1),ip3));
                    fflush(pDebugFile);
      	}
      	
            }
            
            R=ni;

      // -- make a CanInterpolate query list for all interp points --
            int numberToCheck=numberOfInterpolationPoints(grid);
            using namespace CanInterpolate;
      // Allocate space for queries: 
            CanInterpolateQueryData *cid = new CanInterpolateQueryData[max(1,numberToCheck)];


            int * inverseGridp = inverseGrid.Array_Descriptor.Array_View_Pointer2;
            const int inverseGridDim0=inverseGrid.getRawDataSize(0);
            const int inverseGridDim1=inverseGrid.getRawDataSize(1);
#define INVERSEGRID(i0,i1,i2) inverseGridp[i0+inverseGridDim0*(i1+inverseGridDim1*(i2))]	

//       realSerialArray inverseCoordinates;
              if( thisProcessorHasPoints )
              {
        	inverseGrid=-1;
// 	inverseCoordinates.redim(I1,I2,I3,Rx);
              }
            
//       real * inverseCoordinatesp = inverseCoordinates.Array_Descriptor.Array_View_Pointer3;
//       const int inverseCoordinatesDim0=inverseCoordinates.getRawDataSize(0);
//       const int inverseCoordinatesDim1=inverseCoordinates.getRawDataSize(1);
//       const int inverseCoordinatesDim2=inverseCoordinates.getRawDataSize(2);
// #define INVERSECOORDINATES(i0,i1,i2,i3) inverseCoordinatesp[i0+inverseCoordinatesDim0*(i1+inverseCoordinatesDim1*(i2+inverseCoordinatesDim2*(i3)))]	


      // -----------------------------------------------------------------------------------------------
      // --- Fill in all coarse grid interpolation points that match a fine grid interpolation point ---
      //     These points are assumed to be valid interpolation points. 
      // -----------------------------------------------------------------------------------------------

            i3=0;// assumes base 0 ---- fix ---
            j3=0;
            k3=0;
            const int ni0=ni;
            ni=0; // reset -- we will recount
            for( int i=interpolationPoint0.getBase(0); i<=interpolationPoint0.getBound(0); i++ )  // finer grid interp pts
            {
                for( int axis=0; axis<numberOfDimensions; axis++ )
      	{
            	  iv[axis]=ip0(i,axis);
                    jv[axis]=(iv[axis] - INDEXRANGE(0,axis))/2;  // ******************* 2 should be  cf
      	}
                if( (i1%2)==0 && (i2%2)==0 && (i3%2)==0 )  // ******************* %2 should be % cf
      	{  // fine grid interp pt matches coarse grid interp pt.

        	  assert( MASK1(j1,j2,j3) & MappedGrid::ISinterpolationPoint );

          // - fprintf(pDebugFile," grid=%i add interp pt i=%i (%i,%i,%i)\n",grid,ni,j1,j2,j3);
                    ni++;
                    assert( ig0(i)>=0 );
        	  INVERSEGRID(j1,j2,j3)=ig0(i);
//           for( int axis=0; axis<numberOfDimensions; axis++ )
// 	    INVERSECOORDINATES(j1,j2,j3,axis)=ci0(i,axis); 

        	  const int ii= -MASK1(j1,j2,j3)-1;
        	  assert( ii>=0 && ii<ni0 );
                    cid[ii].donor=ig0(i);
        	  for( int axis=0; axis<numberOfDimensions; axis++ )
          	    cid[ii].rv[axis]=ci0(i,axis);   // coarse grid interp. coord's are the same as the fine grid interp. coord's

      	}
      	
            }

      // -------------------------------------------------------------------------------------------
      // Make a list of extra interpolation points that do not coincide with fine grid pts: 
      //  -  For each coarse grid interp point that matches a fine grid interp point (and has already
      //     been marked), mark any neighbours that are interpolation points and are not marked yet.
      // --------------------------------------------------------------------------------------------

            int jb=0;  // counts new interpolation points
      // Note: in parallel we could have the case when numberOfInterpolationPoints0==0 but there are extra interp pts.
      //       This can happen when the fine grid interp pts are in the parallel ghost boundary
            int maxNumberOfExtraInterpolationPoints=numberOfInterpolationPoints0*numberOfDimensions+100;
                                      
      // ---- ib(i,.) : list of `extra' coarse grid interp. pts that we need to find donors for ---
      // 
      // ib(i,0) = i : fine grid interpolation pt, ip0(i,axis), near the coarse grid point 
      // ib(i,1:3) = (j1,j2,j3) : coarse grid point
      // ib(i,4) = ii - points into IA and XA arrays
      // ib(i,5) = grid2 : donor (maybe a guess)
            IntegerArray ib;
            if( thisProcessorHasPoints )
      	ib.redim(maxNumberOfExtraInterpolationPoints,6);
            int *ibp = ib.Array_Descriptor.Array_View_Pointer1;
            int ibDim0=ib.getRawDataSize(0);
#define IB(i0,i1) ibp[i0+ibDim0*(i1)]

            IntegerArray gridsToCheck(cg1.numberOfComponentGrids());
            gridsToCheck=0;
            
            for( int i=interpolationPoint0.getBase(0); i<=interpolationPoint0.getBound(0); i++ )
            {
                for( int axis=0; axis<numberOfDimensions; axis++ )
      	{
            	  iv[axis]=ip0(i,axis);
          // kv[axis]=(iv[axis] - INDEXRANGE(0,axis))/2;  // wrong if negative
                    kv[axis]=(iv[axis] - INDEXRANGE(0,axis) + 8 )/2 -4;
      	}
                if( (i1%2)==0 && (i2%2)==0 && (i3%2)==0 
          	    && orderOfAccuracy==2 ) // ******************************* 030202
      	{  // fine grid interp pt matches coarse grid interp pt.
      	}
      	else
      	{

          // assert( numberOfDimensions<3 );
                    const int m3Start=numberOfDimensions<3 ? 0 : -1;
                    const int m3End  =numberOfDimensions<3 ? 0 : +1;
                    for( int m3=m3Start; m3<=m3End; m3++ )
        	  {
          	    j3=k3+m3;
          	    for( int m2=-1; m2<=1; m2++ )
          	    {
            	      j2=k2+m2;
            	      for( int m1=-1; m1<=1; m1++ )
            	      {
            		j1=k1+m1;

            		
            		if( (MASK1(j1,j2,j3) & MappedGrid::ISinterpolationPoint) && INVERSEGRID(j1,j2,j3)==-1 )
            		{
                  // this neighbour has not been marked yet.
                  // skip points outside (these could be periodic images of interp points) *wdh* 021006
                                    if( j1<eir(0,0) || j1>eir(1,0) ) continue;
                                    if( j2<eir(0,1) || j2>eir(1,1) ) continue;
                                    if( numberOfDimensions==3 && (j3<eir(0,2) || j3>eir(1,2)) ) continue;
              		  
		  // fprintf(pDebugFile," grid=%i ni=%i i=(%i,%i,%i) k=(%i,%i,%i) check j=(%i,%i,%i) mask1(j)=%i "
                  //           "inverseGrid=%i eir=[%i,%i][%i,%i][%i,%i]\n",
                  //        grid,ni,i1,i2,i3,k1,k2,k3,j1,j2,j3,MASK1(j1,j2,j3),INVERSEGRID(j1,j2,j3),
                  //        eir(0,0),eir(1,0),eir(0,1),eir(1,1),eir(0,2),eir(1,2));

                  // - fprintf(pDebugFile," grid=%i add interp pt i=%i (%i,%i,%i)\n",grid,ni,j1,j2,j3);


              		  ni++;

                  // by default we choose the same interpolee grid as point i  -- this may
                  // be changed later
                                    assert( ig0(i)>=0 );
                                    int grid2=ig0(i); // **** this is a first guess , could try to take closest one 
                                    
              		  INVERSEGRID(j1,j2,j3)=grid2;
                                    gridsToCheck(grid2)=1;

                                    IB(jb,0)=i;    // fine grid interp. pt : ip0(i,axis)
                                    IB(jb,1)=j1;   // coarse grid point 
                                    IB(jb,2)=j2;
                                    IB(jb,3)=j3;
                                    int ii= -MASK1(j1,j2,j3)-1;
                                    assert( ii>=0 && ii<ni0 );
                                    IB(jb,4)=ii;    // points into IA and XA arrays
                                    IB(jb,5)=grid2; // guess at donor

                  // initialize quality for these points that do not coincide with a fine grid interp. pt.
                  // These values are later set in getInterpolationCoordinatesNew
              		  IA(ii,3)=canNotInterpolate;    // interp. quality (current best donor)
              		  IA(ii,4)=canNotInterpolate;    // interp. coordinates quality (i.e. quality of "r" coords)

              		  if( debugb & 4 ) 
              		  {
                		    fprintf(pDebugFile,"Extra interp: grid=%i: pt jb=%i i=%i fine=(%i,%i,%i) "
                                                        "coarse=(%i,%i,%i) ii=%i donor-guess=%i\n",grid,jb,i,i1,i2,i3,j1,j2,j3,ii,grid2);
              		  }

              		  jb++;
              		  if( jb>=maxNumberOfExtraInterpolationPoints )
              		  {
                                        maxNumberOfExtraInterpolationPoints=int(maxNumberOfExtraInterpolationPoints*1.5+1);
                		    
                                        fprintf(pDebugFile,"myid=%i: INFO: increasing maxNumberOfExtraInterpolationPoints to %i\n",
                     			   myid,maxNumberOfExtraInterpolationPoints);
                		    ib.resize(maxNumberOfExtraInterpolationPoints,ib.getLength(1));
              		  }
              		  
            		} // end if (MASK1
		// j1-=m1;
            	      } // end for m1
	      // j2-=m2;
          	    }
	    // j3-=m3;
        	  } // end for m3
      	}
      	
            }  // end for i
            


      // *wdh* 100101
            if( ni<numberOfInterpolationPoints(grid) )
            {
	// In some cases in parallel not all interp pts on the coarse grid will be marked
        // (when consecutive fine grid interp pts lie on parallel ghost pts)
        // c.f. -g=cic.bbmg2, -n8 
                Index J1=Range(eir(0,0),eir(1,0));
                Index J2=Range(eir(0,1),eir(1,1));
                Index J3=Range(eir(0,2),eir(1,2));
      	
      	FOR_3(j1,j2,j3,J1,J2,J3)
      	{
        	  if( MASK1(j1,j2,j3) & MappedGrid::ISinterpolationPoint  && INVERSEGRID(j1,j2,j3)==-1 )
        	  {

            // - fprintf(pDebugFile," grid=%i add interp pt i=%i (%i,%i,%i)  (EXTRA)\n",grid,ni,j1,j2,j3);

          	    ni++;

	    // We need to make a guess for the donor grid: 
                                    
          	    int grid2 = (grid+1) % numberOfComponentGrids;  // do this for now ---
          	    INVERSEGRID(j1,j2,j3)=grid2;
          	    gridsToCheck(grid2)=1;

            // **FIX ME**
                        int i=-1;  // this is usually the number of the fine grid interpolation point **do better here**
          	    IB(jb,0)=i;  // index into original interpolation point arrays  **** fix me *** *************************
          	    IB(jb,1)=j1;
          	    IB(jb,2)=j2;
          	    IB(jb,3)=j3;
          	    int ii= -MASK1(j1,j2,j3)-1;
          	    assert( ii>=0 && ii<ni0 );
          	    IB(jb,4)=ii;  // points into IA and XA arrays		  
                        IB(jb,5)=grid2;

	    // initialize quality for these points that do not coincide with a fine grid interp. pt.
	    // These values are later set in getInterpolationCoordinatesNew
          	    IA(ii,3)=canNotInterpolate;    // interp. quality (current best donor)
          	    IA(ii,4)=canNotInterpolate;    // interp. coordinates quality (i.e. quality of "r" coords)

          	    jb++;
          	    if( jb>=maxNumberOfExtraInterpolationPoints )
          	    {
            	      maxNumberOfExtraInterpolationPoints=int(maxNumberOfExtraInterpolationPoints*1.5+1);
                		    
            	      fprintf(pDebugFile,"myid=%i: INFO: increasing maxNumberOfExtraInterpolationPoints to %i\n",
                 		     myid,maxNumberOfExtraInterpolationPoints);
            	      ib.resize(maxNumberOfExtraInterpolationPoints,ib.getLength(1));
          	    }
                          
        	  }
      	} // end FOR_3
      	
            }
            
            const int numberOfExtraInterpolationPoints=jb;

            if( debugb & 8 )
                display(inverseGrid,sPrintF(buff,"After initial setting of inverseGrid: level=%i grid=%i",level,grid),pDebugFile);

            if( debugb & 4 )
            {
                fprintf(pDebugFile," *** number of interpolation points assigned, ni=%i, level=%i grid=%i "
            		"numberOfInterpolationPoints=%i, numExtra=%i\n",ni,level,grid,numberOfInterpolationPoints(grid),
                              numberOfExtraInterpolationPoints );
      	fflush(pDebugFile);
            }
            
            if( ni!=numberOfInterpolationPoints(grid) )
            {
      	printf("buildExtraLevels:ERROR: myid=%i level=%i grid=%i : ni=%i is NOT equal to numberOfInterpolationPoints(grid)=%i\n",
             	       myid,level,grid,ni,numberOfInterpolationPoints(grid));
      	fflush(0);
      	assert( ni==numberOfInterpolationPoints(grid) );
            }
            

      // --- Evaluate the x coordinates of the interpolation points ---
      // xa(i,0:nd-1) : x-coordinates of the interp. pts, i=0,1,...,ni-1 
            RealArray xa;
            real *xap=NULL;
            int xaDim0=0;
            #define XA(i0,i1) xap[i0+xaDim0*(i1)]

      // getInterpolationPointPositions(ni);
            if( ni>0 )
                xa.redim(ni,numberOfDimensions);
            xap = xa.Array_Descriptor.Array_View_Pointer1;
            xaDim0=xa.getRawDataSize(0);
            if( isRectangular )
            {
                if( numberOfDimensions==2 )
                {
                    for( int i=0; i<ni; i++ )
                    {
                        int i1=IA(i,0); i2=IA(i,1); i3=IA(i,2); 
                        XA(i,0)=CENTER10(i1,i2,i3);
                        XA(i,1)=CENTER11(i1,i2,i3);
                    }
                }
                else
                {
                    for( int i=0; i<ni; i++ )
                    {
                        int i1=IA(i,0); i2=IA(i,1); i3=IA(i,2); 
                        XA(i,0)=CENTER10(i1,i2,i3);
                        XA(i,1)=CENTER11(i1,i2,i3);
                        XA(i,2)=CENTER12(i1,i2,i3);
                    }
                }
            }
            else
            { 
        // curvilinear case 
            #ifdef USE_PPP
        // in parallel we cannot rely on the center1 array being on this processor
                RealArray ra;
                if( ni>0 )
                    ra.redim(ni,numberOfDimensions);
                real *rap = ra.Array_Descriptor.Array_View_Pointer1;
                const int raDim0=ra.getRawDataSize(0);
            #define RA(i0,i1) rap[i0+xaDim0*(i1)]
                const IntegerArray & gid1 = mg1.gridIndexRange();
                const RealArray & dr1 = mg1.gridSpacing();
                for( int i=0; i<ni; i++ )
                {
                    for( int axis=0; axis<numberOfDimensions; axis++ )
                        RA(i,axis)=(IA(i,axis)-gid1(0,axis))*dr1(axis);   // r-coordinates of the point 
                }
                Mapping & map1 = mg1.mapping().getMapping();
                map1.mapS(ra,xa);
            #else
                for( int i=0; i<ni; i++ )
                {
                    int i1=IA(i,0); i2=IA(i,1); i3=IA(i,2);
                    for( int axis=0; axis<numberOfDimensions; axis++ )
                        XA(i,axis)=CENTER(i1,i2,i3,axis);
                }
            #endif
            }
            if( debug & 4 )
            {
                fprintf(pDebugFile,"\n ** level=%i grid=%i : Here are the x-coords of the interp points to be found\n",
                    	  level,grid);
                for( int i=0; i<ni; i++ )
                {
                    fprintf(pDebugFile," pt i=%5i (%5i,%5i,%5i) x=(%9.2e,%9.2e,%9.2e)\n",i,IA(i,0),IA(i,1),IA(i,2),XA(i,0),XA(i,1),
                      	    (numberOfDimensions==2 ? 0. : XA(i,2)));
                }
            }


      // ------------------------------------------------------------------------
      // --- Compute the interpolation coords for all points
      // ------------------------------------------------------------------------

            intSerialArray & interpoleeGrid = interpoleeGridA[grid];                  interpoleeGrid.redim(R);
            intSerialArray & interpolationPoint = interpolationPointA[grid];          interpolationPoint.redim(R,Rx);
            intSerialArray & interpoleeLocation = interpoleeLocationA[grid];          interpoleeLocation.redim(R,Rx);
            realSerialArray & interpolationCoordinates = interpolationCoordinatesA[grid]; interpolationCoordinates.redim(R,Rx);

            intSerialArray & variableInterpolationWidth = variableInterpolationWidthA[grid]; 
            variableInterpolationWidth.redim(R);
            variableInterpolationWidth=0;
            
            if( parameters.coarseGridInterpolationWidth>0 || orderOfAccuracy==4 )
            {
        // Interpolate to lower order accuracy for fourth-order discretizations -- this assumes the averaged operator
        // on the coarse grid is only second-order anyway.
                Range Rx=mgcg.numberOfDimensions();

                const int defaultInterpWidth = orderOfAccuracy==2 ? 3 : 3;
      	
                int interpWidth = (parameters.coarseGridInterpolationWidth<0 ? defaultInterpWidth : 
                                                      parameters.coarseGridInterpolationWidth);

         //      Need to set: mgcg.interpolationWidth(Rx,grid,grid2,l)
          	mgcg.interpolationWidth(Rx,all,all,level)=interpWidth; 
          	cg1.interpolationWidth(Rx,all,all,all)=interpWidth; 

            }
            
      // NOTE: checkCanInterpolate will use cg.interpolationWidth and interpolationOverlap 
      // temporarily change these for the canInterpolate function:
            int donor=0;
            const int widthOld = cg1.interpolationWidth(0,grid,donor,0);
            const real ovOld =  cg1.interpolationOverlap(0,grid,donor,0);
            
      // Can we be sure that cgCanInterpolate is consistent with getInterpolationStencil??
      // cgCanInterpolate:         ia=rr-ov,      ib=rr+ov+1  -> width = 2*ov+1 -> ov=(width-1)/2
      // getInterpolationStencil : ia=rr-.5*iw+1  ib=rr+.5*iw -> ov=.5*iw-1 = .5*(width-2)
      // Ogen: changeParameters: ov = .5*(iw-2) for implicit interp

            int interpolationWidth=3;  // *********** fix me 

            Range Rx=numberOfDimensions;
      	
            real ov=max(0., (interpolationWidth-2.)/2. ) ; // Is this correct?
            cg1.interpolationWidth(Rx,all,all,all)=interpolationWidth;  // target interp. width
            cg1.interpolationOverlap(Rx,all,all,all)=ov;

            if( debugb & 8 )
            {
      	::display(cg1.interpolationWidth,"cg1.interpolationWidth",pDebugFile);
      	::display(cg1.interpolationOverlap,"cg1.interpolationOverlap",pDebugFile);
            }


      // fill in the query data:
            for( int i=0; i<numberToCheck; i++ )
            {
      	i1=IA(i,0); i2=IA(i,1); i3=IA(i,2);
      	assert( MASK1(i1,i2,i3) & MappedGrid::ISinterpolationPoint );


      	cid[i].id=i; cid[i].i=i; 
      	cid[i].grid=grid; 
      	cid[i].donor=inverseGrid(i1,i2,i3);
                
	// for( int axis=0; axis<numberOfDimensions; axis++ )
	//   cid[i].rv[axis]=inverseCoordinates(i1,i2,i3,axis);
        	  
      	if( debugb & 4 ) 
      	{
        	  fprintf(pDebugFile,"grid=%i: pt i=%i : find a valid interp stencil for i=(%i,%i,%i), donor guess=%i, "
              		  " ri=(%4.2f,%4.2f,%4.2f)..\n",grid,i,i1,i2,i3,inverseGrid(i1,i2,i3),
                                    cid[i].rv[0],cid[i].rv[1],cid[i].rv[2]);
      	}
            }

      // -----------------------------------------------------------------------
      // --- get the interpolation coords for the extra interpolation points ---
      // -----------------------------------------------------------------------
      // getExtraInterpCoords(numberOfExtraInterpolationPoints);
            if( numberOfExtraInterpolationPoints>0 )
                r.redim(numberOfExtraInterpolationPoints,3);
            rp = r.Array_Descriptor.Array_View_Pointer1;
            rDim0=r.getRawDataSize(0);
            Range Ri=numberOfExtraInterpolationPoints, all;
            if( numberOfExtraInterpolationPoints>0 )
                getInterpolationCoordinatesNew(cg0,cg1,ib(Ri,all),xa, grid,gridsToCheck, r,
                                     				 isRectangular,iv0,dx0,xab0,iv1,dx1,xab1,ipd,ia,donorDist);
            else
            {
        // assert( ib.getLength(0)==0 );
                ib.redim(0);
                getInterpolationCoordinatesNew(cg0,cg1,ib,xa, grid,gridsToCheck, r,
                                     				 isRectangular,iv0,dx0,xab0,iv1,dx1,xab1, ipd,ia,donorDist);
            }
            if( false )
            {
        // check with old "new" version
                RealArray r2;
                if( numberOfExtraInterpolationPoints>0 )
                    r2.redim(numberOfExtraInterpolationPoints,3);
                Range Ri=numberOfExtraInterpolationPoints, all;
                if( numberOfExtraInterpolationPoints>0 )
                    getInterpolationCoordinatesNewOld(cg0,cg1,ib(Ri,all),xa, grid,gridsToCheck, r2,
                                          				      isRectangular,iv0,dx0,xab0,iv1,dx1,xab1,ipd);
                else
                {
          // assert( ib.getLength(0)==0 );
                    ib.redim(0);
                    getInterpolationCoordinatesNewOld(cg0,cg1,ib,xa, grid,gridsToCheck, r2,
                                          				      isRectangular,iv0,dx0,xab0,iv1,dx1,xab1, ipd);
                }
                if( numberOfExtraInterpolationPoints>0 )
                {
                    real maxDiff=max(fabs(r(Ri,Rx)-r2(Ri,Rx)));
                    printf("Ogmg::buildExtraLevelsNew::getExtraInterpCoords: myid=%i : NEW-OLD = %9.3e\n",myid,maxDiff);
                }
            }

            for( int i=0; i<numberOfExtraInterpolationPoints; i++ )
            {
      	int ii=IB(i,4);
      	for( int axis=0; axis<numberOfDimensions; axis++ )
        	  cid[ii].rv[axis]=R(i,axis);

            }

      // *wdh* 11/06/12 - for testing check for nan's
            if( false ) 
            {
      	for( int i=0; i<numberOfExtraInterpolationPoints; i++ )
      	{
        	  int ii=IB(i,4);
        	  if( cid[ii].rv[0] != cid[ii].rv[0] || cid[ii].rv[1] != cid[ii].rv[1]  )
        	  {
                        printf("Ogmg:buildExtraLevelsNew:extraInterp:ERROR: myid=%i grid=%i i=%i ii=%i (<numberToCheck=%i) donor=%i, "
               		   "cid[ii].rv=[%e,%e,%e] ! nan's ?? \n",
               		   myid,grid,i,ii,numberToCheck,inverseGrid(i1,i2,i3),cid[ii].rv[0],cid[ii].rv[1],cid[ii].rv[2]);
        	  }
      	}
            }
            
            

            if( debugb & 8 )
      	display(inverseGrid,sPrintF(buff,"inverseGrid after getInterpolationCoordinates, level=%i grid=%i",level,grid),pDebugFile);

      // ****************************************************
      // ***** Find a valid stencil to interpolate from *****
      // ****************************************************

      // Allocate space for results
            CanInterpolateResultData *cir =new CanInterpolateResultData[max(1,numberToCheck)];

            int pointsRemain = numberToCheck>0;
            pointsRemain = ParallelUtility::getMaxValue(pointsRemain);


            int interpolationStage=-1;
      // =====================================================================================
      // ====== Loop here for checking different donor grids until we find a good donor ======
      // =====================================================================================
            while( pointsRemain )
            {
      	interpolationStage++;

                if( debug & 4 )
        	  fprintf(pDebugFile,"\n--- Interpolation stage %i : numberToCheck=%i (level=%i, grid=%i) ---\n",
                                    interpolationStage,numberToCheck,level,grid);
      	

      	real timea=getCPU();

      	
        // NOTES: 
	//  - canInterpolate will find any valid interpolation by default (i.e. backup results too)
	//  - this function also computes the interpolation stencil

	// *wdh* 091118 : now we can allow interpolation from ghost points.
      	int numberOfValidGhostPoints=0; // do this for now 
      	const int numValidGhost = numberOfValidGhostPoints>0 ? numberOfValidGhostPoints : 0;
      	CanInterpolate::canInterpolate( cg1, numberToCheck,cid, cir, numValidGhost );

      	if( debug & 4 )
      	{
        	  if( numberToCheck>0 )
        	  {
          	    fprintf(pDebugFile,"  --- buildExtraLevels: stage=%i : after CanInterpolate, level=%i grid=%i : \n",
                		    interpolationStage,level,grid);
          	    for( int i=0; i<numberToCheck; i++ )
          	    {
                            const int ii=cid[i].i;
            	      fprintf(pDebugFile,"  pt i=%i (ii=%i) (%i,%i,%i) interpolates=%i width=%i from donor=%i il=(%i,%i,%i) "
                  		      " r=(%8.2e,%8.2e,%8.2e)\n",
                  		      i,ii,IA(ii,0),IA(ii,1),IA(ii,2),int(cir[i].width>0),
                  		      cir[i].width,cid[i].donor,cir[i].il[0],cir[i].il[1],cir[i].il[2],
                  		      cid[i].rv[0],cid[i].rv[1],cid[i].rv[2]);
          	    }
        	  }
      	}
        
	// *************** Assign points that could be interpolated  *****************
        //                 and compress the cid[] list for any remaining points
      	int numNotFound=0;
      	for( int i=0; i<numberToCheck; i++ )
      	{
        	  bool validDonorFound=false;
        	  int width = cir[i].width;   // interpolation width (=0 if invalid)
        	  if( width>0 ) 
        	  {
	    // -- valid interpolation ---
            // -- Use these coordinates if the quality is better than the current best quality --

                        const int ii=cid[i].i; // index into IA arrays

                        const int currentQuality=IA(ii,3);   // current best donor quality
          	    
                        int newQuality=-1;
          	    if( width>=3 )
                            newQuality=canInterpolateQuality1;     // best quality, interpolates to correct order
          	    else if( width==2 )
            	      newQuality=canInterpolateQuality2;     // 2nd best best quality, interpolates to correct order minus 1
                        else
          	    {
            	      assert( width==1 );
                            newQuality=canInterpolateQuality3;     // 3rd best quality, interpolates to correct order minus 2
          	    }
          	    
                        real & currentDonorDist = donorDist(ii,0);
          	    const real newDonorDist = donorDist(ii,1);

            // The interpolation coordinates used for this point may have been extrapolated in which case
            // the interpolation may not be as good. The quality is taken as the worst of these two values.
                        int interpCoordsQuality=IA(ii,4);
          	    newQuality = max( newQuality, interpCoordsQuality );

          	    if( ( (newQuality < currentQuality) && newDonorDist <= currentDonorDist ) ||
                                ( (newQuality <= currentQuality) && newDonorDist < currentDonorDist )   )
          	    {
	      // accept this point as the current best quality
                            IA(ii,3)=newQuality;  // save current quality

                            currentDonorDist = newDonorDist; // update distance 
            	      
            	      for( int axis=0; axis<numberOfDimensions; axis++ )
            	      {
            		interpolationPoint(ii,axis)      =IA(ii,axis);
            		interpolationCoordinates(ii,axis)=cid[i].rv[axis];
            		interpoleeLocation(ii,axis)      =cir[i].il[axis];
            	      }
                            assert( cid[i].donor>=0 && cid[i].donor<numberOfComponentGrids );  // *wdh* 2013/09/16
            	      
            	      interpoleeGrid(ii)= cid[i].donor;
            	      variableInterpolationWidth(ii)=width;
          	    
            	      if( newQuality==canInterpolateQuality1 || newQuality==canInterpolateQuality2 )
            	      {
		// accept this point
            		validDonorFound=true;
            	      }
            	      if( debug & 4 )
            	      {
                                fprintf(pDebugFile,"  ... pt=(%i,%i,%i), donor found, quality=(%i,%i) (stage %i) "
                  			"width=%i for i=%i grid=%i, donor=%i. dist=%8.2e %s. \n",IA(ii,0),IA(ii,1),IA(ii,2),IA(ii,3),IA(ii,4),
                  			interpolationStage,width,cid[i].i,grid,cid[i].donor, currentDonorDist,
                                                (validDonorFound ? "done" : "keep looking.."));
            	      }

          	    }

        	  }

                    if( !validDonorFound )
        	  {
	    // --- keep a list of points we could not interpolate from, or for which we want better quality ---
            //      : save info in cid

                        int ii=cid[i].i;  // index into original IA, XA list
          	    int & j=numNotFound;

            // ---------------------------------
	    // --- look for a new donor grid ---
            // ---------------------------------
                        const int oldDonor=cid[i].donor;

            // Look from donors starting from the highest priority grid:
                        int newDonor=-1;
                        if( interpolationStage==0 )
          	    { // First time thru start by checking the highest priority grid: (this may be changed below)
                            newDonor= numberOfComponentGrids-1;
          	    }
          	    else
          	    { // After the first pass check the last donor checked minus one:
                            newDonor=oldDonor-1;  
          	    }
          	    
            // We need the last donor checked for this point


            // -- Check the distance from the interp pt to the bounding box of the mapping and only
            //    use this as a new potential donor if we are inside or close enough.

          	    real distToBox=0.;  // holds distance to the bounding-box of the new donor mapping ( 0. = inside)
                        while( newDonor>=0 )  // loop to look for the next potential donor.
          	    {
            	      while( (newDonor==oldDonor || newDonor==grid) && newDonor>=0 ) // skip old-donor and target grid
            	      {
                                newDonor--;
            	      }
            	      if( newDonor < 0 ) break;

              // -- Q. which bounding box should we use ?
              // Use the fine grid BB : compute once, but more expensive to compute and may miss extended ghost points
	      // mgcg[newDonor].update(MappedGrid::THEboundingBox);  // ************* FIX ME *********************
	      // const RealArray & boundingBox = mgcg[newDonor].boundingBox(); 
                            const RealArray & boundingBox = mgcg.multigridLevel[0][newDonor].boundingBox(); 

              // -- coarse grids do not have a valid bounding box:
	      // cg0[newDonor].update(MappedGrid::THEboundingBox);  // ************* FIX ME *********************
	      // const RealArray & boundingBox = cg0[newDonor].boundingBox(); 

              // This one is not valid yet:
	      // cg1[newDonor].update(MappedGrid::THEboundingBox);  // ************* FIX ME *********************
	      // const RealArray & boundingBox = cg1[newDonor].boundingBox(); 
              // We could use the one in the mapping so we don't need to recompute it ? But doesn't include ghost!
              // const RealArray & boundingBox = mgcg[newDonor].mapping().getMapping().getBoundingBox();

	      // Check this donor grid if:
	      //    1. We are inside the boundingBox
	      //    2. We are outside the BB but at a distance that is less than the current donorDist

	      //Note the square of the dist from a point x outside the box is just the sum of the 
	      // squares of the distances to the the planes that bound the box
	      //         |        |
	      // ________|________|_______
	      //         |        |
	      //     x   |  Box   |
	      //  _______|________|______
	      //         |        |
	      //     x   |   x    |
	      // 
            	      distToBox=0.; // distance is zero if inside, otherwise the distance to the bounding box
            	      for( int axis=0; axis<numberOfDimensions; axis++ )
            	      {
            		real xx = XA(ii,axis);
            		if( xx<boundingBox(0,axis) )
            		{
              		  distToBox += SQR(xx-boundingBox(0,axis));
            		}
            		else if( xx>boundingBox(1,axis) ) 
            		{
              		  distToBox += SQR(xx-boundingBox(1,axis));
            		}
            	      }
            	      if( distToBox==0. ) 
            	      {
            		break;  // we are inside the bounding box, check this donor grid.
            	      }
            	      else
            	      {
		// point is outside the box:
            		distToBox=sqrt(distToBox);
            		if( distToBox < donorDist(ii,0) )
            		{
                  // The distance to the box is less than the current best distance between interp. pt. and donor pt.
                  // We should thus check this box:
                                    break;
            		}
            	      }
                            
              // keep looking for a valid new donor:
                            newDonor--;

          	    }  // end while newDonor >= 0 

            // Note: if newDonor<0 then are no more donor grids to check for this point. 
            // We will use the current best guess for the donor, and the point will not be added to the list below.
                        if( newDonor>=0 )
          	    {
            	      cid[i].donor=newDonor;

            	      if( i!=j )
            	      {
            		cid[j]=cid[i]; // deep copy 
            	      }
          	    
            	      numNotFound++;

            	      if( debug & 4 )
            	      {
                    	        const int ii=cid[i].i; // index into IA arrays
            		if( width>0 )
            		{
              		  if( oldDonor==interpoleeGrid(ii) )
              		  {
                		    fprintf(pDebugFile,"  ... pt=(%i,%i,%i) donor=%i found but poor quality=(%i,%i) (stage %i) "
                      			    "width=%i for i=%i grid=%i, new-donor-to-check=%i (distToBox=%8.2e) dist-to-donor=%8.2e, Keep looking... \n",
                      			    IA(ii,0),IA(ii,1),IA(ii,2),oldDonor,IA(ii,3),IA(ii,4),
                      			    interpolationStage,width,cid[i].i,grid,newDonor,distToBox,donorDist(ii,0));
              		  }
              		  else
              		  {
                		    fprintf(pDebugFile,"  ... pt=(%i,%i,%i) possible donor=%i (dist=%8.2e) but NOT better than donor=%i, current-quality=(%i,%i) (stage %i) "
                      			    "width=%i for i=%i grid=%i, new-donor-to-check=%i (distToBox=%8.2e) dist-to-donor=%8.2e, Keep looking... \n",
                      			    IA(ii,0),IA(ii,1),IA(ii,2),oldDonor,donorDist(ii,1),interpoleeGrid(ii),IA(ii,3),IA(ii,4),
                      			    interpolationStage,width,cid[i].i,grid,newDonor,distToBox,donorDist(ii,0));
              		  }
              		  
            		}
            		else
            		{
              		  fprintf(pDebugFile,"  ... pt=(%i,%i,%i) donor NOT found (stage %i) width=0 for i=%i grid=%i, donor=%i, current-donor=%i"
                    			  " new-donor=%i (distToBox=%8.2e) current-quality=%i. current-dist=%8.2e. Keep looking... \n",
                    			  IA(ii,0),IA(ii,1),IA(ii,2),interpolationStage,cid[i].i,grid,oldDonor,interpoleeGrid(ii),
                                                    newDonor,distToBox,IA(ii,3),donorDist(ii,0));
            		}
            	      
            	      }
          	    }
          	    
        	  }
        	  
      	}

      	numberToCheck=numNotFound;
                pointsRemain = ParallelUtility::getMaxValue(numberToCheck);
      	if( pointsRemain && debug & 4 )
        	  fprintf(pDebugFile," myid=%i : After CanInterpolate for interpolationStage=%i, numNotFound=%i. (numberOfComponentGrids=%i)\n",
              		  myid,interpolationStage,numberToCheck,numberOfComponentGrids);

      	if( interpolationStage==(numberOfComponentGrids-2) )
      	{
        	  break;
      	}
      	

      	if( pointsRemain )
      	{
	  // ---- Recompute the ib array ----

        	  if( numberToCheck>0 )
                        ib.resize(numberToCheck,ib.getLength(1));
                    else
                        ib.redim(0);
          // re-compute macro parameters: 
        	  ibp = ib.Array_Descriptor.Array_View_Pointer1;
                    ibDim0=ib.getRawDataSize(0);
                    gridsToCheck=0;

                    for(int i=0; i<numberToCheck; i++ ) 
        	  {
                        IB(i,0)=-1;  // index into fine grid interp. arrays, -1 means there is none

                        int ii=cid[i].i;  // index into original IA list
                        IB(i,4)=ii;       
                        IB(i,3)=0;
                        for( int axis=0; axis<numberOfDimensions; axis++ )
          	    {
            	      IB(i,axis+1)=IA(ii,axis);
          	    }
          	    IB(i,5)=cid[i].donor;

                        const int newDonor=cid[i].donor;
          	    gridsToCheck(newDonor)=1;

        	  }
        	  
          // -- Get the "r" coordinates of the remaining points ---

          // getExtraInterpCoords(numberToCheck);
                    if( numberToCheck>0 )
                        r.redim(numberToCheck,3);
                    rp = r.Array_Descriptor.Array_View_Pointer1;
                    rDim0=r.getRawDataSize(0);
                    Range Ri=numberToCheck, all;
                    if( numberToCheck>0 )
                        getInterpolationCoordinatesNew(cg0,cg1,ib(Ri,all),xa, grid,gridsToCheck, r,
                                             				 isRectangular,iv0,dx0,xab0,iv1,dx1,xab1,ipd,ia,donorDist);
                    else
                    {
            // assert( ib.getLength(0)==0 );
                        ib.redim(0);
                        getInterpolationCoordinatesNew(cg0,cg1,ib,xa, grid,gridsToCheck, r,
                                             				 isRectangular,iv0,dx0,xab0,iv1,dx1,xab1, ipd,ia,donorDist);
                    }
                    if( false )
                    {
            // check with old "new" version
                        RealArray r2;
                        if( numberToCheck>0 )
                            r2.redim(numberToCheck,3);
                        Range Ri=numberToCheck, all;
                        if( numberToCheck>0 )
                            getInterpolationCoordinatesNewOld(cg0,cg1,ib(Ri,all),xa, grid,gridsToCheck, r2,
                                                  				      isRectangular,iv0,dx0,xab0,iv1,dx1,xab1,ipd);
                        else
                        {
              // assert( ib.getLength(0)==0 );
                            ib.redim(0);
                            getInterpolationCoordinatesNewOld(cg0,cg1,ib,xa, grid,gridsToCheck, r2,
                                                  				      isRectangular,iv0,dx0,xab0,iv1,dx1,xab1, ipd);
                        }
                        if( numberToCheck>0 )
                        {
                            real maxDiff=max(fabs(r(Ri,Rx)-r2(Ri,Rx)));
                            printf("Ogmg::buildExtraLevelsNew::getExtraInterpCoords: myid=%i : NEW-OLD = %9.3e\n",myid,maxDiff);
                        }
                    }

	  // fill in the query data r-coords:
          	  for( int i=0; i<numberToCheck; i++ )
          	  {
          	    if( debug & 2  )
          	    { // sanity check: 
            	      int ii=cid[i].i;
            	      i1=IA(ii,0); i2=IA(ii,1); i3=IA(ii,2);
            	      assert( MASK1(i1,i2,i3) & MappedGrid::ISinterpolationPoint );
          	    }
          	    
            	    for( int axis=0; axis<numberOfDimensions; axis++ )
              	      cid[i].rv[axis]=R(i,axis); // inverseCoordinates(i1,i2,i3,axis);
        	  
          	  }
        	  
      	}
        
// 	if( interpolationStage>numberOfComponentGrids )
// 	{
//           printF("buildExtraLevels:ERROR: interpolationStage>numberOfComponentGrids=%i -- "
//                 "this should probably not happen.\n",numberOfComponentGrids);
//           OV_ABORT("error");
// 	}
      	

            } // end while pointsRemain
            
            if( interpolationStage==(numberOfComponentGrids-2) && pointsRemain ) // *wdh* 2013/09/17 fixed -1 -> -2
            {
      	if( debug & 4 )
      	{
                    fprintf(pDebugFile,"\n ===== WARNING: %i points have poor quality donors. ==== \n",numberToCheck);
      	}
      	bool ok=true;
      	for(int i=0; i<numberToCheck; i++ ) 
      	{
                      int ii=cid[i].i;
         	   if( IA(ii,3)==canNotInterpolate )
         	   {
                          int i1=IA(ii,0), i2=IA(ii,1), i3=IA(ii,2);
                          if( debug & 4 )
             	       fprintf(pDebugFile,"level=%i, grid=%i, Unable to interpolate pt ii=%i iv=(%i,%i,%i) mask1=%i\n",level,grid,ii,i1,i2,i3,
                		    MASK1(i1,i2,i3));

             // --- look for a neighbour that can interpolate and use the same donor ---
                          int quality=canNotInterpolate; // look for best quality neighbour
                          int neighbourIndex=-1;         // save IA index of best neighbour here 
                          const int width=1, width3=numberOfDimensions==2 ? 0 : width;
           	     for( int j3=i3-width3; j3<=i3+width3; j3++ )
           	     {
             	       for( int j2=i2-width ; j2<=i2+width ; j2++ )
             	       {
             		 for( int j1=i1-width ; j1<=i1+width ; j1++ )
             		 {
               		   if( debug & 4 )
                 		     fprintf(pDebugFile," jv=(%i,%i,%i) mask1=%i : ",j1,j2,j3,MASK1(j1,j2,j3));
               		   if( (j1!=i1 || j2!=i2 || j3!=i3) && MASK1(j1,j2,j3)<0 )
               		   {
                 		     int jj= -MASK1(j1,j2,j3)-1;
                 		     assert( jj>=0 && jj<ni0 );
                 		     if( debug & 4 )
                   		       fprintf(pDebugFile," canInterp=%i (0=best,%i=no), donor=%i il=(%i,%i) r=(%e,%e)",IA(jj,3),(int)canNotInterpolate,
                        			      interpoleeGrid(jj),
                        			      interpoleeLocation(jj,0),interpoleeLocation(jj,1),
                        			      interpolationCoordinates(jj,0),interpolationCoordinates(jj,1));

                 		     int newQuality=IA(jj,3);
                 		     if( newQuality<quality )
                 		     {
                   		       quality=newQuality;
                                              neighbourIndex=jj;
                 		     }
                 		     
               		   }
               		   if( debug & 4 ) fprintf(pDebugFile,"\n");
             		 }
             	       }
           	     }
           	     if( quality!=canNotInterpolate )
           	     {
               // --- use the donor from a neighbour ---
               // For now just use the same interp. coords -- we could do better

                              if( debug & 4 ) fprintf(pDebugFile,"Use donor from neighbour with index jj=%i, quality=%i\n",neighbourIndex,quality);

             	       IA(ii,3)=canInterpolateQualityVeryBad; // mark this point as canInterpolate but with poor quality

             	       for( int axis=0; axis<numberOfDimensions; axis++ )
             	       {
             		 interpolationPoint(ii,axis)      =IA(ii,axis);
             		 interpolationCoordinates(ii,axis)=interpolationCoordinates(neighbourIndex,axis);
             		 interpoleeLocation(ii,axis)      =interpoleeLocation(neighbourIndex,axis);
             	       }
             	       interpoleeGrid(ii)=interpoleeGrid(neighbourIndex);
             	       variableInterpolationWidth(ii)=variableInterpolationWidth(neighbourIndex);

           	     }
         	   } // end if IA(ii,3)==canNotInterpolate
         	   
         	   if( IA(ii,3)==canNotInterpolate )
           	     ok=false;

      	}
      	if( !ok )
      	{
          // *FIX ME* -- as a backup we could just interpolate from the a nearby point on the same grid?

        	  printf("Ogmg::buildExtraLevels:ERROR: unable to find donors for some coarse grid points!\n");
        	  printf("      level=%i, grid=%i, number not found=%i!\n",level,grid,numberToCheck);
        	  printf("myid=%i : grid=%i numberOfInterpolationPoints=%i\n",myid,grid,numberOfInterpolationPoints(grid));
        	  ::display(interpolationPoint,"interpolationPoint");
        	  ::display(interpoleeGrid,"interpoleeGrid");

        	  OV_ABORT("ERROR");
      	}
      	
            }

            delete [] cid;
            delete [] cir;
            

            timeForValidStencil+=getCPU()-timea;
            
            if( debugb & 4 )
            {
      	display(interpoleeLocation,sPrintF(buff,"interpoleeLocation, level=%i grid=%i",level,grid),pDebugFile);
      	display(interpolationCoordinates,sPrintF(buff,"interpolationCoordinates, level=%i grid=%i",level,grid),pDebugFile);
      	display(variableInterpolationWidth,sPrintF(buff,"variableInterpolationWidth, level=%i grid=%i",level,grid),pDebugFile);
            }
            


        }  // end for grid
        timeForBuildInterpolation+=getCPU()-timeb;
        


    // --- mark ghost points as "2" or 0  ---
    // note: this next routine also does a periodic update
        markGhostPoints( cg1 );
        if( debugb & 4 )
        {
            for( int grid=0; grid<cg1.numberOfComponentGrids(); grid++ )
            {
      	intSerialArray mask1Local; getLocalArrayWithGhostBoundaries(cg1[grid].mask(),mask1Local);
      	displayMask(mask1Local,"Ogmg::buildExtraLevels: mask1 after markGhostPoints",pDebugFile);
            }
        }
        

    // display(cg1.numberOfInterpolationPoints,"cg1.numberOfInterpolationPoints");
        

    // dimension new serial array interpolation data arrays
#define adjustSizeMacro(x,n)			while( x.getLength() < n )			x.addElement();				while( x.getLength() > n )			x.deleteElement()

    // *wdh* 091201 -- for parallel see classify.C l. 3879 ---

    // **TODO: set cg1->numberOfInterpolationPointsLocal  ------------------------------------************** FIX
    //             cg1->interpolationStartEndIndexLocal 

          #ifdef USE_PPP
      // numberOfInterpolationPoints(grid) = number of interp pts. on this processor
      // cg1.numberOfInterpolationPoints(grid) = sum total over all processors

            ParallelUtility::getSums( &numberOfInterpolationPoints(0), &cg1.numberOfInterpolationPoints(0), numberOfComponentGrids);

      // tell the CompositeGrid that we are storing the interp data in a local serial form:
            cg1->localInterpolationDataState=CompositeGridData::localInterpolationDataForAll;

            adjustSizeMacro(cg1->interpolationPointLocal,numberOfComponentGrids);
            adjustSizeMacro(cg1->interpoleeGridLocal,numberOfComponentGrids);
            adjustSizeMacro(cg1->variableInterpolationWidthLocal,numberOfComponentGrids);
            adjustSizeMacro(cg1->interpoleeLocationLocal,numberOfComponentGrids);
            adjustSizeMacro(cg1->interpolationCoordinatesLocal,numberOfComponentGrids);
        #else
          cg1.numberOfInterpolationPoints(Rg)=numberOfInterpolationPoints(Rg);
     // now we know how many interpolation points there are so we can create the arrays in the cg.
          cg1.update(
              CompositeGrid::THEinterpolationPoint       |
              CompositeGrid::THEinterpoleeGrid           |
              CompositeGrid::THEinterpoleeLocation       |
              CompositeGrid::THEinterpolationCoordinates,
              CompositeGrid::COMPUTEnothing);
        #endif

        if( debugb & 4 )
            display(cg1.numberOfInterpolationPoints,"cg1.numberOfInterpolationPoints",debugFile);


    //  printF("*** mgcg.interpolationIsAllExplicit()=%i\n",mgcg.interpolationIsAllExplicit());
    //  printF("*** cg0.interpolationIsAllExplicit()=%i\n",cg0.interpolationIsAllExplicit());
    //  printF("*** cg1.interpolationIsAllExplicit()=%i\n",cg1.interpolationIsAllExplicit());
    // 	cg1.interpolationIsImplicit.display("cg1.interpolationIsImplicit");

    // ---- Fill in the interpolation info. ----

        cg1->numberOfInterpolationPointsLocal.redim(cg1.numberOfComponentGrids());
        IntegerArray & interpolationStartEndIndex = cg1->interpolationStartEndIndex;
        

        IntegerArray gridStart(cg1.numberOfComponentGrids()), ng(cg1.numberOfComponentGrids());
        for( int grid=0; grid<cg1.numberOfComponentGrids(); grid++ )
        {
            for( int grid2=0; grid2<cg1.numberOfComponentGrids(); grid2++ )
            {
	// in parallel we set interpolation is implicit even if there are no local interp pts: *wdh* 100101
      	mgcg.interpolationIsImplicit(grid,grid2,level)=true;
      	cg1.interpolationIsImplicit(grid,grid2,0)=true;

            }
            
            cg1->numberOfInterpolationPointsLocal(grid)=numberOfInterpolationPoints(grid);
            if( numberOfInterpolationPoints(grid) > 0 )
            {
                const int nig=numberOfInterpolationPoints(grid);

                #ifdef USE_PPP
                  intSerialArray & interpoleeGrid1             = cg1->interpoleeGridLocal[grid]; 
                  intSerialArray & interpolationPoint1         = cg1->interpolationPointLocal[grid];
                  intSerialArray & interpoleeLocation1         = cg1->interpoleeLocationLocal[grid];
                  intSerialArray & variableInterpolationWidth1 = cg1->variableInterpolationWidthLocal[grid];
                  realSerialArray & interpolationCoordinates1  = cg1->interpolationCoordinatesLocal[grid];

                  interpoleeGrid1.redim(nig);
                  interpolationPoint1.redim(nig,numberOfDimensions);
                  interpoleeLocation1.redim(nig,numberOfDimensions);
                  variableInterpolationWidth1.redim(nig);
                  interpolationCoordinates1.redim(nig,numberOfDimensions);

                #else
                  const intArray & interpoleeGrid1            = cg1.interpoleeGrid[grid]; 
                  const intArray & interpolationPoint1        = cg1.interpolationPoint[grid];
       	 intArray & interpoleeLocation1              = cg1.interpoleeLocation[grid];
                  intArray & variableInterpolationWidth1      = cg1.variableInterpolationWidth[grid];
                  const realArray & interpolationCoordinates1 = cg1.interpolationCoordinates[grid];
                #endif  

      	intSerialArray & interpoleeGrid            = interpoleeGridA[grid];
      	intSerialArray & interpolationPoint        = interpolationPointA[grid];
      	intSerialArray & interpoleeLocation        = interpoleeLocationA[grid];
                intSerialArray & variableInterpolationWidth=variableInterpolationWidthA[grid];
      	realSerialArray & interpolationCoordinates = interpolationCoordinatesA[grid]; 

            const int *interpoleeLocationp = interpoleeLocation.Array_Descriptor.Array_View_Pointer1;
            const int interpoleeLocationDim0=interpoleeLocation.getRawDataSize(0);
#define il(i0,i1) interpoleeLocationp[i0+interpoleeLocationDim0*(i1)]
            int *interpoleeLocation1p = interpoleeLocation1.Array_Descriptor.Array_View_Pointer1;
            const int interpoleeLocation1Dim0=interpoleeLocation1.getRawDataSize(0);
#define il1(i0,i1) interpoleeLocation1p[i0+interpoleeLocation1Dim0*(i1)]

            const int *interpolationPointp = interpolationPoint.Array_Descriptor.Array_View_Pointer1;
            const int interpolationPointDim0=interpolationPoint.getRawDataSize(0);
#define ip(i0,i1) interpolationPointp[i0+interpolationPointDim0*(i1)]
            int *interpolationPoint1p = interpolationPoint1.Array_Descriptor.Array_View_Pointer1;
            const int interpolationPoint1Dim0=interpolationPoint1.getRawDataSize(0);
#define ip1(i0,i1) interpolationPoint1p[i0+interpolationPoint1Dim0*(i1)]

            const real *interpolationCoordinatesp = interpolationCoordinates.Array_Descriptor.Array_View_Pointer1;
            const int interpolationCoordinatesDim0=interpolationCoordinates.getRawDataSize(0);
#define ci(i0,i1) interpolationCoordinatesp[i0+interpolationCoordinatesDim0*(i1)]
            real *interpolationCoordinates1p = interpolationCoordinates1.Array_Descriptor.Array_View_Pointer1;
            const int interpolationCoordinates1Dim0=interpolationCoordinates1.getRawDataSize(0);
#define ci1(i0,i1) interpolationCoordinates1p[i0+interpolationCoordinates1Dim0*(i1)]


            int * interpoleeGridp = interpoleeGrid.Array_Descriptor.Array_View_Pointer0;
#define ig(i0) interpoleeGridp[i0]
            int * interpoleeGrid1p = interpoleeGrid1.Array_Descriptor.Array_View_Pointer0;
#define ig1(i0) interpoleeGrid1p[i0]
            int * ngp = ng.Array_Descriptor.Array_View_Pointer0;
#define NG(i0) ngp[i0]

            int * gridStartp = gridStart.Array_Descriptor.Array_View_Pointer0;
#define GRIDSTART(i0) gridStartp[i0]
            const int * variableInterpolationWidthp = variableInterpolationWidth.Array_Descriptor.Array_View_Pointer0;
#define viw(i0) variableInterpolationWidthp[i0]
            int * variableInterpolationWidth1p = variableInterpolationWidth1.Array_Descriptor.Array_View_Pointer0;
#define viw1(i0) variableInterpolationWidth1p[i0]

        // -- order the interpolation points by interpolee grid. ---
      	ng=0;
      	for( int i=0; i<nig; i++ )
      	{
// 	  if( ig(i)<0 || ig(i) >= cg1.numberOfComponentGrids() ) 
// 	  {
// 	    printf("ERROR: level=%i, grid=%i, i=%i ig(i)=%i numberOfComponentGrids=%i\n",level,grid,i,ig(i),cg1.numberOfComponentGrids());
//             ::display(interpoleeGrid,"interpoleeGrid");
//             ::display(interpolationPoint,"interpolationPoint");
//             ::display(interpolationCoordinates,"interpolationCoordinates");
//             OV_ABORT("error");
// 	  }
        	  NG(ig(i))++;
      	}
          	    
      	GRIDSTART(0)=0;
      	for( int grid2=1; grid2<cg1.numberOfComponentGrids(); grid2++ )
        	  GRIDSTART(grid2)=GRIDSTART(grid2-1)+NG(grid2-1);
      	
        // ***** we need to assign the interpolationStartEndIndex 
        // **** this needs to be set on multigridLevel[0] too ********

        // for now we assume that the interpolation is implicit on coarser levels *** fix this ***

                cg1.interpolationIsAllExplicit()=false;
                cg1.interpolationIsAllImplicit()=true;
      	
      	for( int grid2=0; grid2<cg1.numberOfComponentGrids(); grid2++ )
      	{
        	  if( NG(grid2)>0 )
        	  {

          	    interpolationStartEndIndex(0,grid,grid2)=GRIDSTART(grid2);              // start value
          	    interpolationStartEndIndex(1,grid,grid2)=GRIDSTART(grid2)+NG(grid2)-1;  // end value
          	    if( true || cg1.interpolationIsImplicit(grid,grid2,0) )
            	      interpolationStartEndIndex(2,grid,grid2)= interpolationStartEndIndex(1,grid,grid2);
            // fix this: put any implicit points first
            // 	   else if( ngi(grid2)>0 )
            // 	     cg1.interpolationStartEndIndex(2,grid,grid2)=GRIDSTART(grid2)+ngi(grid2)-1; // end value for implicit pts.
        	  }
      	}


                if( numberOfDimensions==2 )
      	{
        	  for( int i=0; i<nig; i++ )
        	  {
          	    int grid2=ig(i);
          	    int j=GRIDSTART(grid2);
          	    ig1(j)=grid2;
          	    ip1(j,0)=ip(i,0);
          	    ip1(j,1)=ip(i,1);
          	    il1(j,0)=il(i,0);
          	    il1(j,1)=il(i,1);
          	    ci1(j,0)=ci(i,0);
          	    ci1(j,1)=ci(i,1);
          	    viw1(j)=viw(i);
        	  
          	    GRIDSTART(grid2)++;
        	  }
      	}
      	else
      	{
        	  for( int i=0; i<nig; i++ )
        	  {
          	    int grid2=ig(i);
          	    int j=GRIDSTART(grid2);
          	    interpoleeGrid1(j)=grid2;
          	    ip1(j,0)=ip(i,0);
          	    ip1(j,1)=ip(i,1);
          	    ip1(j,2)=ip(i,2);
          	    il1(j,0)=il(i,0);
          	    il1(j,1)=il(i,1);
          	    il1(j,2)=il(i,2);
          	    ci1(j,0)=ci(i,0);
          	    ci1(j,1)=ci(i,1);
          	    ci1(j,2)=ci(i,2);
          	    viw1(j)=viw(i);
        	  
          	    GRIDSTART(grid2)++;
        	  }
      	}
      	
      	if( debugb & 4 )
      	{
        	  fprintf(pDebugFile,"myid=%i : grid=%i numberOfInterpolationPoints=%i\n",myid,grid,numberOfInterpolationPoints(grid));
        	  ::display(interpolationPoint1,"interpolationPoint1",pDebugFile);
        	  ::display(interpoleeGrid1,"interpoleeGrid1",pDebugFile);
        	  ::display(interpoleeLocation1,"interpoleeLocation1",pDebugFile);
        	  ::display(variableInterpolationWidth1,"variableInterpolationWidth1",pDebugFile);
        	  ::display(interpolationCoordinates1,"interpolationCoordinates1",pDebugFile,"%5.2f ");
      	}

            } // end if num-interp > 0 


        } // end for grid 
        
    
    //  Tell the CompositeGrid that the interpolation data have been computed:
        cg1->computedGeometry |=
            CompositeGrid::THEmask                     |
            CompositeGrid::THEinterpolationCoordinates |
            CompositeGrid::THEinterpolationPoint       |
            CompositeGrid::THEinterpoleeLocation       |
            CompositeGrid::THEinterpoleeGrid;

    // we also need to mark each MappedGrid (or else we lose the mask if we put/get to a file)
        for( int grid=0; grid<cg1.numberOfComponentGrids(); grid++ )
            cg1[grid]->computedGeometry |= MappedGrid::THEmask;     // added 030829 *wdh*



    // --- Save the local interp data in the top level CompositeGrid  mgcg ---
        #ifdef USE_PPP
        if( l==0 )
        {
      // -- now we have local interp. data at all levels, including level=0 ---

      // --- is this needed ?
            mgcg->localInterpolationDataState=CompositeGridData::localInterpolationDataForAll;

      // Why dor we fill in all levels here ? 
            const int numGridsAllLevels = numberOfComponentGrids*mgcg.numberOfMultigridLevels();  // total number of grids over all levels
            adjustSizeMacro(mgcg->interpolationPointLocal,numGridsAllLevels);
            adjustSizeMacro(mgcg->interpoleeGridLocal,numGridsAllLevels);
            adjustSizeMacro(mgcg->variableInterpolationWidthLocal,numGridsAllLevels);
            adjustSizeMacro(mgcg->interpoleeLocationLocal,numGridsAllLevels);
            adjustSizeMacro(mgcg->interpolationCoordinatesLocal,numGridsAllLevels);

            mgcg->numberOfInterpolationPointsLocal.redim(numGridsAllLevels);
        }
        
        if( true )
        {
      // --- We replace the interpolation data on the previous level (l) with the interpolation data ---
      //     that is local to this processor (computed with getLocalInterpolationData) 
      // NOTE: the "local" interp data computed above for level="level" is local to the finer level grid, level=l
      //       not the current level
            CompositeGrid & cgl = mgcg.multigridLevel[l];
            cgl->localInterpolationDataState=CompositeGridData::localInterpolationDataForAll;
            adjustSizeMacro(cgl->interpolationPointLocal,numberOfComponentGrids);
            adjustSizeMacro(cgl->interpoleeGridLocal,numberOfComponentGrids);
            adjustSizeMacro(cgl->variableInterpolationWidthLocal,numberOfComponentGrids);
            adjustSizeMacro(cgl->interpoleeLocationLocal,numberOfComponentGrids);
            adjustSizeMacro(cgl->interpolationCoordinatesLocal,numberOfComponentGrids);

            cgl->numberOfInterpolationPointsLocal.redim(numberOfComponentGrids);
            for( int grid=0; grid<numberOfComponentGrids; grid++ )
            {
                InterpolationData & ipd = interpData[grid];

      	if( debugb & 2 )
      	{
        	  fprintf(pDebugFile," Ogmg: Fill-in local-interp data at level=%i : grid=%i, ni=%i\n",l,grid,ipd.numberOfInterpolationPoints);
	  // ::display(ipd.interpolationPoint,"ipd.interpolationPoint");
      	}
      	
                cgl->numberOfInterpolationPointsLocal(grid)=ipd.numberOfInterpolationPoints;
                cgl->interpolationPointLocal[grid].reference(ipd.interpolationPoint);
                cgl->interpoleeGridLocal[grid].reference(ipd.interpoleeGrid);
                cgl->variableInterpolationWidthLocal[grid].reference(ipd.variableInterpolationWidth);
                cgl->interpoleeLocationLocal[grid].reference(ipd.interpoleeLocation);
                cgl->interpolationCoordinatesLocal[grid].reference(ipd.interpolationCoordinates);
            }

            if( false  )
            {
      	for( int grid=0; grid<cgl.numberOfComponentGrids(); grid++ )
      	{
        	  printF(" grid=%i, nig=%i\n",grid,cgl->numberOfInterpolationPointsLocal(grid));
        	  ::display(cgl->interpoleeGridLocal[grid],"cgl->interpoleeGridLocal");
        	  ::display(cgl->interpolationPointLocal[grid],"cgl->interpolationPointLocal");
      	}
      	
            }

      // sort the local interp. arrays and build the interpolationStartEndIndex array: 
            ParallelGridUtility::sortLocalInterpolationPoints(cgl);

            if( level==lastLevel )
            {
        // --- On the coarsest level we transfer the interpolation data to local arrays  ---
        // -- this is duplicate code from above : fix me --
                InterpolationData *interpData=NULL;
      	ParallelGridUtility::getLocalInterpolationData( cg1, interpData );
      	CompositeGrid & cgl = mgcg.multigridLevel[level];  // Note: level (not l)
      	cgl->localInterpolationDataState=CompositeGridData::localInterpolationDataForAll;
      	adjustSizeMacro(cgl->interpolationPointLocal,numberOfComponentGrids);
      	adjustSizeMacro(cgl->interpoleeGridLocal,numberOfComponentGrids);
      	adjustSizeMacro(cgl->variableInterpolationWidthLocal,numberOfComponentGrids);
      	adjustSizeMacro(cgl->interpoleeLocationLocal,numberOfComponentGrids);
      	adjustSizeMacro(cgl->interpolationCoordinatesLocal,numberOfComponentGrids);

      	cgl->numberOfInterpolationPointsLocal.redim(numberOfComponentGrids);
      	for( int grid=0; grid<numberOfComponentGrids; grid++ )
      	{
        	  InterpolationData & ipd = interpData[grid];

        	  if( debugb & 2 )
        	  {
          	    fprintf(pDebugFile," Ogmg: Fill-in local-interp data at level=%i : grid=%i, ni=%i (LAST level)\n",
                                      level,grid,ipd.numberOfInterpolationPoints);
	    // ::display(ipd.interpolationPoint,"ipd.interpolationPoint");
        	  }
      	
        	  cgl->numberOfInterpolationPointsLocal(grid)=ipd.numberOfInterpolationPoints;
        	  cgl->interpolationPointLocal[grid].reference(ipd.interpolationPoint);
        	  cgl->interpoleeGridLocal[grid].reference(ipd.interpoleeGrid);
        	  cgl->variableInterpolationWidthLocal[grid].reference(ipd.variableInterpolationWidth);
        	  cgl->interpoleeLocationLocal[grid].reference(ipd.interpoleeLocation);
        	  cgl->interpolationCoordinatesLocal[grid].reference(ipd.interpolationCoordinates);
      	}

	// sort the local interp. arrays and build the interpolationStartEndIndex array: 
      	ParallelGridUtility::sortLocalInterpolationPoints(cgl);

                delete [] interpData;

            }

        }

        #endif

        delete [] interpData;


#undef ip
#undef il
#undef ig
#undef viw
#undef ci

    //  -- save a check file of the grid interpolation data so we can compare serial and parallel results ---
        if( parameters.saveGridCheckFile )
        {
            
            fPrintF(gridCheckFile," =================== Interpolation data for level %i =================\n",level);
            for( int grid=0; grid<cg1.numberOfComponentGrids(); grid++ )
            {
      	const int ni = cg1.numberOfInterpolationPoints(grid);
      	fPrintF(gridCheckFile," level=%i, grid=%i, numberOfInterpolationPoints=%i\n",
            		level,grid,ni);

      	if( ni==0 ) continue;

        // save interp data
                #ifdef USE_PPP
                  intSerialArray & interpoleeGrid1             = cg1->interpoleeGridLocal[grid]; 
                  intSerialArray & interpolationPoint1         = cg1->interpolationPointLocal[grid];
                  intSerialArray & interpoleeLocation1         = cg1->interpoleeLocationLocal[grid];
                  intSerialArray & variableInterpolationWidth1 = cg1->variableInterpolationWidthLocal[grid];
                  realSerialArray & interpolationCoordinates1  = cg1->interpolationCoordinatesLocal[grid];

	 // gather interp data to myid=0 so we can output
                  const int destProc=0;
           	 intSerialArray ip,il;
                  realSerialArray ci;
                  Iv[0]=interpolationPoint1.dimension(0);
                  Iv[1]=Range(numberOfDimensions);
	 // if( gridCheckFile!=NULL )
         //  ::display(interpolationPoint1,"interpolationPoint1",gridCheckFile);
       	 CopyArray::getAggregateArray( interpolationPoint1, Iv, ip, destProc );
       	 CopyArray::getAggregateArray( interpoleeLocation1, Iv, il, destProc );
       	 CopyArray::getAggregateArray( interpolationCoordinates1, Iv, ci, destProc );
                  intSerialArray ig,viw;
       	 Iv[1]=Range(0,0);
                  CopyArray::getAggregateArray( interpoleeGrid1, Iv, ig, destProc );
                  CopyArray::getAggregateArray( variableInterpolationWidth1, Iv, viw, destProc );

                #else
                  const intArray & ig  = cg1.interpoleeGrid[grid]; 
                  const intArray & ip  = cg1.interpolationPoint[grid];
       	 const intArray & il  = cg1.interpoleeLocation[grid];
                  const intArray & viw = cg1.variableInterpolationWidth[grid];
                  const realArray & ci = cg1.interpolationCoordinates[grid];
                #endif  

        // We sort into ascending order of ip(i,0) and secondarily in ascending order of ip(i,1)
                const int nip=ip.getLength(0);
      	IntegerArray perm(ip.dimension(0));
      	perm.seqAdd(0,1);

      	if( numberOfDimensions==2 )
      	{
        	  SortCmp2d cmp(ip); // this class knows how to compare two elements of ip in 2D
        	  std::sort( &perm(perm.getBase(0)),&perm(perm.getBase(0))+nip, cmp );
      	}
      	else
      	{
        	  SortCmp3d cmp(ip); // this class knows how to compare two elements of ip in 3D
        	  std::sort( &perm(perm.getBase(0)),&perm(perm.getBase(0))+nip, cmp );
      	}
      	
      	for( int j=ip.getBase(0); j<=ip.getBound(0); j++ )
      	{
                    int i=perm(j);
        	  fPrintF(gridCheckFile," i=%i, ip=(%i,%i,%i) il=(%i,%i,%i) donor=%i viw=%i ci=(%5.2f,%5.2f,%5.2f)\n",
                                  j,
              		  ip(i,0),ip(i,1),(numberOfDimensions==2? 0 : ip(i,2)),
              		  il(i,0),il(i,1),(numberOfDimensions==2? 0 : il(i,2)),ig(i),viw(i),
                                    ci(i,0),ci(i,1),(numberOfDimensions==2? 0 : ci(i,2)));
      	}

            } // end for grid
        } 

        if( false )
        {
            fflush(pDebugFile);
            OV_ABORT("Ogmg:buildExtraLevelsNew: stop here for now");
        }

        if( debugb & 16 && ps!=NULL )
        {
            ps->erase();
            PlotIt::plot(*ps,mgcg);
            PlotIt::plot(*ps,cg1);
        }
        
        
    } // end for l 
  // ----------------------------------------------------------------------------------------------
  // ------------------------------- END LOOP OVER LEVELS -----------------------------------------
  // ----------------------------------------------------------------------------------------------

    
    if( false )
    {
        fflush(pDebugFile);
        OV_ABORT("Ogmg:buildExtraLevelsNew: stop here for now");
    }
            
  // -- fill in the interpolation data in the main CompositeGrid ---
    if( newWay )
    {
        for( int l=0; l<mgcg.numberOfMultigridLevels(); l++ )
        {
            Range Rl = Rg + mgcg.numberOfComponentGrids()*l;
            mgcg.numberOfInterpolationPoints(Rl)=mgcg.multigridLevel[l].numberOfInterpolationPoints(Rg);
        }
      // for( int l=1; l<mgcg.numberOfMultigridLevels(); l++ )
        for( int l=0; l<mgcg.numberOfMultigridLevels(); l++ )
        {
            CompositeGrid & cgl = mgcg.multigridLevel[l];
            int gridl=l*mgcg.numberOfComponentGrids();
            for( int grid=0; grid<cgl.numberOfComponentGrids(); grid++ )
            {
                #ifdef USE_PPP
         	 mgcg->numberOfInterpolationPointsLocal(gridl)=cgl->numberOfInterpolationPointsLocal(grid);
       	 mgcg->interpolationPointLocal[gridl].reference(cgl->interpolationPointLocal[grid]);
       	 mgcg->interpoleeGridLocal[gridl].reference(cgl->interpoleeGridLocal[grid]);
       	 mgcg->interpoleeLocationLocal[gridl].reference(cgl->interpoleeLocationLocal[grid]);
       	 mgcg->variableInterpolationWidthLocal[gridl].reference(cgl->variableInterpolationWidthLocal[grid]);
       	 mgcg->interpolationCoordinatesLocal[gridl].reference(cgl->interpolationCoordinatesLocal[grid]);

                  if( false && debug & 2 )
       	 {
                      realSerialArray & ci = mgcg->interpolationCoordinatesLocal[gridl];
                      printF(" level=%i grid=%i gridl=%i niLocal=%i ci=[%i,%i]\n",l,grid,gridl,
              		  mgcg->numberOfInterpolationPointsLocal(gridl),
                                    ci.getBase(0),ci.getBound(0));
        	  realSerialArray & cil= cgl->interpolationCoordinatesLocal[grid];
        	  printF(" level=%i grid=%i gridl=%i cgl: niLocal=%i ci=[%i,%i]\n",l,grid,gridl,
             		 cgl->numberOfInterpolationPointsLocal(grid),
             		 cil.getBase(0),ci.getBound(0));
       	 }
       	 

                #else
       	 mgcg->interpolationPoint[gridl].reference(cgl->interpolationPoint[grid]);
       	 mgcg->interpoleeGrid[gridl].reference(cgl->interpoleeGrid[grid]);
       	 mgcg->interpoleeLocation[gridl].reference(cgl->interpoleeLocation[grid]);
       	 mgcg->variableInterpolationWidth[gridl].reference(cgl->variableInterpolationWidth[grid]);
       	 mgcg->interpolationCoordinates[gridl].reference(cgl->interpolationCoordinates[grid]);
                #endif
                gridl++;
            }

            for( int grid=0; grid<cgl.numberOfComponentGrids(); grid++ )
            {
      	for( int grid2=0; grid2<cgl.numberOfComponentGrids(); grid2++ )
      	{
        	  int g=grid+l*mgcg.numberOfComponentGrids();
        	  int g2=grid2+l*mgcg.numberOfComponentGrids();
        	  mgcg.interpolationStartEndIndex(Range(0,2),g,g2)=cgl.interpolationStartEndIndex(Range(0,2),grid,grid2);

          // not used? : mgcg->interpolationStartEndIndexLocal(Range(0,2),g,g2)=cgl->interpolationStartEndIndexLocal(Range(0,2),grid,grid2);
      	}
            }
            
        }
        mgcg.updateReferences();
        
        if( false && debug & 2 )
        {
            for( int l=0; l<mgcg.numberOfMultigridLevels(); l++ )
            {
      	CompositeGrid & cgl = mgcg.multigridLevel[l];
      	int gridl=l*mgcg.numberOfComponentGrids();
      	for( int grid=0; grid<cgl.numberOfComponentGrids(); grid++ )
      	{
        	  realSerialArray & ci = mgcg->interpolationCoordinatesLocal[gridl];
        	  printF("AFTER updateRef's :  level=%i grid=%i gridl=%i mgcg: niLocal=%i ci=[%i,%i]\n",l,grid,gridl,
             		 mgcg->numberOfInterpolationPointsLocal(gridl),
             		 ci.getBase(0),ci.getBound(0));
        	  realSerialArray & cil= cgl->interpolationCoordinatesLocal[grid];
        	  printF("AFTER updateRef's :  level=%i grid=%i gridl=%i cgl: niLocal=%i ci=[%i,%i]\n",l,grid,gridl,
             		 cgl->numberOfInterpolationPointsLocal(grid),
             		 cil.getBase(0),ci.getBound(0));
                    
      	}
            }
        }
        

    // Tell the CompositeGrid that the interpolation data have been computed:
        mgcg->computedGeometry |=
            CompositeGrid::THEmask                     |
            CompositeGrid::THEinterpolationCoordinates |
            CompositeGrid::THEinterpolationPoint       |
            CompositeGrid::THEinterpoleeLocation       |
            CompositeGrid::THEinterpoleeGrid;

    // ::display(mgcg.numberOfInterpolationPoints,"buildExtra: mgcg.numberOfInterpolationPoints");    
        
    }
    
    
    delete [] pMask1;

    delete [] pGridIndexRange0;
  // delete [] pDimension0;
  // delete [] pExtendedIndexRange0;
  // delete [] pIndexRange0;
    delete [] pBoundaryCondition0;

    delete [] pGridIndexRange1;
    delete [] pDimension1;
    delete [] pExtendedIndexRange1;
  // delete [] pIndexRange1;
    delete [] pBoundaryCondition1;

//   for( int l=0; l<mgcg.numberOfMultigridLevels(); l++ )
//   {
//     mgcg.multigridLevel[l]->computedGeometry |=
//       CompositeGrid::THEmask                     |
//       CompositeGrid::THEinterpolationCoordinates |
//       CompositeGrid::THEinterpolationPoint       |
//       CompositeGrid::THEinterpoleeLocation       |
//       CompositeGrid::THEinterpoleeGrid;
//   }
    

    delete [] iaA; // *wdh* added 040820
    delete [] interpoleeGridA;
    delete [] interpolationPointA;
    delete [] interpoleeLocationA;
    delete [] variableInterpolationWidthA;
    delete [] interpolationCoordinatesA;

//   for( l=level0; l<level0+numberOfExtraLevels; l++ )
//   {
//     mgcg.multigridLevel[level]->computedGeometry |=
//       CompositeGrid::THEmask                     |
//       CompositeGrid::THEinterpolationCoordinates |
//       CompositeGrid::THEinterpolationPoint       |
//       CompositeGrid::THEinterpoleeLocation       |
//       CompositeGrid::THEinterpoleeGrid;
//   }

  // printF(" **** debug=%i, debug & 1 = %i,  debug & 2 = %i,  debug & 4 = %i \n",debug,debug&1,debug&2,debug&4);
    
    if( debugb & 4 )
    {
    // -- check the grids ---

        Ogen ogen;
        int levelStart=1;  // 0 -- no need to check level 0 ?
        for( l=levelStart; l<mgcg.numberOfMultigridLevels(); l++ )
        {
      // Note: there is probably no need to check l==0 
      // Note: in parallel, explicit interpolation on l==0 requires extra parallel ghost for
      //       check CanInterpolate (2nd-order -> 2 ghost)
            int level=l;
      // Note: checkOverlappingGrid will check all levels.
      // CompositeGrid & cg0 = l==0 ? mgcg : mgcg.multigridLevel[l];
            CompositeGrid & cg0 = mgcg.multigridLevel[l];
            printF("--> checkOverlappingGrid: level %i...\n",level);
            int option=0;
            if( debug & 2 ) option=3;
            int rt=checkOverlappingGrid(cg0,option);
            if( rt==0 )
                printF("... level %i is OK\n",l);
            else
                printF("... level %i is NOT OK ****ERROR****\n",l);

      // int iv[3], &i1=iv[0], &i2=iv[1], &i3=iv[2];
      // Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
            int numErrors=0;
            IntegerArray errorsPerGrid(cg0.numberOfComponentGrids());
            errorsPerGrid=0;
            const bool checkOneSidedAtBoundaries=false;
            for( int grid=0; grid<cg0.numberOfComponentGrids(); grid++ )
            {
        // printF(" check: level=%i grid=%i numberOfInterpolationPoints=%i\n",
        //        l,grid,cg0.numberOfInterpolationPoints(grid));
      	
      	MappedGrid & mg = cg0[grid];
                const intArray & maskg = mg.mask();
                #ifdef USE_PPP
                  intSerialArray mask; getLocalArrayWithGhostBoundaries(maskg,mask);
                #else
                  const intSerialArray & mask = maskg;
                #endif

      	getIndex(mg.gridIndexRange(),I1,I2,I3);
                int includeGhost=0;  // no parallel ghost
                bool ok = ParallelUtility::getLocalArrayBounds(maskg,mask,I1,I2,I3,includeGhost);

      	if( ok )
      	{
        	  FOR_3D(i1,i2,i3,I1,I2,I3)
        	  {
          	    if( mask(i1,i2,i3)>0 )
          	    {
            	      if( !ogen.canDiscretize( mg,iv,checkOneSidedAtBoundaries ) ) // Note: iv==(i1,i2,i3)
            	      {
            		numErrors++;
            		errorsPerGrid(grid)++;
            		printf("buildExtraLevels:ERROR: myid=%i level=%i grid=%i Discretization pt (%i,%i,%i) cannot be discretized\n",
                   		       myid,l,grid,i1,i2,i3);
            		fprintf(pDebugFile,"buildExtraLevels:ERROR: myid=%i level=%i grid=%i Discretization pt (%i,%i,%i) cannot be discretized\n",
                  			myid,l,grid,i1,i2,i3);

            		Range J1(i1-1,i1+1),J2(i2-1,i2+1),J3(i3-1,i3+1);
            		if( numberOfDimensions==2 )
              		  J3=Range(i3,i3);

            		displayMask(mask(J1,J2,J3),"mask near i1,i2,i3",pDebugFile);
            	      
            	      }
          	    }
        	  }
      	}
      	
        //
        // Now we need to check that there are no discretization points in the ghost point region of
        // interpolation boundaries. (This is a mistake that can be made in the above algorithm)
                const IntegerArray & gir = mg.gridIndexRange();
                I3=gir(0,2);
                const int numGhostLines=orderOfAccuracy/2; // check this many ghost lines
      	for( int axis=0; axis<cg0.numberOfDimensions(); axis++ )
      	{
        	  for( int dir=0; dir<cg0.numberOfDimensions(); dir++ )
        	  {
          	    if( dir!=axis )
          	    {
            	      int na=gir(0,dir);
            	      int nb=gir(1,dir);
              // check adjacent ghost lines (thus corners) if the adjacent boundary is interpolation
            	      if( mg.boundaryCondition(0,dir)==0 ) na-=numGhostLines;
            	      if( mg.boundaryCondition(1,dir)==0 ) nb+=numGhostLines;
            	      Iv[dir]=Range(na,nb);
          	    }
        	  }
        	  for( int side=0; side<=1; side++ )
        	  {
                        if( mg.boundaryCondition(side,axis)==0 )
          	    {
            	      const int is=1-2*side;
            	      const int ghost=1;
	      // check "numGhostLines" different ghost lines :

            	      Iv[axis]=Range(mg.gridIndexRange(side,axis)-is,mg.gridIndexRange(side,axis)-is*numGhostLines);
                            bool ok = ParallelUtility::getLocalArrayBounds(maskg,mask,I1,I2,I3,includeGhost);
            	      if( !ok ) continue;
            	      FOR_3(i1,i2,i3,I1,I2,I3)
            	      {
            		if( mask(i1,i2,i3)>0 )
            		{
              		  numErrors++;
                    	          errorsPerGrid(grid)++;
              		  printf("ERROR: level=%i, grid=%i, ghost point (%i,%i,%i) (side,axis)=(%i,%i) mask=%i, "
                                                  "is a discretization pt!\n", l,grid,i1,i2,i3,side,axis,mask(i1,i2,i3));
              		  fprintf(pDebugFile,"ERROR: level=%i, grid=%i, ghost point (%i,%i,%i) (side,axis)=(%i,%i) mask=%i, "
                                                  "is a discretization pt!\n", l,grid,i1,i2,i3,side,axis,mask(i1,i2,i3));
            		}
            	      }
          	    }
        	  }
      	}
            }
            numErrors=ParallelUtility::getSum(numErrors);
            if( numErrors>0 )
            {
      	printF("$$$$ check points on level %i **ERROR** there were %i invalid points.\n",
             	       l,numErrors);
      	
      	OV_ABORT("ERROR");
            }
            else
            {
      	printF("$$$$ check points on level %i **PASSED***\n",l);
            }

        }
    }
    

    if( (debugb & 8) && level0==0 && ( mgcg.numberOfInterpolationPoints(0)>0)  )
    {
    // now test out the validity of the newly created levels.

        for( l=level0; l<level0+numberOfExtraLevels; l++ )
        {
            level=l+1;
            
            printF("\n\n **************** check extra level %i ******************* \n\n",level);

      // Check the validity of a grid by solving an elliptic problem on it.
            checkGrid( mgcg.multigridLevel[level],ps,debugb );
            
        }

    // exit(0);
    }
    
    if( false )
    {
      mgcg.interpolationStartEndIndex.display("buildExtraLevels: END:mgcg.interpolationStartEndIndex");
      mgcg.multigridLevel[0].interpolationStartEndIndex.display("buildExtraLevels:END: mgcg.multigridLevel[0].interpolationStartEndIndex");
    }
    
    if( gridCheckFile!=NULL )
    {
        fflush(gridCheckFile);
    }

    tm[timeForBuildExtraLevels]+=getCPU()-time0;
    if( debugb & 4 )
        printF(" ****tm[timeForBuildExtraLevels]=%8.2e buildMask=%8.2e buildInterp=%8.2e validStencil=%8.2e ****\n",
                      tm[timeForBuildExtraLevels],timeForBuildMask,timeForBuildInterpolation,timeForValidStencil);
    
    if( false )
    {
        fflush(pDebugFile);
        OV_ABORT("Ogmg:buildExtraLevelsNew: stop here for now");
    }


    debug=debugSave;

    return 0;
}



int Ogmg::
getInterpolationCoordinates( CompositeGrid & cg0, // finer grid
                                                          CompositeGrid & cg1, // new coarser grid
                                                          const IntegerArray & ib,     // check these points...
                       			     const int grid,            // ..on this grid
                                                          const IntegerArray & gridsToCheck, // ..from these grids
                                                          realSerialArray & rb,      // return these values
                                                          const bool isRectangular,
                                                          int iv0[3], real dx0[3], real xab0[2][3],   // these are used by Macros!
                                                          int iv1[3], real dx1[3], real xab1[2][3],
                                                          InterpolationData & ipd )
// ==================================================================================================
// /Description: ** new version that does many points at a time
//     Given a new interpolation point on a coarse grid, determine the r coordinates on the 
//   interpolee grid. 
//
// /ib (input) : ib(i,4) : (i,j1,j2,j3) 
// ==================================================================================================
{
    const int numberOfDimensions=cg0.numberOfDimensions();


    #ifdef USE_PPP
        intSerialArray & interpoleeGrid0 = ipd.interpoleeGrid;
        intSerialArray & interpolationPoint0 = ipd.interpolationPoint;
        realSerialArray & interpolationCoordinates0 = ipd.interpolationCoordinates;
    #else
        const intArray & interpoleeGrid0 =cg0.interpoleeGrid[grid];  // ************ should use cg0 ****
        const intArray & interpolationPoint0 =cg0.interpolationPoint[grid];
        const realArray & interpolationCoordinates0 =cg0.interpolationCoordinates[grid];
    #endif    


  // const intArray & interpoleeGrid0 =cg0.interpoleeGrid[grid];  // ************ should use cg0 ****
  // const realArray & interpolationCoordinates0 =cg0.interpolationCoordinates[grid];
    const real *interpolationCoordinates0p = interpolationCoordinates0.Array_Descriptor.Array_View_Pointer1;
    const int interpolationCoordinates0Dim0=interpolationCoordinates0.getRawDataSize(0);

    const int * interpoleeGrid0p = interpoleeGrid0.Array_Descriptor.Array_View_Pointer0;

  // const intArray & interpolationPoint0 =cg0.interpolationPoint[grid];
    const int *interpolationPoint0p = interpolationPoint0.Array_Descriptor.Array_View_Pointer1;
    const int interpolationPoint0Dim0=interpolationPoint0.getRawDataSize(0);

    MappedGrid & mg0 = cg0[grid];
    MappedGrid & mg1 = cg1[grid];
    #ifdef USE_PPP
        realSerialArray center;  if( !isRectangular ) getLocalArrayWithGhostBoundaries(mg1.center(),center);
        realSerialArray center0; if( !isRectangular ) getLocalArrayWithGhostBoundaries(mg0.center(),center0);
    #else
        const realArray & center = mg1.center();
        const realArray & center0 = mg0.center();
    #endif


    real *center0p;  
    int center0Dim0,center0Dim1,center0Dim2;
    real *centerp;
    int centerDim0,centerDim1,centerDim2;
    if( !isRectangular )
    {
        centerp = center.Array_Descriptor.Array_View_Pointer3;
        centerDim0=center.getRawDataSize(0);
        centerDim1=center.getRawDataSize(1);
        centerDim2=center.getRawDataSize(2);

        center0p = center0.Array_Descriptor.Array_View_Pointer3;
        center0Dim0=center0.getRawDataSize(0);
        center0Dim1=center0.getRawDataSize(1);
        center0Dim2=center0.getRawDataSize(2);

    }
#define CENTER0(i0,i1,i2,i3) center0p[i0+center0Dim0*(i1+center0Dim1*(i2+center0Dim2*(i3)))]	
            
    const int maxNumToInterp = ib.getLength(0);
    if( maxNumToInterp==0 ) return 0;

    realSerialArray x(maxNumToInterp,3), r(maxNumToInterp,3);
    IntegerArray ia(maxNumToInterp);
    
    real *xp = x.Array_Descriptor.Array_View_Pointer1;
    const int xDim0=x.getRawDataSize(0);
    real *rp = r.Array_Descriptor.Array_View_Pointer1;
    const int rDim0=r.getRawDataSize(0);

    int *iap = ia.Array_Descriptor.Array_View_Pointer0;
#undef IA
#define IA(i0) iap[i0]

    real *rbp = rb.Array_Descriptor.Array_View_Pointer1;
    const int rbDim0=rb.getRawDataSize(0);
#define RB(i0,i1) rbp[i0+rbDim0*(i1)]

    int *ibp = ib.Array_Descriptor.Array_View_Pointer1;
    const int ibDim0=ib.getRawDataSize(0);

    int ii,axis;
    int jv[3], &j1=jv[0], &j2=jv[1], &j3=jv[2];      
    int kv[3], &k1=kv[0], &k2=kv[1], &k3=kv[2];      
    int kpv[3], &kp1=kpv[0], &kp2=kpv[1], &kp3=kpv[2];      
    
#ifdef USE_PPP
  // -- parallel case : we cannot rely on being able to evaluate the center array -- 
  //    We evaluate the mapping instead 
    RealArray xc;
    real *xcp=NULL; // set below 
    int xcDim0;
    if( !isRectangular )
    {
        RealArray rc;
        if( maxNumToInterp>0 )
        {
            rc.redim(maxNumToInterp,numberOfDimensions);
            xc.redim(maxNumToInterp,numberOfDimensions);
        }
        real *rcp = rc.Array_Descriptor.Array_View_Pointer1;
        const int rcDim0=rc.getRawDataSize(0);
#define RC(i0,i1) rcp[i0+rcDim0*(i1)]
        xcp = xc.Array_Descriptor.Array_View_Pointer1;
        xcDim0=xc.getRawDataSize(0);
#define XC(i0,i1) xcp[i0+xcDim0*(i1)]
        
        const IntegerArray & gid1 = mg1.gridIndexRange();
        const RealArray & dr1 = mg1.gridSpacing();
        for( int i=0; i<maxNumToInterp; i++ )
        {
            for( int axis=0; axis<numberOfDimensions; axis++ )
      	RC(i,axis)= (IB(i,axis+1)-gid1(0,axis))*dr1(axis);   // r-coordinates of the point 
        }

        Mapping & map1 = mg1.mapping().getMapping();
        map1.mapS(rc,xc);

    }
#endif   


    for( int grid2=0; grid2<cg1.numberOfComponentGrids(); grid2++ )
    {
        if( gridsToCheck(grid2)==0 ) continue;  // no need to check this grid

    // collect up all new interpolation points that interpolate from grid2
        int jb=0;
        if( isRectangular )
        {
            if( numberOfDimensions==2 )
            {
      	for( int i=0; i<maxNumToInterp; i++ )
      	{
                    ii=IB(i,0);  // index into orginal interpolation point arrays
        	  if( ig0(ii)==grid2 )
        	  {
          	    j1=IB(i,1); j2=IB(i,2); j3=IB(i,3); 

          	    IA(jb)=i;  // save i
          	    X(jb,0)=CENTER10(j1,j2,j3);
          	    X(jb,1)=CENTER11(j1,j2,j3);
          	    R(jb,0)=ci0(ii,0);
          	    R(jb,1)=ci0(ii,1);
          	    R(jb,2)=0.;
          	    jb++;
        	  }
            
      	}
            }
            else
            {
      	for( int i=0; i<maxNumToInterp; i++ )
      	{
                    ii=IB(i,0);  // index into orginal interpolation point arrays
        	  if( ig0(ii)==grid2 )
        	  {
          	    j1=IB(i,1); j2=IB(i,2); j3=IB(i,3); 

          	    IA(jb)=i;
          	    X(jb,0)=CENTER10(j1,j2,j3);
          	    X(jb,1)=CENTER11(j1,j2,j3);
          	    X(jb,2)=CENTER12(j1,j2,j3);
          	    R(jb,0)=ci0(ii,0);
          	    R(jb,1)=ci0(ii,1);
          	    R(jb,2)=ci0(ii,2);
          	    jb++;
        	  }
      	}
            }
        }
        else
        { 
      // curvilinear case 
            if( numberOfDimensions==2 )
            {
      	for( int i=0; i<maxNumToInterp; i++ )
      	{
                    ii=IB(i,0);  // index into orginal interpolation point arrays
        	  if( ig0(ii)==grid2 )
        	  {
          	    j1=IB(i,1); j2=IB(i,2); j3=IB(i,3); 

          	    IA(jb)=i;
                        #ifndef USE_PPP
                	      X(jb,0)=CENTER(j1,j2,j3,0);
            	      X(jb,1)=CENTER(j1,j2,j3,1);
                        #else
                	      X(jb,0)=XC(i,0);
            	      X(jb,1)=XC(i,1);
                        #endif
          	    R(jb,0)=ci0(ii,0);
          	    R(jb,1)=ci0(ii,1);
          	    R(jb,2)=0.;
          	    jb++;
        	  }
      	}
            }
            else
            {
      	for( int i=0; i<maxNumToInterp; i++ )
      	{
                    ii=IB(i,0);  // index into orginal interpolation point arrays
        	  if( ig0(ii)==grid2 )
        	  {
          	    j1=IB(i,1); j2=IB(i,2); j3=IB(i,3); 

          	    IA(jb)=i;
                        #ifndef USE_PPP
            	      X(jb,0)=CENTER(j1,j2,j3,0);
            	      X(jb,1)=CENTER(j1,j2,j3,1);
            	      X(jb,2)=CENTER(j1,j2,j3,2);
                        #else
                	      X(jb,0)=XC(i,0);
            	      X(jb,1)=XC(i,1);
            	      X(jb,2)=XC(i,2);
                        #endif
          	    R(jb,0)=ci0(ii,0);
          	    R(jb,1)=ci0(ii,1);
          	    R(jb,2)=ci0(ii,2);
          	    jb++;
        	  }
      	}
            }
        } // end curvilinear 
        
        const int numToInterp=jb;
        if( numToInterp==0 ) continue;  // **** no points to interpolate   -------------- fix me parallel ----------
        
    // printF(" grid=%i : interpolate %i extra points from grid2=%i\n",grid,numToInterp,grid2);

        MappedGrid & g2 = cg1[grid2];
        const IntegerArray & extended = g2.extendedIndexRange(); 
        const realArray & center2 = g2.center();

        const bool g2IsRectangular=g2.isRectangular();
        real dx2[3], xra[3][3];
        if( g2IsRectangular )
        {
            g2.getDeltaX(dx2);
        }
        const real offset = parameters.allowExtrapolationOfInterpolationPoints ? 1. : 0.; // *wdh* 040903
        real rMin[3], rMax[3];
        for( axis=0; axis<numberOfDimensions; axis++ )
        {
      // normally limit r to [0,1] unless the boundary is interpolation, then limit by .25*Delta r
      // from the last interpolation point.
            const real dr = g2.gridSpacing(axis);
            rMin[axis] = g2.boundaryCondition(Start,axis)!=0  ? -dr*offset :
                                                        	                                                  (extended(Start,axis)+.25)*dr; // move in .25*Dr from the end
            rMax[axis] = g2.boundaryCondition(End  ,axis)!=0  ? 1.+dr*offset :(extended(End,  axis)-.25)*dr;
        }
            
        Range R=numToInterp, Rx=numberOfDimensions;
        
    // invert mapping to get coordinates of the new interpolation pt.
        Mapping & map2 = g2.mapping().getMapping();
        map2.useRobustInverse(true);
        r=-1.;
        #ifdef USE_PPP
            map2.inverseMapS(x(R,Rx),r);  // ** here is the expensive part **
        #else
            map2.inverseMap(x(R,Rx),r);  // ** here is the expensive part **
        #endif

        real dx[3], dr[3];
        real dr2[3]={g2.gridSpacing(0),g2.gridSpacing(1),g2.gridSpacing(2)}; //
        realSerialArray xx(1,3), rr(1,3);
        for( jb=0; jb<numToInterp; jb++ )
        {
            const int i=IA(jb);
            if( max(fabs(R(jb,0)),fabs(R(jb,1)),fabs(R(jb,2))) > 5. )
            {
	// pt was not invertible -- estimate it's inverse location

                const int ii=IB(i,0);
      	
          	for( axis=0; axis<numberOfDimensions; axis++ )   // *wdh* 021203
            	  R(jb,axis)=ci0(ii,axis);	


	// dx = distance from nearby interpolation pt to the new interpolation point.
	// add dr = (dr/dx)_2 * dx 
                int i1=ip0(ii,0), i2=ip0(ii,1);
                int i3=numberOfDimensions==2 ? 0 : ip0(ii,2);
                int j1=IB(i,1), j2=IB(i,2), j3=IB(i,3);
      	if( isRectangular )
      	{
        	  dx[0]=CENTER10(j1,j2,j3)-CENTER00(i1,i2,i3);
        	  dx[1]=CENTER11(j1,j2,j3)-CENTER01(i1,i2,i3);
        	  dx[2]=CENTER12(j1,j2,j3)-CENTER02(i1,i2,i3);

      	}
      	else
      	{
        	  for( axis=0; axis<numberOfDimensions; axis++ )
          	    dx[axis]=CENTER(j1,j2,j3,axis)-CENTER0(i1,i2,i3,axis);
      	}
      	if( g2IsRectangular )
      	{
        	  dr[0]=dx[0]/dx2[0]*dr2[0];
        	  dr[1]=dx[1]/dx2[1]*dr2[1];
        	  dr[2]=dx[2]/dx2[2]*dr2[2];
      	}    
      	else
      	{

        	  Mapping & map2 = g2.mapping().getMapping();
        	  rr=-1.;
        	  xx(0,Rx)=x(jb,Rx);
                    #ifdef USE_PPP
          	    OV_ABORT("Ogmg::getInterpolationCoordinates:ERROR: finish this");
            	  #else
              	    map2.approximateGlobalInverse->findNearestGridPoint(0,0,xx,rr);
                    #endif

                    if( debug & 4 )
          	    printF(" Ogmg:non-invertible pt: map2.usingRobustInverse()=%i, nearest: rr=(%8.2e,%8.2e,%8.2e)"
               		   " -> i=(%i,%i,%i)\n",
               		   (int)map2.usingRobustInverse(),rr(0,0),rr(0,1),rr(0,2),
               		   int(rr(0,0)/g2.gridSpacing(0)),int(rr(0,1)/g2.gridSpacing(1)),int(rr(0,2)/g2.gridSpacing(2)));


	  // kv=(k1,k2,k3) = closest point on grid2 (use dr/dx from near this point)
                                  
        	  k3=g2.dimension(Start,axis3);
        	  for( axis=0; axis<numberOfDimensions; axis++ )
        	  {
	    // dx[axis]=center(j1,j2,j3,axis)-center0(i1,i2,i3,axis);
          	    kv[axis]=int( R(jb,axis)/g2.gridSpacing(axis) + g2.indexRange(0,axis) );
          	    kpv[axis]=kv[axis]+1;
          	    if( kpv[axis] > g2.dimension(End,axis) )
          	    {
            	      kpv[axis]=kv[axis]-1;
            	      assert( kpv[axis] >= g2.dimension(Start,axis) );
          	    }
        	  }


#define XR(m,n) xra[n][m]
        	  int ax;
        	  if( numberOfDimensions==2 )
        	  {
	    // estimate (dx/dr) on grid 2 by differences (to avoid building xr)
          	    for(ax=0; ax<numberOfDimensions; ax++ ) 
          	    {
            	      xra[0][ax]=(kp1-k1)*(center2(kp1,k2,k3,ax)-center2(k1,k2,k3,ax))/g2.gridSpacing(0);
            	      xra[1][ax]=(kp2-k2)*(center2(k1,kp2,k3,ax)-center2(k1,k2,k3,ax))/g2.gridSpacing(1);
          	    }
          	    real det = XR(0,0)*XR(1,1)-XR(0,1)*XR(1,0);
          	    if( det!=0. )
          	    {
            	      det=1./det;
            	      dr[0]=(  XR(1,1)*dx[0]-XR(0,1)*dx[1] )*det;
            	      dr[1]=( -XR(1,0)*dx[0]+XR(0,0)*dx[1] )*det;
          	    }
          	    else
          	    { // if the jacobian is singular
            	      if( debug & 1 )
            	      {
            		printf("Ogmg:WARNING: non-invertible point and jacobian=0. for estimating location\n");
            	      }
            	      dr[0]=dr[1]=0.;
          	    }
          	    dr[2]=0.;
                        if( debug & 4 )
                	      printF("Ogmg:buildExtraLevels: non-invertible pt, dr from diff.: dx=(%e,%e) r=(%e,%e) dr=(%e,%e) \n",
                 		     dx[0],dx[1],r(0,0),r(0,1),dr[0],dr[1]);
        	  }
        	  else
        	  {
          	    for(ax=0; ax<numberOfDimensions; ax++ ) 
          	    {
            	      xra[0][ax]=(kp1-k1)*(center2(kp1,k2,k3,ax)-center2(k1,k2,k3,ax))/g2.gridSpacing(0);  // opt these *****
            	      xra[1][ax]=(kp2-k2)*(center2(k1,kp2,k3,ax)-center2(k1,k2,k3,ax))/g2.gridSpacing(1);
            	      xra[2][ax]=(kp3-k3)*(center2(k1,k2,kp3,ax)-center2(k1,k2,k3,ax))/g2.gridSpacing(2);
          	    }
          	    real det =((XR(0,0)*XR(1,1)-XR(0,1)*XR(1,0))*XR(2,2) +
                   		       (XR(0,1)*XR(1,2)-XR(0,2)*XR(1,1))*XR(2,0) +
                   		       (XR(0,2)*XR(1,0)-XR(0,0)*XR(1,2))*XR(2,1));
          	    if( det!=0. )
          	    {
            	      det=1./det;
            	      dr[0]=( (XR(1,1)*XR(2,2)-XR(2,1)*XR(1,2))*dx[0]+
                  		      (XR(2,1)*XR(0,2)-XR(0,1)*XR(2,2))*dx[1]+
                  		      (XR(0,1)*XR(1,2)-XR(1,1)*XR(0,2))*dx[2] )*det;
                  		      
            	      dr[1]=( (XR(1,2)*XR(2,0)-XR(2,2)*XR(1,0))*dx[0]+
                  		      (XR(2,2)*XR(0,0)-XR(0,2)*XR(2,0))*dx[1]+
                  		      (XR(0,2)*XR(1,0)-XR(1,2)*XR(0,0))*dx[2] )*det;
                  		      
            	      dr[2]=( (XR(1,0)*XR(2,1)-XR(2,0)*XR(1,1))*dx[0]+
                  		      (XR(2,0)*XR(0,1)-XR(0,0)*XR(2,1))*dx[1]+
                  		      (XR(0,0)*XR(1,1)-XR(1,0)*XR(0,1))*dx[2] )*det;

                            if( debug & 4 )
                            printF(" Ogmg:non-invertible pt: interp=(%i,%i,%i) j=(%i,%i,%i) R(jb=%i,.)=(%8.2e,%8.2e,%8.2e) \n"
                                          "       x=(%8.2e,%8.2e,%8.2e) kv=[%i,%i,%i] kpv=[%i,%i,%i]\n"
                                          "       dx=(%8.2e,%8.2e,%8.2e) dr=(%8.2e,%8.2e,%8.2e) gridSpacing=(%8.2e,%8.2e,%8.2e)\n"
                                          " xr(.,0)=(%8.2e,%8.2e,%8.2e) \n"
                                          " xr(.,1)=(%8.2e,%8.2e,%8.2e)\n"
                                          " xr(.,2)=(%8.2e,%8.2e,%8.2e) \n",
                 		     i1,i2,i3,j1,j2,j3,jb,R(jb,0),R(jb,1),R(jb,2),x(jb,0),x(jb,1),x(jb,2),
                                          k1,k2,k3,kp1,kp2,kp3,
                                          dx[0],dx[1],dx[2],dr[0],dr[1],dr[2],
                                          g2.gridSpacing(0),g2.gridSpacing(1),g2.gridSpacing(2),
                                          XR(0,0),XR(1,0),XR(2,0),XR(0,1),XR(1,1),XR(2,1),XR(0,2),XR(1,2),XR(2,2));  
            	      
                            for(ax=0; ax<numberOfDimensions; ax++ )
            	      {
                                dr[ax]=min(g2.gridSpacing(ax),max(-g2.gridSpacing(ax),dr[ax]));
            	      }
            	      
          	    }
          	    else
          	    { // if the jacobian is singular
            	      if( debug & 1 )
            		printf("Ogmg:WARNING: non-invertible point and jacobian=0. for estimating location\n"
                                              " grid=%i, grid2=%i : kv=[%i,%i,%i] kpv=[%i,%i,%i] \n"
                                              " center2(kv) = (%8.2e,%8.2e,%8.2e) center2(kpv)=(%8.2e,%8.2e,%8.2e) \n"
                                              " xra[.][0]=(%8.2e,%8.2e,%8.2e) \n"
                                              " xra[.][1]=(%8.2e,%8.2e,%8.2e)\n"
                                              " xra[.][2]=(%8.2e,%8.2e,%8.2e) \n",grid,grid2,
                                              k1,k2,k3,kp1,kp2,kp3,center2(k1,k2,k3,0),center2(k1,k2,k3,1),center2(k1,k2,k3,2),
                                              center2(kp1,k2,k3,0),center2(k1,kp2,k3,1),center2(k1,k2,kp3,2),
                                              XR(0,0),XR(1,0),XR(2,0),XR(0,1),XR(1,1),XR(2,1),XR(0,2),XR(1,2),XR(2,2));
            	      dr[0]=dr[1]=dr[2]=0.;
          	    }
        	  }
      	}
#undef XR
                		    
      	for( axis=0; axis<numberOfDimensions; axis++ )
      	{
        	  R(jb,axis)+=dr[axis];
      	}
            }  // end if point not invertible
        
            for( axis=0; axis<numberOfDimensions; axis++ )
            {
	// limit r to [0,1] unless the boundary is interpolation, then limit by .25*Delta r
	// from the last interpolation point.
      	RB(i,axis)=max(rMin[axis],min(rMax[axis],R(jb,axis)));
            }

        } // end for jb
    }  // end for grid2


    return 0;
}

int Ogmg::
getInterpolationCoordinatesNewOld( CompositeGrid & cg0, // finer grid
                        				CompositeGrid & cg1, // new coarser grid
                        				const IntegerArray & ib,     // check these points...
                                                                const RealArray & xa,        // with these x-coordinates 
                        				const int grid,            // ..on this grid
                        				const IntegerArray & gridsToCheck, // ..from these grids
                        				realSerialArray & rb,      // return these values
                        				const bool isRectangular,
                        				int iv0[3], real dx0[3], real xab0[2][3],   // these are used by Macros!
                        				int iv1[3], real dx1[3], real xab1[2][3],
                        				InterpolationData & ipd )
// ==================================================================================================
// /Description: ** Old "new" version that does many points at a time
//     Given a new interpolation point on a coarse grid, determine the r coordinates on the 
//   interpolee grid. 
//
// /ib (input) : ib(i,4) : (i,j1,j2,j3) 
// ==================================================================================================
{
    const bool checkForNans=false;  // for testing turn this on to check for nans

    CompositeGrid & mgcg = multigridCompositeGrid();
    const int numberOfDimensions=cg0.numberOfDimensions();
    const int numberOfComponentGrids = cg0.numberOfComponentGrids();

    #ifdef USE_PPP
        intSerialArray & interpoleeGrid0 = ipd.interpoleeGrid;
        intSerialArray & interpolationPoint0 = ipd.interpolationPoint;
        realSerialArray & interpolationCoordinates0 = ipd.interpolationCoordinates;
    #else
        const intArray & interpoleeGrid0 =cg0.interpoleeGrid[grid];  // ************ should use cg0 ****
        const intArray & interpolationPoint0 =cg0.interpolationPoint[grid];
        const realArray & interpolationCoordinates0 =cg0.interpolationCoordinates[grid];
    #endif    


  // const intArray & interpoleeGrid0 =cg0.interpoleeGrid[grid];  // ************ should use cg0 ****
  // const realArray & interpolationCoordinates0 =cg0.interpolationCoordinates[grid];
    const real *interpolationCoordinates0p = interpolationCoordinates0.Array_Descriptor.Array_View_Pointer1;
    const int interpolationCoordinates0Dim0=interpolationCoordinates0.getRawDataSize(0);

    const int * interpoleeGrid0p = interpoleeGrid0.Array_Descriptor.Array_View_Pointer0;

  // const intArray & interpolationPoint0 =cg0.interpolationPoint[grid];
    const int *interpolationPoint0p = interpolationPoint0.Array_Descriptor.Array_View_Pointer1;
    const int interpolationPoint0Dim0=interpolationPoint0.getRawDataSize(0);

    MappedGrid & mg0 = cg0[grid];
    MappedGrid & mg1 = cg1[grid];
    const IntegerArray & gid0 = mg0.gridIndexRange();
    const IntegerArray & gid1 = mg1.gridIndexRange();
    
    #ifdef USE_PPP
        realSerialArray center;  if( !isRectangular ) getLocalArrayWithGhostBoundaries(mg1.center(),center);
        realSerialArray center0; if( !isRectangular ) getLocalArrayWithGhostBoundaries(mg0.center(),center0);
    #else
        const realArray & center = mg1.center();
        const realArray & center0 = mg0.center();
    #endif


    const real *xap = xa.Array_Descriptor.Array_View_Pointer1;
    const int xaDim0=xa.getRawDataSize(0);
#define XA(i0,i1) xap[i0+xaDim0*(i1)]


    real *center0p;  
    int center0Dim0,center0Dim1,center0Dim2;
    real *centerp;
    int centerDim0,centerDim1,centerDim2;
    if( !isRectangular )
    {
        centerp = center.Array_Descriptor.Array_View_Pointer3;
        centerDim0=center.getRawDataSize(0);
        centerDim1=center.getRawDataSize(1);
        centerDim2=center.getRawDataSize(2);

        center0p = center0.Array_Descriptor.Array_View_Pointer3;
        center0Dim0=center0.getRawDataSize(0);
        center0Dim1=center0.getRawDataSize(1);
        center0Dim2=center0.getRawDataSize(2);

    }
#define CENTER0(i0,i1,i2,i3) center0p[i0+center0Dim0*(i1+center0Dim1*(i2+center0Dim2*(i3)))]	
            
    const int maxNumToInterp = ib.getLength(0);
  // if( maxNumToInterp==0 ) return 0;                 // ***************** fix me ***************

    realSerialArray x, r;
    IntegerArray ia;
    if( maxNumToInterp>0 )
        x.redim(maxNumToInterp,3); r.redim(maxNumToInterp,3); ia.redim(maxNumToInterp);
    
    real *xp = x.Array_Descriptor.Array_View_Pointer1;
    const int xDim0=x.getRawDataSize(0);
    real *rp = r.Array_Descriptor.Array_View_Pointer1;
    const int rDim0=r.getRawDataSize(0);

    int *iap = ia.Array_Descriptor.Array_View_Pointer0;
#undef IA
#define IA(i0) iap[i0]

    real *rbp = rb.Array_Descriptor.Array_View_Pointer1;
    const int rbDim0=rb.getRawDataSize(0);
#define RB(i0,i1) rbp[i0+rbDim0*(i1)]

    int *ibp = ib.Array_Descriptor.Array_View_Pointer1;
    const int ibDim0=ib.getRawDataSize(0);

    int level0=0;
    const IntegerArray & coarseningRatio = mgcg.multigridCoarseningRatio(Range(0,2),grid,level0);
    int cf[3], &cf1=cf[0], &cf2=cf[1], &cf3=cf[2];
    cf1=coarseningRatio(axis1);  // coarsening factor
    cf2=coarseningRatio(axis2);
    cf3=coarseningRatio(axis3);  
    assert(cf1==2 && (cf2==2 || numberOfDimensions<2) && (cf3==2 || numberOfDimensions<3));

    const real epsDet=REAL_MIN*1.e5;  // *wdh* 1106012 -- lower bound for det(jacobian)

    int i0,ii,axis;
    int jv[3], &j1=jv[0], &j2=jv[1], &j3=jv[2];      
    int kv[3], &k1=kv[0], &k2=kv[1], &k3=kv[2];      
    int kpv[3], &kp1=kpv[0], &kp2=kpv[1], &kp3=kpv[2];      
    
    if( false ) // *wdh* 110613
    {
        fprintf(pDebugFile,"=== Ogmg:getInterpCoordsNew START===\n");
        for( int i=0; i<maxNumToInterp; i++ )
        {
            ii=IB(i,4); 
            int donor = IB(i,5);
            fprintf(pDebugFile,"i=%i ii=%i donor=%i gridsToCheck(donor)=%i x=(%e,%e)\n",i,ii,donor,gridsToCheck(donor),
            	      XA(ii,0),XA(ii,1));
        }
    }


    for( int grid2=0; grid2<cg1.numberOfComponentGrids(); grid2++ )
    {
        #ifndef USE_PPP
            if( gridsToCheck(grid2)==0 ) continue;  // no need to check this grid -- in parallel we need to keep going
        #endif

    // collect up all new interpolation points that interpolate from grid2
        int jb=0;
        if( gridsToCheck(grid2)!=0 )
        {
            if( numberOfDimensions==2 )
            {
      	for( int i=0; i<maxNumToInterp; i++ )
      	{
        	  ii=IB(i,4);  // index into cid and XA arrays
        	  int donor = IB(i,5);
        	  assert( donor>=0 && donor<numberOfComponentGrids );
        	  if( donor==grid2 )
        	  {
          	    j1=IB(i,1); j2=IB(i,2); j3=IB(i,3); 

          	    IA(jb)=i;  // save i
          	    X(jb,0)=XA(ii,0);
          	    X(jb,1)=XA(ii,1);

          	    i0=IB(i,0);  // index into original interpolation point arrays
          	    if( i0>=0 )
          	    {
            	      R(jb,0)=ci0(i0,0); // initial guess
            	      R(jb,1)=ci0(i0,1);
            	      R(jb,2)=0.;
          	    }
          	    else
          	    {
            	      R(jb,0)=-1.;
            	      R(jb,1)=-1.;
            	      R(jb,2)=-1.;
          	    }
          	    jb++;
        	  }
            
      	}
            }
            else
            {
      	for( int i=0; i<maxNumToInterp; i++ )
      	{
        	  ii=IB(i,4);  
        	  int donor = IB(i,5);
        	  assert( donor>=0 && donor<numberOfComponentGrids );
        	  if( donor==grid2 )
        	  {
          	    j1=IB(i,1); j2=IB(i,2); j3=IB(i,3); 

          	    IA(jb)=i;
          	    X(jb,0)=XA(ii,0);
          	    X(jb,1)=XA(ii,1);
          	    X(jb,2)=XA(ii,2);
          	    i0=IB(i,0);  // index into orginal interpolation point arrays
          	    if( i0>=0 )
          	    {
            	      R(jb,0)=ci0(i0,0);
            	      R(jb,1)=ci0(i0,1);
            	      R(jb,2)=ci0(i0,2);
          	    }
          	    else
          	    {
            	      R(jb,0)=-1.;
            	      R(jb,1)=-1.;
            	      R(jb,2)=-1.;
          	    }
          	    jb++;
        	  }
      	}
            }
        }
        
        const int numToInterp=jb;
    // if( numToInterp==0 ) continue;  // **** no points to interpolate   -------------- fix me parallel ----------
        
    // printF(" grid=%i : interpolate %i extra points from grid2=%i\n",grid,numToInterp,grid2);

        MappedGrid & g2 = cg1[grid2];
        const IntegerArray & extended = g2.extendedIndexRange(); 
        const realArray & center2 = g2.center();

        const bool g2IsRectangular=g2.isRectangular();
        real dx2[3], xra[3][3];
        if( g2IsRectangular )
        {
            g2.getDeltaX(dx2);
        }
        const real offset = parameters.allowExtrapolationOfInterpolationPoints ? 1. : 0.; // *wdh* 040903
        real rMin[3], rMax[3];
        for( axis=0; axis<numberOfDimensions; axis++ )
        {
      // normally limit r to [0,1] unless the boundary is interpolation, then limit by .25*Delta r
      // from the last interpolation point.
            const real dr = g2.gridSpacing(axis);
            rMin[axis] = g2.boundaryCondition(Start,axis)!=0  ? -dr*offset :
                                                        	                                                  (extended(Start,axis)+.25)*dr; // move in .25*Dr from the end
            rMax[axis] = g2.boundaryCondition(End  ,axis)!=0  ? 1.+dr*offset :(extended(End,  axis)-.25)*dr;
        }
            
        Range R=numToInterp, Rx=numberOfDimensions;
        
    // invert mapping to get coordinates of the new interpolation pt.
        Mapping & map2 = g2.mapping().getMapping();
        map2.useRobustInverse(true);
        if( numToInterp>0 )
        {
            r=-1.;
            #ifdef USE_PPP
                map2.inverseMapS(x(R,Rx),r);  // ** here is the expensive part **
            #else
                map2.inverseMap(x(R,Rx),r);  // ** here is the expensive part **
            #endif
        }
        else
        {
      // There are no points on this processor to interpolate
            RealArray xNull,rNull;
            #ifdef USE_PPP
                map2.inverseMapS(xNull,rNull);  // ** here is the expensive part **
            #else
                map2.inverseMap(xNull,rNull);  // ** here is the expensive part **
            #endif
        }
        
        real dx[3], dr[3]={0.,0.,0.};
        real dr2[3]={g2.gridSpacing(0),g2.gridSpacing(1),g2.gridSpacing(2)}; //
        realSerialArray xx(1,3), rr(1,3), xxr(1,3,3);
        for( jb=0; jb<numToInterp; jb++ )
        {
            const int i=IA(jb);  // index into the original ib array

            if( checkForNans )  // *wdh* 2011/06/12 -- for testing check for nan's
            {
      	if( R(jb,0)!=R(jb,0) || R(jb,1)!=R(jb,1) || R(jb,2)!=R(jb,2) )
      	{
        	  if( true )
        	  {
          	    printf("Ogmg:getInterpCoordsNew: ERROR: r=(%e,%e,%e) nan's ?? map=%s\n",R(jb,0),R(jb,1),R(jb,2),
               		   (const char*)map2.getName(Mapping::mappingName));
        	  }
        	  
        	  R(jb,0)=R(jb,1)=R(jb,2)=Mapping::bogus;
      	}
            }

            if( max(fabs(R(jb,0)),fabs(R(jb,1)),fabs(R(jb,2))) > 5. )
            {
	// pt was not invertible -- estimate it's inverse location

                int i0=IB(i,0); // note i
      	if( i0<0 )
      	{
                    if( debug & 4 )
          	    fprintf(pDebugFile,"Ogmg:getInterpCoordsNew: Unable to invert pt (%i,%i,%i) grid=%i from donor=%i \n",IB(i,1),IB(i,2),IB(i,3),grid,grid2); 

          // find the closest fine grid interp point that also uses this donor
                    int j1=IB(i,1), j2=IB(i,2), j3=IB(i,3); // coarse grid point
        	  int i1=(j1-gid1(0,0))*cf[0]+gid0(0,0), i2=(j2-gid1(0,1))*cf[1]+gid0(0,1), i3=(j3-gid1(0,2))*cf[2]+gid0(0,2);  // fine grid pt
                    int minDist=INT_MAX;
        	  for( int k=interpolationPoint0.getBase(0); k<=interpolationPoint0.getBound(0); k++ )
        	  {
                        int donor=ig0(k);
          	    if( donor==grid2 )
          	    {
                            int dist = abs(i1-ip0(k,0))+abs(i2-ip0(k,1));
            	      if( numberOfDimensions==3 ) dist+= abs(i3-ip0(k,2));
            	      if( dist<minDist )
            	      {
            		i0=k;
            		minDist=dist;
            	      }
          	    }
          	    
        	  }
        	  

        	  if( i0<0 )
        	  {
          	    if( debug & 4 )
          	    {
            	      fprintf(pDebugFile,"Ogmg:getInterpCoordsNew: i=%i Unable to invert pt (%i,%i,%i) grid=%i from donor=%i"
                  		      " R=(%e,%e,%e) \n",i,IB(i,1),IB(i,2),IB(i,3),grid,grid2,R(jb,0),R(jb,1),R(jb,2)); 
            	      fprintf(pDebugFile,"Ogmg:getInterpCoordsNew: i=%i Unable to find a fine grid interp pt with donor=%i\n",i,grid2);
          	    }
          	    
	    // OV_ABORT("finish me for this case: IB(i,0)<0");


            // fill in bogus values -- this will force another donor grid to be found.
            // *** we could do better here ***
          	    for( axis=0; axis<numberOfDimensions; axis++ )
          	    {
            	      RB(i,axis)=Mapping::bogus;
          	    }
          	    continue;
          	    
        	  }
                    else
        	  {
                        if( debug & 2 )
            	      fprintf(pDebugFile," ... use fine grid interp. point i0=%i, (%i,%i,%i)\n",i0,
                  		      ip0(i0,0),ip0(i0,1),(numberOfDimensions==2 ? 0 : ip0(i0,2)));
            	      
        	  }
        	  
        	  
      	}
      	
      	assert( i0>=0 );
      	
        // As a first approximation the r coords are the same as the nearby fine grid interp pt,
        // we then improve this below: 
          	for( axis=0; axis<numberOfDimensions; axis++ )   // *wdh* 021203
            	  R(jb,axis)=ci0(i0,axis);	


	// dx = distance from nearby interpolation pt to the new interpolation point.
	// add dr = (dr/dx)_2 * dx 
                int i1=ip0(i0,0), i2=ip0(i0,1);
                int i3=numberOfDimensions==2 ? 0 : ip0(i0,2);
                int j1=IB(i,1), j2=IB(i,2), j3=IB(i,3);
      	if( isRectangular )
      	{
        	  dx[0]=CENTER10(j1,j2,j3)-CENTER00(i1,i2,i3);
        	  dx[1]=CENTER11(j1,j2,j3)-CENTER01(i1,i2,i3);
        	  dx[2]=CENTER12(j1,j2,j3)-CENTER02(i1,i2,i3);

      	}
      	else
      	{
        	  for( axis=0; axis<numberOfDimensions; axis++ )
        	  {
	    // dx[axis]=CENTER(j1,j2,j3,axis)-CENTER0(i1,i2,i3,axis);
          	    dx[axis]=X(jb,axis)-CENTER0(i1,i2,i3,axis);  
        	  }
        	  
      	}
      	if( g2IsRectangular )
      	{
        	  dr[0]=dx[0]/dx2[0]*dr2[0];
        	  dr[1]=dx[1]/dx2[1]*dr2[1];
        	  dr[2]=dx[2]/dx2[2]*dr2[2];
      	}    
      	else
      	{

          // Evaluate x.r at the nearby interp coord's
        	  Mapping & map2 = g2.mapping().getMapping();
                    for( axis=0; axis<numberOfDimensions; axis++ )
          	    rr(0,axis)=R(jb,axis);

          // *FIX* me: this next could hang in parallel if the forward map is distributed (e.g. DPM)
        	  map2.mapS(rr,xx,xxr);
        	  
// 	  rr=-1.;
// 	  xx(0,Rx)=x(jb,Rx);
//           #ifdef USE_PPP
// 	    OV_ABORT("Ogmg::getInterpolationCoordinates:ERROR: finish this");
//   	  #else
//   	    map2.approximateGlobalInverse->findNearestGridPoint(0,0,xx,rr);
//           #endif

//           if( debug & 4 )
// 	    printF(" Ogmg:non-invertible pt: map2.usingRobustInverse()=%i, nearest: rr=(%8.2e,%8.2e,%8.2e)"
// 		   " -> i=(%i,%i,%i)\n",
// 		   (int)map2.usingRobustInverse(),rr(0,0),rr(0,1),rr(0,2),
// 		   int(rr(0,0)/g2.gridSpacing(0)),int(rr(0,1)/g2.gridSpacing(1)),int(rr(0,2)/g2.gridSpacing(2)));


#define XR(m,n) xxr(0,m,n)
        	  if( numberOfDimensions==2 )
        	  {
          	    real det = XR(0,0)*XR(1,1)-XR(0,1)*XR(1,0);
          	    if( fabs(det)>epsDet )
          	    {
            	      det=1./det;
            	      dr[0]=(  XR(1,1)*dx[0]-XR(0,1)*dx[1] )*det;
            	      dr[1]=( -XR(1,0)*dx[0]+XR(0,0)*dx[1] )*det;
          	    }
          	    else
          	    { // if the jacobian is singular
            	      if( debug & 1 )
            	      {
            		printf("Ogmg:WARNING: non-invertible point and jacobian=0. for estimating location\n");
            	      }
            	      dr[0]=dr[1]=0.;
          	    }
          	    dr[2]=0.;
                        if( debug & 4 )
                	      fprintf(pDebugFile,"Ogmg:buildExtraLevels: non-invertible pt, dr computed from r.x*dx: (fine interp i0=%i)\n"
                                            "  grid=%i donor=%i fine=(i1,i2,i3)=(%i,%i,%i) coarse=(%i,%i,%i), dx=(%8.2e,%8.2e) r=(%8.2e,%8.2e)"
                                            " dr=(%8.2e,%8.2e) \n",
                  		      i0,grid,grid2, i1,i2,i3,j1,j2,j3,
                 		     dx[0],dx[1],rr(0,0),rr(0,1),dr[0],dr[1]);
        	  }
        	  else
        	  {
          	    real det =((XR(0,0)*XR(1,1)-XR(0,1)*XR(1,0))*XR(2,2) +
                   		       (XR(0,1)*XR(1,2)-XR(0,2)*XR(1,1))*XR(2,0) +
                   		       (XR(0,2)*XR(1,0)-XR(0,0)*XR(1,2))*XR(2,1));
          	    if( det>epsDet )
          	    {
            	      det=1./det;
            	      dr[0]=( (XR(1,1)*XR(2,2)-XR(2,1)*XR(1,2))*dx[0]+
                  		      (XR(2,1)*XR(0,2)-XR(0,1)*XR(2,2))*dx[1]+
                  		      (XR(0,1)*XR(1,2)-XR(1,1)*XR(0,2))*dx[2] )*det;
                  		      
            	      dr[1]=( (XR(1,2)*XR(2,0)-XR(2,2)*XR(1,0))*dx[0]+
                  		      (XR(2,2)*XR(0,0)-XR(0,2)*XR(2,0))*dx[1]+
                  		      (XR(0,2)*XR(1,0)-XR(1,2)*XR(0,0))*dx[2] )*det;
                  		      
            	      dr[2]=( (XR(1,0)*XR(2,1)-XR(2,0)*XR(1,1))*dx[0]+
                  		      (XR(2,0)*XR(0,1)-XR(0,0)*XR(2,1))*dx[1]+
                  		      (XR(0,0)*XR(1,1)-XR(1,0)*XR(0,1))*dx[2] )*det;

                            if( debug & 4 )
            		fprintf(pDebugFile," Ogmg:non-invertible pt: interp=(%i,%i,%i) j=(%i,%i,%i) R(jb=%i,.)=(%8.2e,%8.2e,%8.2e) \n"
                   		       "       x=(%8.2e,%8.2e,%8.2e) \n"
                   		       "       dx=(%8.2e,%8.2e,%8.2e) dr=(%8.2e,%8.2e,%8.2e) gridSpacing=(%8.2e,%8.2e,%8.2e)\n"
                   		       " xr(.,0)=(%8.2e,%8.2e,%8.2e) \n"
                   		       " xr(.,1)=(%8.2e,%8.2e,%8.2e) \n"
                   		       " xr(.,2)=(%8.2e,%8.2e,%8.2e) \n",
                   		       i1,i2,i3,j1,j2,j3,jb,R(jb,0),R(jb,1),R(jb,2),x(jb,0),x(jb,1),x(jb,2),
                   		       dx[0],dx[1],dx[2],dr[0],dr[1],dr[2],
                   		       g2.gridSpacing(0),g2.gridSpacing(1),g2.gridSpacing(2),
                   		       XR(0,0),XR(1,0),XR(2,0),XR(0,1),XR(1,1),XR(2,1),XR(0,2),XR(1,2),XR(2,2));  
            	      
                            for( int ax=0; ax<numberOfDimensions; ax++ )
            	      {
                                dr[ax]=min(g2.gridSpacing(ax),max(-g2.gridSpacing(ax),dr[ax]));
            	      }
            	      
          	    }
          	    else
          	    { // if the jacobian is singular
            	      if( debug & 1 )
            		fprintf(pDebugFile,"Ogmg:WARNING: non-invertible point and jacobian=0. for estimating location\n"
                                              " grid=%i, grid2=%i :  \n"
                                              " xr[.][0]=(%8.2e,%8.2e,%8.2e) \n"
                                              " xr[.][1]=(%8.2e,%8.2e,%8.2e) \n"
                                              " xr[.][2]=(%8.2e,%8.2e,%8.2e) \n",grid,grid2,
                                              XR(0,0),XR(1,0),XR(2,0),XR(0,1),XR(1,1),XR(2,1),XR(0,2),XR(1,2),XR(2,2));
            	      dr[0]=dr[1]=dr[2]=0.;
          	    }
        	  }
      	}
      	
#undef XR
                		    
      	for( axis=0; axis<numberOfDimensions; axis++ )
      	{
        	  R(jb,axis)+=dr[axis];
      	}

      	if( checkForNans )  // *wdh* 2011/06/12 -- check for nan's
      	{
        	  if( R(jb,0)!=R(jb,0) || R(jb,1)!=R(jb,1) || R(jb,2)!=R(jb,2) )
        	  {
          	    printf("Ogmg:getInterpCoordsNew:ERROR(2): dr=(%e,%e,%e) r=(%e,%e,%e) nan's ?? map=%s\n",dr[0],dr[1],dr[2], R(jb,0),R(jb,1),R(jb,2),
               		   (const char*)map2.getName(Mapping::mappingName));
                        fflush(0);
        	  }
      	}
      	
            }  // end if point not invertible
        
            for( axis=0; axis<numberOfDimensions; axis++ )
            {
	// limit r to [0,1] unless the boundary is interpolation, then limit by .25*Delta r
	// from the last interpolation point.
      	RB(i,axis)=max(rMin[axis],min(rMax[axis],R(jb,axis)));
            }
            if( checkForNans )  // *wdh* 2011/06/12 -- check for nan's
            {
      	if( numberOfDimensions==2 )
      	{
        	  if( RB(i,0)!=RB(i,0) || RB(i,1)!=RB(i,1) )
        	  {
          	    printf("Ogmg:getInterpCoordsNew:ERROR(3): r=(%e,%e) nan's ?? map=%s\n",RB(i,0),RB(i,1),
               		   (const char*)map2.getName(Mapping::mappingName));
        	  }
      	}
      	else 
      	{
        	  if( RB(i,0)!=RB(i,0) || RB(i,1)!=RB(i,1) || RB(i,2)!=RB(i,2) )
        	  {
          	    printf("Ogmg:getInterpCoordsNew:ERROR(3): r=(%e,%e,%e) nan's ?? map=%s\n",RB(i,0),RB(i,1),RB(i,2),
               		   (const char*)map2.getName(Mapping::mappingName));
        	  }
      	}
      	
            }

        } // end for jb
    }  // end for grid2

  // *wdh* 2011/06/12 -- check for nan's
    if( checkForNans )  
    {
        for( int i=0; i<maxNumToInterp; i++ )
        {
            if( numberOfDimensions==2 )
            {
        // fprintf(pDebugFile,"Ogmg:getInterpCoordsNew: i=%i RB=(%e,%e)\n",i,RB(i,0),RB(i,1));

      	if( RB(i,0)!=RB(i,0) || RB(i,1)!=RB(i,1) )
      	{
        	  printf("Ogmg:getInterpCoordsNew:ERROR(4): myid=%i i=%i r=(%e,%e) nan's ?? \n",myid,i,RB(i,0),RB(i,1));
      	}
            }
            else 
            {
      	if( RB(i,0)!=RB(i,0) || RB(i,1)!=RB(i,1) || RB(i,2)!=RB(i,2) )
      	{
        	  printf("Ogmg:getInterpCoordsNew:ERROR(4): i=%i r=(%e,%e,%e) nan's ?? \n",i,RB(i,0),RB(i,1),RB(i,2));
      	}
            }
      	
        }
        fflush(0);
        fflush(pDebugFile);
        
    }
    
    return 0;
}


int Ogmg::
getInterpolationCoordinatesNew( CompositeGrid & cg0, // finer grid
                        				CompositeGrid & cg1, // new coarser grid
                        				const IntegerArray & ib,     // check these points...
                                                                const RealArray & xa,        // with these x-coordinates 
                        				const int grid,            // ..on this grid
                        				const IntegerArray & gridsToCheck, // ..from these grids
                        				realSerialArray & rb,      // return these values
                        				const bool isRectangular,
                        				int iv0[3], real dx0[3], real xab0[2][3],   // these are used by Macros!
                        				int iv1[3], real dx1[3], real xab1[2][3],
                        				InterpolationData & ipd,
                                                                IntegerArray & ia0,           // list of all interp points
                                                                realSerialArray & donorDist   // distance to donor
                                                              )
// ==================================================================================================
// /Description: ** new version that does many points at a time
//     Given a new interpolation point on a coarse grid, determine the r coordinates on the 
//   interpolee grid. 
//
// /ib (input) : ib(i,4) : (i,j1,j2,j3) 
// ==================================================================================================
{
    const bool checkForNans=false;  // for testing turn this on to check for nans

    CompositeGrid & mgcg = multigridCompositeGrid();
    const int numberOfDimensions=cg0.numberOfDimensions();
    const int numberOfComponentGrids = cg0.numberOfComponentGrids();

    #ifdef USE_PPP
        intSerialArray & interpoleeGrid0 = ipd.interpoleeGrid;
        intSerialArray & interpolationPoint0 = ipd.interpolationPoint;
        realSerialArray & interpolationCoordinates0 = ipd.interpolationCoordinates;
    #else
        const intArray & interpoleeGrid0 =cg0.interpoleeGrid[grid];  // ************ should use cg0 ****
        const intArray & interpolationPoint0 =cg0.interpolationPoint[grid];
        const realArray & interpolationCoordinates0 =cg0.interpolationCoordinates[grid];
    #endif    


  // const intArray & interpoleeGrid0 =cg0.interpoleeGrid[grid];  // ************ should use cg0 ****
  // const realArray & interpolationCoordinates0 =cg0.interpolationCoordinates[grid];
    const real *interpolationCoordinates0p = interpolationCoordinates0.Array_Descriptor.Array_View_Pointer1;
    const int interpolationCoordinates0Dim0=interpolationCoordinates0.getRawDataSize(0);

    const int * interpoleeGrid0p = interpoleeGrid0.Array_Descriptor.Array_View_Pointer0;

  // const intArray & interpolationPoint0 =cg0.interpolationPoint[grid];
    const int *interpolationPoint0p = interpolationPoint0.Array_Descriptor.Array_View_Pointer1;
    const int interpolationPoint0Dim0=interpolationPoint0.getRawDataSize(0);

    MappedGrid & mg0 = cg0[grid];
    MappedGrid & mg1 = cg1[grid];
    const IntegerArray & gid0 = mg0.gridIndexRange();
    const IntegerArray & gid1 = mg1.gridIndexRange();
    
    #ifdef USE_PPP
        realSerialArray center;  if( !isRectangular ) getLocalArrayWithGhostBoundaries(mg1.center(),center);
        realSerialArray center0; if( !isRectangular ) getLocalArrayWithGhostBoundaries(mg0.center(),center0);
    #else
        const realArray & center = mg1.center();
        const realArray & center0 = mg0.center();
    #endif


    const real *xap = xa.Array_Descriptor.Array_View_Pointer1;
    const int xaDim0=xa.getRawDataSize(0);
#define XA(i0,i1) xap[i0+xaDim0*(i1)]


    real *center0p;  
    int center0Dim0,center0Dim1,center0Dim2;
    real *centerp;
    int centerDim0,centerDim1,centerDim2;
    if( !isRectangular )
    {
        centerp = center.Array_Descriptor.Array_View_Pointer3;
        centerDim0=center.getRawDataSize(0);
        centerDim1=center.getRawDataSize(1);
        centerDim2=center.getRawDataSize(2);

        center0p = center0.Array_Descriptor.Array_View_Pointer3;
        center0Dim0=center0.getRawDataSize(0);
        center0Dim1=center0.getRawDataSize(1);
        center0Dim2=center0.getRawDataSize(2);

    }
#define CENTER0(i0,i1,i2,i3) center0p[i0+center0Dim0*(i1+center0Dim1*(i2+center0Dim2*(i3)))]	
            
    const int maxNumToInterp = ib.getLength(0);
  // if( maxNumToInterp==0 ) return 0;                 // ***************** fix me ***************

    realSerialArray x, r;
    IntegerArray ia;
    if( maxNumToInterp>0 )
        x.redim(maxNumToInterp,3); r.redim(maxNumToInterp,3); ia.redim(maxNumToInterp);
    
    real *xp = x.Array_Descriptor.Array_View_Pointer1;
    const int xDim0=x.getRawDataSize(0);
    real *rp = r.Array_Descriptor.Array_View_Pointer1;
    const int rDim0=r.getRawDataSize(0);

    int *ia0p = ia0.Array_Descriptor.Array_View_Pointer1;
    const int ia0Dim0=ia0.getRawDataSize(0);
#define IA0(i0,i1) ia0p[i0+ia0Dim0*(i1)]


    int *iap = ia.Array_Descriptor.Array_View_Pointer0;
#undef IA
#define IA(i0) iap[i0]

    real *rbp = rb.Array_Descriptor.Array_View_Pointer1;
    const int rbDim0=rb.getRawDataSize(0);
#define RB(i0,i1) rbp[i0+rbDim0*(i1)]

    int *ibp = ib.Array_Descriptor.Array_View_Pointer1;
    const int ibDim0=ib.getRawDataSize(0);

    int level0=0;
    const IntegerArray & coarseningRatio = mgcg.multigridCoarseningRatio(Range(0,2),grid,level0);
    int cf[3], &cf1=cf[0], &cf2=cf[1], &cf3=cf[2];
    cf1=coarseningRatio(axis1);  // coarsening factor
    cf2=coarseningRatio(axis2);
    cf3=coarseningRatio(axis3);  
    assert(cf1==2 && (cf2==2 || numberOfDimensions<2) && (cf3==2 || numberOfDimensions<3));

    const real epsDet=REAL_MIN*1.e5;  // *wdh* 1106012 -- lower bound for det(jacobian)

    int i0,ii,axis;
    int jv[3], &j1=jv[0], &j2=jv[1], &j3=jv[2];      
    int kv[3], &k1=kv[0], &k2=kv[1], &k3=kv[2];      
    int kpv[3], &kp1=kpv[0], &kp2=kpv[1], &kp3=kpv[2];      
    
    if( debug & 4 ) // *wdh* 110613
    {
        fprintf(pDebugFile,"  === getInterpolationCoordinatesNew START ===\n");
        for( int i=0; i<maxNumToInterp; i++ )
        {
            ii=IB(i,4); 
            int donor = IB(i,5);
            fprintf(pDebugFile,"  i=%i ii=%i (%i,%i,%i) donor=%i gridsToCheck(donor)=%i x=(%e,%e)\n",
                            i,ii,IB(i,1),IB(i,2),IB(i,3),donor,gridsToCheck(donor),
            	      XA(ii,0),XA(ii,1));
        }
    }


  // --------------------------------------------------------
  // ------------ Loop over possible donor grids ------------
  // --------------------------------------------------------
    for( int grid2=0; grid2<cg1.numberOfComponentGrids(); grid2++ )
    {
        #ifndef USE_PPP
            if( gridsToCheck(grid2)==0 ) continue;  // no need to check this grid -- in parallel we need to keep going
        #endif

    // collect up all new interpolation points that interpolate from grid2
        int jb=0;
        if( gridsToCheck(grid2)!=0 )
        {
            if( numberOfDimensions==2 )
            {
      	for( int i=0; i<maxNumToInterp; i++ )
      	{
        	  ii=IB(i,4);  // index into cid and XA arrays
        	  int donor = IB(i,5);
        	  assert( donor>=0 && donor<numberOfComponentGrids );
        	  if( donor==grid2 )
        	  {
          	    j1=IB(i,1); j2=IB(i,2); j3=IB(i,3); 

          	    IA(jb)=i;  // save i
          	    X(jb,0)=XA(ii,0);
          	    X(jb,1)=XA(ii,1);

          	    i0=IB(i,0);  // index into original interpolation point arrays
          	    if( i0>=0 )
          	    {
            	      R(jb,0)=ci0(i0,0); // initial guess
            	      R(jb,1)=ci0(i0,1);
            	      R(jb,2)=0.;
          	    }
          	    else
          	    {
            	      R(jb,0)=-1.;
            	      R(jb,1)=-1.;
            	      R(jb,2)=-1.;
          	    }
          	    jb++;
        	  }
            
      	}
            }
            else
            {
      	for( int i=0; i<maxNumToInterp; i++ )
      	{
        	  ii=IB(i,4);  
        	  int donor = IB(i,5);
        	  assert( donor>=0 && donor<numberOfComponentGrids );
        	  if( donor==grid2 )
        	  {
          	    j1=IB(i,1); j2=IB(i,2); j3=IB(i,3); 

          	    IA(jb)=i;
          	    X(jb,0)=XA(ii,0);
          	    X(jb,1)=XA(ii,1);
          	    X(jb,2)=XA(ii,2);
          	    i0=IB(i,0);  // index into original fine grid interpolation point arrays
          	    if( i0>=0 )
          	    {
            	      R(jb,0)=ci0(i0,0);
            	      R(jb,1)=ci0(i0,1);
            	      R(jb,2)=ci0(i0,2);
          	    }
          	    else
          	    {
            	      R(jb,0)=-1.;
            	      R(jb,1)=-1.;
            	      R(jb,2)=-1.;
          	    }
          	    jb++;
        	  }
      	}
            }
        }
        
        const int numToInterp=jb;
    // if( numToInterp==0 ) continue;  // **** no points to interpolate   -------------- fix me parallel ----------
        
    // printF(" grid=%i : interpolate %i extra points from grid2=%i\n",grid,numToInterp,grid2);

        MappedGrid & g2 = cg1[grid2];
        const IntegerArray & extended = g2.extendedIndexRange(); 
        const realArray & center2 = g2.center();

        const bool g2IsRectangular=g2.isRectangular();
        real dx2[3], xra[3][3];
        if( g2IsRectangular )
        {
            g2.getDeltaX(dx2);
        }
        const real offset = parameters.allowExtrapolationOfInterpolationPoints ? 1. : 0.; // *wdh* 040903
        real rMin[3], rMax[3];
        for( axis=0; axis<numberOfDimensions; axis++ )
        {
      // normally limit r to [0,1] unless the boundary is interpolation, then limit by .25*Delta r
      // from the last interpolation point.
            const real dr = g2.gridSpacing(axis);
            rMin[axis] = g2.boundaryCondition(Start,axis)!=0  ? -dr*offset :
                                                        	                                                  (extended(Start,axis)+.25)*dr; // move in .25*Dr from the end
            rMax[axis] = g2.boundaryCondition(End  ,axis)!=0  ? 1.+dr*offset :(extended(End,  axis)-.25)*dr;
        }
            
        Range Rni=numToInterp, Rx=numberOfDimensions;
        
    // invert mapping to get coordinates of the new interpolation pt.
        Mapping & map2 = g2.mapping().getMapping();
        map2.useRobustInverse(true);
        if( numToInterp>0 )
        {
            r=-1.;
            #ifdef USE_PPP
                map2.inverseMapS(x(Rni,Rx),r);  // ** here is the expensive part **
            #else
                map2.inverseMap(x(Rni,Rx),r);   // ** here is the expensive part **
            #endif
        }
        else
        {
      // There are no points on this processor to interpolate
            RealArray xNull,rNull;
            #ifdef USE_PPP
                map2.inverseMapS(xNull,rNull);  // ** here is the expensive part **
            #else
                map2.inverseMap(xNull,rNull);   // ** here is the expensive part **
            #endif
        }
        
        real dx[3], dr[3]={0.,0.,0.};
        real dr2[3]={g2.gridSpacing(0),g2.gridSpacing(1),g2.gridSpacing(2)}; //

    // numToFix : keep track of non-invertible points that need to call the map2 function
        int numToFix=0;  
        intSerialArray ja;

        for( jb=0; jb<numToInterp; jb++ )
        {
            const int i=IA(jb);  // index into the original ib array

            if( checkForNans )  // *wdh* 2011/06/12 -- for testing check for nan's
            {
      	if( R(jb,0)!=R(jb,0) || R(jb,1)!=R(jb,1) || R(jb,2)!=R(jb,2) )
      	{
        	  if( true )
        	  {
          	    printf("  getInterpCoordsNew: ERROR: r=(%e,%e,%e) nan's ?? map=%s\n",R(jb,0),R(jb,1),R(jb,2),
               		   (const char*)map2.getName(Mapping::mappingName));
        	  }
        	  
        	  R(jb,0)=R(jb,1)=R(jb,2)=Mapping::bogus;
      	}
            }

            const int ii = IB(i,4);  // index into IA0 array -- full list of coarse grid interp points 
            IA0(ii,4)=canInterpolateQuality1; // by default the interp. coord. quality is assumed to be good.

            if( max(fabs(R(jb,0)),fabs(R(jb,1)),fabs(R(jb,2))) > 5. )
            {
	// === pt was not invertible - estimate it's inverse location ===

                IA0(ii,4)=canInterpolateQualityBad; // bad quality for these "r" coordinates

	// To estimate the donor "r" coordinates we start from the corrdinates of a nearby
	// fine grid interpolation point and then add on a correction:
	//       r(coarse) = r(fine) + (dr/dx)*dx

        // printf("Ogmg::buildExtraLevelsNew:: myid=%i: Unable to invert pt (%i,%i,%i) grid=%i from donor=%i \n",
	//       myid,IB(i,1),IB(i,2),IB(i,3),grid,grid2); 

      	if( debug & 4 )
        	  fprintf(pDebugFile,"  getInterpCoordsNew: Unable to invert pt (%i,%i,%i) grid=%i from donor=%i,"
              		  " R=(%8.2e,%8.2e,%8.2e)\n",IB(i,1),IB(i,2),IB(i,3),grid,grid2,R(jb,0),R(jb,1),R(jb,2)); 


        // --- First get i0: index of fine grid interpolation point that is closeby ---
                int i0=IB(i,0); // note i
      	if( i0<0 )
      	{
          // find the closest fine grid interp point that also uses this donor
                    int j1=IB(i,1), j2=IB(i,2), j3=IB(i,3); // coarse grid point
        	  int i1=(j1-gid1(0,0))*cf[0]+gid0(0,0), i2=(j2-gid1(0,1))*cf[1]+gid0(0,1), i3=(j3-gid1(0,2))*cf[2]+gid0(0,2);  // fine grid pt
                    int minDist=INT_MAX;
        	  for( int k=interpolationPoint0.getBase(0); k<=interpolationPoint0.getBound(0); k++ )
        	  {
                        int donor=ig0(k);
          	    if( donor==grid2 )
          	    {
                            int dist = abs(i1-ip0(k,0))+abs(i2-ip0(k,1));
            	      if( numberOfDimensions==3 ) dist+= abs(i3-ip0(k,2));
            	      if( dist<minDist )
            	      {
            		i0=k;
            		minDist=dist;
            	      }
          	    }
          	    
        	  }
// 	  if( minDist>8 )  // the fine grid point cannot be two far away! *wdh* 2012/06/03
// 	  { 
// 	    i0=-1;
// 	  }

        	  if( minDist>4 )
        	  {
          	    IA0(ii,4)=canInterpolateQualityVeryBad; // very bad qaulity for these "r" coordinates 
        	  }
        	  

        	  if( i0<0 )
        	  {
          	    if( debug & 4 )
          	    {
            	      fprintf(pDebugFile,"  getInterpCoordsNew: i=%i Unable to invert pt (%i,%i,%i) grid=%i from donor=%i"
                  		      " R=(%8.2e,%8.2e,%8.2e) \n",i,IB(i,1),IB(i,2),IB(i,3),grid,grid2,R(jb,0),R(jb,1),R(jb,2)); 
            	      fprintf(pDebugFile,"  getInterpCoordsNew: i=%i Unable to find a fine grid interp pt with donor=%i\n",i,grid2);
          	    }
          	    
	    // OV_ABORT("finish me for this case: IB(i,0)<0");


            // fill in bogus values -- this will force another donor grid to be found.
            // *** we could do better here ***
                        IA0(ii,4)=canNotInterpolate; // mark as unable to interpolate
          	    for( int axis=0; axis<numberOfDimensions; axis++ )
          	    {
            	      RB(i,axis)=Mapping::bogus;
          	    }
          	    continue;
          	    
        	  }
                    else
        	  {
                        if( debug & 4 )
            	      fprintf(pDebugFile,"  - use nearby fine grid interp. pt i0=%i, (%i,%i,%i) min-index-dist=%i "
                                            "to guess interp coords...\n",
                                            i0,ip0(i0,0),ip0(i0,1),(numberOfDimensions==2 ? 0 : ip0(i0,2)),minDist);
            	      
        	  }
        	  
        	  
      	}
      	
      	assert( i0>=0 );
      	
        // As a first approximation the r coords are the same as the nearby fine grid interp pt,
        // we then improve this below: 
          	for( axis=0; axis<numberOfDimensions; axis++ )   // *wdh* 021203
            	  R(jb,axis)=ci0(i0,axis);	

      	

	// dx = distance from nearby interpolation pt to the new interpolation point.
	// add dr = (dr/dx)_2 * dx 
      	if( g2IsRectangular )
      	{
          // -- If g2 is rectangular we can compute the correction dr[axis] directly. ---

        	  int i1=ip0(i0,0), i2=ip0(i0,1), i3=numberOfDimensions==2 ? 0 : ip0(i0,2);
        	  int j1=IB(i,1), j2=IB(i,2), j3=IB(i,3);
        	  if( isRectangular )
        	  {
          	    dx[0]=CENTER10(j1,j2,j3)-CENTER00(i1,i2,i3);
          	    dx[1]=CENTER11(j1,j2,j3)-CENTER01(i1,i2,i3);
          	    dx[2]=CENTER12(j1,j2,j3)-CENTER02(i1,i2,i3);
        	  }
        	  else
        	  {
          	    for( axis=0; axis<numberOfDimensions; axis++ )
          	    {
            	      dx[axis]=X(jb,axis)-CENTER0(i1,i2,i3,axis);  
          	    }
        	  
        	  }
        	  dr[0]=dx[0]/dx2[0]*dr2[0];
        	  dr[1]=dx[1]/dx2[1]*dr2[1];
        	  dr[2]=dx[2]/dx2[2]*dr2[2];

        	  for( int axis=0; axis<numberOfDimensions; axis++ )
        	  {
          	    R(jb,axis)+=dr[axis];
	    // limit r to [0,1] unless the boundary is interpolation, then limit by .25*Delta r
	    // from the last interpolation point.
          	    RB(i,axis)=max(rMin[axis],min(rMax[axis],R(jb,axis)));
        	  }

      	}    
      	else
      	{
          // Grid g2 is curvilinear: 
          // Keep a list of non-invertible points that have a curvilinear donor grid.
          // Below we will evaluate map2 to determine dx/dr from which we compute dr[axis]

        	  if( ja.getLength(0) >= numToFix )
        	  { // add space to hold the points that need fixing
                        int newSize = min( max(10,ja.getLength(0) + numToInterp/4), numToInterp);
                        ja.resize(newSize,2);
        	  }
        	  ja(numToFix,0)=jb;
        	  ja(numToFix,1)=i0;
        	  numToFix++;
      	}
            }  // end if point not invertible
            else
            {
        // Point was invertible: save the r coordinates
      	if( debug & 4 )
        	  fprintf(pDebugFile,"  getInterpCoordsNew: pt (%i,%i,%i) grid=%i interpolates from donor=%i,"
              		  " R=(%8.2e,%8.2e,%8.2e)\n",IB(i,1),IB(i,2),IB(i,3),grid,grid2,R(jb,0),R(jb,1),R(jb,2)); 


                IA0(ii,4)=canInterpolateQuality1; // mark coordinates as best quality -- will later be adjusted
      	for( int axis=0; axis<numberOfDimensions; axis++ )
      	{
	  // limit r to [0,1] unless the boundary is interpolation, then limit by .25*Delta r
	  // from the last interpolation point.

	  // RB(i,axis)=max(rMin[axis],min(rMax[axis],R(jb,axis))); // *wdh* 2012/06/04

        	  real rjb = R(jb,axis);
        	  if( rjb<rMin[axis]-dr2[axis] || rjb>rMax[axis]+dr2[axis] )
        	  {
            // coordinates are not so good: 
                        IA0(ii,4)=canInterpolateWithExtrapolation;  
        	  }

        	  RB(i,axis)=max(rMin[axis],min(rMax[axis],rjb)); // *wdh* 2012/06/04


      	}


            }
        
        } // end for jb


        int maxNumToFix=ParallelUtility::getMaxValue(numToFix);
        if( maxNumToFix>0 ) // we need to go through this loop if any processor has points to fix
        {
      // --- There were some non-invertible points that have a curvilinear donor grid ---
      // To estimate the donor "r" coordinates we start from the coordinates of a nearby
      // fine grid interpolation point and then add on a correction:
      //       r(coarse) = r(fine) + (dr/dx)*dx

            realSerialArray xx, rr, xxr;
            if( numToFix>0 )
            {
      	rr.redim(numToFix,Rx);
      	xx.redim(numToFix,Rx);
      	xxr.redim(numToFix,Rx,Rx);
            }
            for( int jj=0; jj<numToFix; jj++ )
            {
      	const int jb=ja(jj,0);
      	for( int axis=0; axis<numberOfDimensions; axis++ )
        	  rr(jj,axis)=R(jb,axis);
            }
            
      // Evaluate x.r at the nearby interp coord's
            map2.mapS(rr,xx,xxr);
        	  
            for( int jj=0; jj<numToFix; jj++ )
            {
      	const int jb=ja(jj,0);
      	const int i0=ja(jj,1);
                const int i=IA(jb);  // index into the original ib array

	// dx = distance from nearby interpolation pt to the new interpolation point.
	// add dr = (dr/dx)_2 * dx 
                int i1=ip0(i0,0), i2=ip0(i0,1), i3=numberOfDimensions==2 ? 0 : ip0(i0,2);
                int j1=IB(i,1), j2=IB(i,2), j3=IB(i,3);
      	if( isRectangular )
      	{
        	  dx[0]=CENTER10(j1,j2,j3)-CENTER00(i1,i2,i3);
        	  dx[1]=CENTER11(j1,j2,j3)-CENTER01(i1,i2,i3);
        	  dx[2]=CENTER12(j1,j2,j3)-CENTER02(i1,i2,i3);
      	}
      	else
      	{
        	  for( int axis=0; axis<numberOfDimensions; axis++ )
        	  {
          	    dx[axis]=X(jb,axis)-CENTER0(i1,i2,i3,axis);  
        	  }
        	  
      	}
                #define XR(m,n) xxr(jj,m,n)
      	if( numberOfDimensions==2 )
      	{
        	  real det = XR(0,0)*XR(1,1)-XR(0,1)*XR(1,0);
        	  if( fabs(det)>epsDet )
        	  {
          	    det=1./det;
          	    dr[0]=(  XR(1,1)*dx[0]-XR(0,1)*dx[1] )*det;
          	    dr[1]=( -XR(1,0)*dx[0]+XR(0,0)*dx[1] )*det;
        	  }
        	  else
        	  { // if the jacobian is singular
          	    if( debug & 1 )
          	    {
            	      printf("Ogmg:getInterpCoordsNew::WARNING: non-invertible point and jacobian=0. for estimating "
                                          "location.\n");
          	    }
          	    dr[0]=dr[1]=0.;
        	  }
        	  dr[2]=0.;
        	  if( debug & 4 )
          	    fprintf(pDebugFile,"  getInterpCoordsNew: non-invertible pt, dr computed from r.x*dx: (fine interp i0=%i)\n"
                		    "  grid=%i donor=%i fine=(i1,i2,i3)=(%i,%i,%i) coarse=(%i,%i,%i), dx=(%8.2e,%8.2e) r=(%8.2e,%8.2e)"
                		    " dr=(%8.2e,%8.2e) \n",
                		    i0,grid,grid2, i1,i2,i3,j1,j2,j3,
                		    dx[0],dx[1],rr(jj,0),rr(jj,1),dr[0],dr[1]);
      	}
      	else // 3D
      	{
        	  real det =((XR(0,0)*XR(1,1)-XR(0,1)*XR(1,0))*XR(2,2) +
                 		     (XR(0,1)*XR(1,2)-XR(0,2)*XR(1,1))*XR(2,0) +
                 		     (XR(0,2)*XR(1,0)-XR(0,0)*XR(1,2))*XR(2,1));
        	  if( det>epsDet )
        	  {
          	    det=1./det;
          	    dr[0]=( (XR(1,1)*XR(2,2)-XR(2,1)*XR(1,2))*dx[0]+
                		    (XR(2,1)*XR(0,2)-XR(0,1)*XR(2,2))*dx[1]+
                		    (XR(0,1)*XR(1,2)-XR(1,1)*XR(0,2))*dx[2] )*det;
                  		      
          	    dr[1]=( (XR(1,2)*XR(2,0)-XR(2,2)*XR(1,0))*dx[0]+
                		    (XR(2,2)*XR(0,0)-XR(0,2)*XR(2,0))*dx[1]+
                		    (XR(0,2)*XR(1,0)-XR(1,2)*XR(0,0))*dx[2] )*det;
                  		      
          	    dr[2]=( (XR(1,0)*XR(2,1)-XR(2,0)*XR(1,1))*dx[0]+
                		    (XR(2,0)*XR(0,1)-XR(0,0)*XR(2,1))*dx[1]+
                		    (XR(0,0)*XR(1,1)-XR(1,0)*XR(0,1))*dx[2] )*det;

          	    if( debug & 4 )
            	      fprintf(pDebugFile," getInterpCoordsNew::non-invertible pt: interp=(%i,%i,%i) j=(%i,%i,%i)"
                                            " R(jb=%i,.)=(%8.2e,%8.2e,%8.2e) \n"
                  		      "       x=(%8.2e,%8.2e,%8.2e) \n"
                  		      "       dx=(%8.2e,%8.2e,%8.2e) dr=(%8.2e,%8.2e,%8.2e) gridSpacing=(%8.2e,%8.2e,%8.2e)\n"
                  		      " xr(.,0)=(%8.2e,%8.2e,%8.2e) \n"
                  		      " xr(.,1)=(%8.2e,%8.2e,%8.2e) \n"
                  		      " xr(.,2)=(%8.2e,%8.2e,%8.2e) \n",
                  		      i1,i2,i3,j1,j2,j3,jb,R(jb,0),R(jb,1),R(jb,2),x(jb,0),x(jb,1),x(jb,2),
                  		      dx[0],dx[1],dx[2],dr[0],dr[1],dr[2],
                  		      g2.gridSpacing(0),g2.gridSpacing(1),g2.gridSpacing(2),
                  		      XR(0,0),XR(1,0),XR(2,0),XR(0,1),XR(1,1),XR(2,1),XR(0,2),XR(1,2),XR(2,2));  
            	      
          	    for( int ax=0; ax<numberOfDimensions; ax++ )
          	    {
            	      dr[ax]=min(g2.gridSpacing(ax),max(-g2.gridSpacing(ax),dr[ax]));
          	    }
            	      
        	  }
        	  else
        	  { // if the jacobian is singular
          	    if( debug & 1 )
            	      fprintf(pDebugFile,"Ogmg::getInterpCoordsNew:WARNING: non-invertible point and jacobian=0. "
                                            "for estimating location\n"
                  		      " grid=%i, grid2=%i :  \n"
                  		      " xr[.][0]=(%8.2e,%8.2e,%8.2e) \n"
                  		      " xr[.][1]=(%8.2e,%8.2e,%8.2e) \n"
                  		      " xr[.][2]=(%8.2e,%8.2e,%8.2e) \n",grid,grid2,
                  		      XR(0,0),XR(1,0),XR(2,0),XR(0,1),XR(1,1),XR(2,1),XR(0,2),XR(1,2),XR(2,2));
          	    dr[0]=dr[1]=dr[2]=0.;
        	  }
      	} // end if 3D
      	
      	for( int axis=0; axis<numberOfDimensions; axis++ )
      	{
        	  R(jb,axis)+=dr[axis];
	  // limit r to [0,1] unless the boundary is interpolation, then limit by .25*Delta r
	  // from the last interpolation point.
        	  RB(i,axis)=max(rMin[axis],min(rMax[axis],R(jb,axis)));
      	}

            } // end for jj 
            
        } // end if( maxNumToFix>0 )
        
#undef XR

    // ------------------------------------------------------------------------
    // --- Compute the distance from the interp. pt. to the new donor point ---
    // ------------------------------------------------------------------------
    //  The distance will not be zero if the r-coord's have been shifted to the boundary

    // first make a sub-list of points for which we need to compute the distance
        if( numToInterp>0 )
            ja.redim(numToInterp);

        int numToComputeDist=0;
        for( int jb=0; jb<numToInterp; jb++ )
        {
            int i = IA(jb);  // index into IB, RB

            int ii = IB(i,4);  // index into IA0
            const int currentQuality=IA0(ii,3);         // current best donor quality
            const int interpCoordsQuality=IA0(ii,4);    // quality of the new donor

            
            if( interpCoordsQuality<=currentQuality )
            {
	// this donor may be of better quality -> we should compute the distance 
        // NOTE: there is really no need to compute the distance if the r-coord's are inside the unit square -> dist=0 *fix me*

      	ja(numToComputeDist)=i;
      	numToComputeDist++;
            }
            else
            {
	// this donor will not be chosen anyway -- 
      	donorDist(ii,1)=REAL_MAX;
      	for( int axis=0; axis<numberOfDimensions; axis++ )
      	{
        	  RB(i,axis)=Mapping::bogus;  // fill in bogus values -- this will force another donor grid to be found.
      	}
            
            }
            
        } // end for jb
        
        
        realSerialArray rr,xx;
        if( numToComputeDist>0 )
        {
            rr.redim(numToComputeDist,Rx);  xx.redim(numToComputeDist,Rx);
        }
        
        for( int jj=0; jj<numToComputeDist; jj++ )
        {
            int i = ja(jj); // index into IB
            for( int axis=0; axis<numberOfDimensions; axis++ )
      	rr(jj,axis)=RB(i,axis);  // Note: use RB values here since these have been limited to [-delta,1+delta]
            
        }
        
    // Evaluate x-coord's of donor points
        map2.mapS(rr,xx);

    // compute the distance from the donor points xx to the interp. pt. XA
        for( int jj=0; jj<numToComputeDist; jj++ )
        {
            int i = ja(jj); // index into IB
            int ii = IB(i,4); // index into IA0, XA
            
            real dist=0.;
            if( numberOfDimensions==2 )
                dist=sqrt( SQR(XA(ii,0)-xx(jj,0)) + SQR(XA(ii,1)-xx(jj,1)) );
            else
                dist=sqrt( SQR(XA(ii,0)-xx(jj,0)) + SQR(XA(ii,1)-xx(jj,1)) + SQR(XA(ii,2)-xx(jj,2)) );

            donorDist(ii,1)=dist;

            if( debug & 4 )
      	fprintf(pDebugFile,"  getCoords: pt ii=%i (%i,%i,%i) xa=(%8.2e,%8.2e,%8.2e), potential donor=%i r=(%8.2e,%8.2e,%8.2e)"
                                " x=(%8.2e,%8.2e,%8.2e) dist=%8.2e \n",
            		ii,IA0(ii,0),IA0(ii,1),IA0(ii,2), XA(ii,0),XA(ii,1),(numberOfDimensions==2 ? 0. : XA(ii,2)),
                                grid2,rr(jj,0),rr(jj,1),(numberOfDimensions==2 ? 0. : rr(jj,2)),
                                xx(jj,0),xx(jj,1),(numberOfDimensions==2 ? 0. : xx(jj,2)),dist);

        }


    }  // end for( grid2 ) -- loop over possible donor grids




  // *wdh* 2011/06/12 -- check for nan's
    if( checkForNans )  
    {
        for( int i=0; i<maxNumToInterp; i++ )
        {
            if( numberOfDimensions==2 )
            {
        // fprintf(pDebugFile,"Ogmg:getInterpCoordsNew: i=%i RB=(%e,%e)\n",i,RB(i,0),RB(i,1));

      	if( RB(i,0)!=RB(i,0) || RB(i,1)!=RB(i,1) )
      	{
        	  printf("Ogmg:getInterpCoordsNew:ERROR(4): myid=%i i=%i r=(%e,%e) nan's ?? \n",myid,i,RB(i,0),RB(i,1));
      	}
            }
            else 
            {
      	if( RB(i,0)!=RB(i,0) || RB(i,1)!=RB(i,1) || RB(i,2)!=RB(i,2) )
      	{
        	  printf("Ogmg:getInterpCoordsNew:ERROR(4): i=%i r=(%e,%e,%e) nan's ?? \n",i,RB(i,0),RB(i,1),RB(i,2));
      	}
            }
      	
        }
        fflush(0);
        fflush(pDebugFile);
        
    }
    
    return 0;
}

