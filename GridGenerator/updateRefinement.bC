#include "Overture.h"
#include "Ogen.h"
#include "display.h"
#include "HDF_DataBase.h"
#include "ParallelUtility.h"

// The next file contains:
//    macro setMaskAtAlignedHoles(DIM,RATIO)
#Include updateRefinementMacros.h


#define FOR_3D(i1,i2,i3,I1,I2,I3) \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++) \
for(i2=I2Base; i2<=I2Bound; i2++) \
for(i1=I1Base; i1<=I1Bound; i1++)

#define FOR_3(i1,i2,i3,I1,I2,I3) \
I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++) \
for(i2=I2Base; i2<=I2Bound; i2++) \
for(i1=I1Base; i1<=I1Bound; i1++)

#define FOR_3DS(i1,i2,i3,I1,I2,I3) \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
int I1Stride=I1.getStride(),  I2Stride=I2.getStride(), I3Stride=I3.getStride(); \
for(i3=I3Base; i3<=I3Bound; i3+=I3Stride ) \
for(i2=I2Base; i2<=I2Bound; i2+=I2Stride ) \
for(i1=I1Base; i1<=I1Bound; i1+=I1Stride )

#define FOR_3S(i1,i2,i3,I1,I2,I3) \
I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
I1Stride=I1.getStride(),  I2Stride=I2.getStride(), I3Stride=I3.getStride(); \
for(i3=I3Base; i3<=I3Bound; i3+=I3Stride ) \
for(i2=I2Base; i2<=I2Bound; i2+=I2Stride ) \
for(i1=I1Base; i1<=I1Bound; i1+=I1Stride )

#define FOR_3R()  \
I1rBase  =I1r.getBase(),  I2rBase  =I2r.getBase(),  I3rBase  =I3r.getBase();   \
I1rBound =I1r.getBound(), I2rBound =I2r.getBound(), I3rBound =I3r.getBound();  \
I1rStride=I1r.getStride(),I2rStride=I2r.getStride(),I3rStride=I3r.getStride();  \
  \
for(i3r=I3rBase; i3r<=I3rBound; i3r+=I3rStride)   \
for(i2r=I2rBase; i2r<=I2rBound; i2r+=I2rStride)   \
for(i1r=I1rBase; i1r<=I1rBound; i1r+=I1rStride)

#define FOR_3BR()  \
I1bBase =I1b.getBase(),   I2bBase =I2b.getBase(),  I3bBase =I3b.getBase();   \
I1bBound=I1b.getBound(),  I2bBound=I2b.getBound(), I3bBound=I3b.getBound();  \
  \
I1rBase  =I1r.getBase(),  I2rBase  =I2r.getBase(),  I3rBase  =I3r.getBase();   \
I1rBound =I1r.getBound(), I2rBound =I2r.getBound(), I3rBound =I3r.getBound();  \
I1rStride=I1r.getStride(),I2rStride=I2r.getStride(),I3rStride=I3r.getStride();  \
  \
for(i3b=I3bBase,i3r=I3rBase; i3b<=I3bBound; i3b++,i3r+=I3rStride)   \
for(i2b=I2bBase,i2r=I2rBase; i2b<=I2bBound; i2b++,i2r+=I2rStride)   \
for(i1b=I1bBase,i1r=I1rBase; i1b<=I1bBound; i1b++,i1r+=I1rStride)


//\begin{>>RegridInclude.tex}{\subsection{outputRefinementInfo}} 
int 
outputRefinementInfo( GridCollection & gc, 
                      const aString & gridFileName, 
                       const aString & fileName )
// =======================================================================================
// /Description:
//   This function will output a command file for the "refine" test code.
// /gc(input) : name of the grid.
// /refinementRatio (input) : refinement ratio.
// /gridFileName (input) : grid file name, such as "cic.hdf". This is not essential,
//    but then you will have to edit the comamnd file to add the correct name.
// /fileName (input) : name of the output command file, such as "bug.cmd"
// The output will be a file of the form
// \begin{verbatim}
// choose a grid
//   cic.hdf
// add a refinement
//   0 1 4 10 12 15
// add a refinement
//   0 1 3 10 15 19
// add a refinement
//   1 1 12 16 0 7
// add a refinement
//   1 1 16 20 3 7
// \end{verbatim}
//\end{RegridInclude.tex} 
// ========================================================================================
{
  printf("*** outputing a command file %s for refine ****\n",(const char*)fileName);
  
  FILE *file=fopen(fileName,"w");
  fprintf(file,"choose a grid\n"
	  " %s \n",(const char*)gridFileName);
  for( int grid=0; grid<gc.numberOfComponentGrids(); grid++ )
  {
    if( gc.refinementLevelNumber(grid)>0 )
    {
      //  Find a parent grid at the same multigrid level.
      int level=gc.refinementLevelNumber(grid);
      int p;
      for (p=0; gc.refinementLevelNumber(p)!=level-1 || gc.baseGridNumber(p)!=gc.baseGridNumber(grid); p++);

      int refinementRatio[3]={1,1,1};
      for( int axis=0; axis<gc.numberOfDimensions(); axis++ )
      {
	refinementRatio[axis]=gc.refinementFactor(axis,grid)/gc.refinementFactor(axis,p);
        assert( refinementRatio[axis]==2 || refinementRatio[axis]==4 );
      }
      
      MappedGrid & mg = gc[grid];
      fprintf(file,"add a refinement\n"
              " %i %i  %i %i %i %i %i %i %i\n",gc.baseGridNumber(grid),gc.refinementLevelNumber(grid),
              mg.gridIndexRange(0,0)/refinementRatio[0],mg.gridIndexRange(1,0)/refinementRatio[0],
              mg.gridIndexRange(0,1)/refinementRatio[1],mg.gridIndexRange(1,1)/refinementRatio[1],
              mg.gridIndexRange(0,2)/refinementRatio[2],mg.gridIndexRange(1,2)/refinementRatio[2],
             refinementRatio[0] );
    }
  }
  fclose(file);

  bool saveTheGrid=true;
  if( saveTheGrid )
  {
    // save the GridCollection (CompositeGrid) consisting of the base level grids
    // This may be necessary for moving grids if we want know the grid when the error occured.

    if( gc.getClassName()=="CompositeGrid" )
    {
      CompositeGrid & cg = (CompositeGrid &)gc;
      
      CompositeGrid c; // this will hold the base grids
    
      c = cg;  // make a copy

      // delete all refinement grids
      c.deleteRefinementLevels();
      c.updateReferences();
      
      //  *wdh* Tell the CompositeGrid that the interpolation data have been computed:
      c->computedGeometry |=
	CompositeGrid::THEmask                     |
	CompositeGrid::THEinterpolationCoordinates |
	CompositeGrid::THEinterpolationPoint       |
	CompositeGrid::THEinterpoleeLocation       |
	CompositeGrid::THEinterpoleeGrid;

      // if( c.numberOfInterpolationPoints(0)>0 )
      // {
      //   printf(" ***** c.numberOfInterpolationPoints(0)=%i\n",c.numberOfInterpolationPoints(0));
	// c.interpolationPoint[0].display("c.interpolationPoint[0]");
      // }
      


      printf("Saving the current CompositeGrid in %s\n",(const char*)gridFileName);

      HDF_DataBase dataFile;
      dataFile.mount(gridFileName,"I");

      int streamMode=1; // save in compressed form.
      dataFile.put(streamMode,"streamMode");
      if( !streamMode )
	dataFile.setMode(GenericDataBase::noStreamMode); // this is now the default
      else
      {
	dataFile.setMode(GenericDataBase::normalMode); // need to reset if in noStreamMode
      }
           
      if( c.numberOfGrids() > 1 || c.numberOfInterpolationPoints(0)>0 )
	c.destroy(MappedGrid::EVERYTHING & ~MappedGrid::THEmask );
      else
	c.destroy(CompositeGrid::EVERYTHING);
      

      const aString gridName="bugGrid";
      c.put(dataFile,gridName);
      dataFile.unmount();
      
      // -------------
      if( false )
      {
	CompositeGrid cg2;
	dataFile.mount(gridFileName,"R");
	cg2.get(dataFile,gridName);
      
	// printf(" ***** cg2.numberOfInterpolationPoints(0)=%i\n",cg2.numberOfInterpolationPoints(0));
	// cg2.interpolationPoint[0].display("cg2.interpolationPoint[0]");
      }
      
      // ----------------
    }
    
    


  }
  


  return 0;
}


//\begin{>>ogenUpdateInclude.tex}{\subsubsection{updateRefinement : Adapative Grid updateOverlap}}
int Ogen::
updateRefinement(CompositeGrid & cg, 
                 const int & refinementLevel /* = -1 */ )
// ===================================================================================
// /Description:
//    Update the refinement levels. 
//
// /refinementLevel (input): update this refinement level. By default update all refinement levels.
// /Notes:
//  A refinement grid prefers to interpolate from
//   \begin{enumerate}
//     \item Another refinement at the same level and same base grid
//     \item Another refinement at the same level and different base grid
//     \item The base grid.  ( -> ?? no need to check lower refinement levels ?? )
//   \end{enumerate}
//  Interpolation points on the base grid are not changed.
//\end{ogenUpdateInclude.tex}
// ===================================================================================
{
  #ifdef USE_PPP
    // return updateRefinementNew(cg,refinementLevel);

    // *wdh* 061211 -- indicate that the AMR interpolation data uses the local arrays in the CompositeGrid
    if( cg->localInterpolationDataState!=CompositeGridData::localInterpolationDataForAll )
      cg->localInterpolationDataState=CompositeGridData::localInterpolationDataForAMR;

    return updateRefinementNewer(cg,refinementLevel);  // even newer version 
  #endif

  real timeStart=getCPU();
  bool useOpt=true; 
  // bool useOptNew=true;

  if( cg.numberOfBaseGrids() <=1 )
  {
    // assign mask values at points hidden by finer patches
    cg.setMaskAtRefinements();
    return 0;
  }
  
  // const bool useNewAlgorithm=TRUE; 
  
  
//  debug=0;
//  debug=7;  // *************************


  updateParameters(cg); // this will compute interpolationOverlap

  // cg.update( MappedGrid::THEcenter | MappedGrid::THEvertex | MappedGrid::THEmask );
  int grid;
  for( grid=0; grid<cg.numberOfComponentGrids(); grid++ )
  {
    if( cg[grid].isRectangular() )
      cg[grid].update(MappedGrid::THEmask );
    else
      cg[grid].update(MappedGrid::THEvertex | MappedGrid::THEcenter | MappedGrid::THEmask );
  }
  
  real time1=getCPU();
  real timeForUpdate=time1-timeStart;
  // printf(" cg.interpoleeGrid[0]: min=%i, max=%i (start)\n",min(cg.interpoleeGrid[0]),max(cg.interpoleeGrid[0]));

  Range Rx(0,cg.numberOfDimensions()-1),all;
  const int & numberOfDimensions = cg.numberOfDimensions();

  Index Iv[3], &I1 = Iv[0], &I2=Iv[1], &I3=Iv[2];
  Index Jv[3], &J1 = Jv[0], &J2=Jv[1], &J3=Jv[2];
  Index Ivr[3], &I1r = Ivr[0], &I2r=Ivr[1], &I3r=Ivr[2];
  Index Ivb[3], &I1b = Ivb[0], &I2b=Ivb[1], &I3b=Ivb[2];
      
  int iv[3], &i1=iv[0], &i2=iv[1], &i3=iv[2];
  int jv[3], &j1=jv[0], &j2=jv[1], &j3=jv[2];
  int kv[3], &k3=kv[2];
  int lv[3], &l3=lv[2];
  int ie[3], &ie1=ie[0], &ie2=ie[1], &ie3=ie[2];
  int iBase[3],iBound[3];

  realArray rr(1,3),xx(1,3),rb(1,3); rr=-1.; rb=-1.;
  
  intArray interpolates(1), useBackupRules(1);
  useBackupRules=FALSE;
  const int notAssigned = INT_MIN;
  const int mgLevel=0;  // *** multigrid level
  
  // 
  // If checkForOneSided=TRUE then canInterpolate will not allow a one-sided interpolation
  // stencil to use ANY interiorBoundaryPoint's -- this is actually too strict. We really
  // only want to disallow interpolation that has less than the minimum overlap distance
  //
  checkForOneSided=FALSE;  
  int axis,dir;
  int l;

  // allocate temporary arrays to hold the new interpolation points on the refinement level.
  intArray **interpolationPoints = new intArray* [cg.numberOfRefinementLevels()];

  int i1b,i2b,i3b,i1r,i2r,i3r;
  int I1bBase,I2bBase,I3bBase; 
  int I1bBound,I2bBound, I3bBound;
  int I1rBase,I2rBase,I3rBase; 
  int I1rBound,I2rBound,I3rBound;
  int I1rStride,I2rStride,I3rStride;
  int I1Base,I2Base,I3Base; 
  int I1Bound,I2Bound,I3Bound;
  int I1Stride,I2Stride,I3Stride;

  real timeForMarkOffAxis=0., timeForMarkInterp=0.;
  
  for( l=1; l<cg.numberOfRefinementLevels(); l++ )
    interpolationPoints[l] = new intArray [cg.refinementLevel[l].numberOfComponentGrids()];
  
  // ******************************************************************************************
  //  For each refinement level above the coarsest,
  //  build a mask array for each refinement grid, based on the mask array for coarser levels.
  //  The mask array will indicate which points should be interpolated.    
  // ******************************************************************************************
  for( l=1; l<cg.numberOfRefinementLevels(); l++ )
  {
    GridCollection & rl = cg.refinementLevel[l];
    // IntegerArray *interpolationPoints = new IntegerArray [rl.numberOfComponentGrids()];
    
    int g;
    for( g=0; g<rl.numberOfComponentGrids(); g++ )
    {
      int grid =rl.gridNumber(g);        // index into cg
      int bg = cg.baseGridNumber(grid);  // base grid for this refinement
      
      // printf("updateOverlap(refinements): update level=%i, g=%i, grid=%i from base grid %i\n",l,g,grid,bg);

      MappedGrid & cr = rl[g];              // refined grid
      MappedGrid & cb = cg[bg];             // base grid

      const intArray & maskb = cb.mask();   // base grid mask
      intArray & maskr = cr.mask();         // *** here is the mask we need to assign ***

      maskr=MappedGrid::ISdiscretizationPoint;

      int rf[3];  // refinement factors to the base grid.
      rf[0]=rl.refinementFactor(0,g);
      rf[1]=rl.refinementFactor(1,g);
      rf[2]=rl.refinementFactor(2,g);
      
      assert( rf[0]>0 && rf[1]>0 && rf[2]>0 );

      int rrf[3]={1,1,1}; // refinement factors to the next level
      const int gParent=0;  // assume refinement factors are the same for all grids.
      for( axis=0; axis<3; axis++ )
        rrf[axis]=rl.refinementFactor(0,g)/cg.refinementLevel[l-1].refinementFactor(0,gParent);

      // make a copy of the mask which is larger than the extended index range, just
      // so we can index it in a convenient way. (we may want to index points outside the extendedIndexRange)
      getIndex(cr.extendedIndexRange(),I1,I2,I3);
      J3=I3;
      for( axis=0; axis<numberOfDimensions; axis++ )
      {
	int base  = Iv[axis].getBase();
	int bound = Iv[axis].getBound();
	// note -1 % 2 == -1, -3 % 4 == -3
        // base = base%rf[axis] == 0 ? base-rf[axis] : base - abs(base % rf[axis]);
	// bound= bound%rf[axis]==0 ? bound+rf[axis] : bound +rf[axis]-abs(bound % rf[axis]);


        int baseMod = base>0 ? base % rf[axis] : rf[axis] - ((-base) % rf[axis]);
        int boundMod = bound>0 ? bound % rf[axis] : rf[axis] - ((-bound) % rf[axis]);
	
        base = baseMod == 0 ? base-rf[axis] : base  - baseMod;
	bound= boundMod==0 ? bound+rf[axis] : bound + rf[axis]-boundMod;

	assert( base%rf[axis] ==0 && bound%rf[axis] ==0 );

	Iv[axis]=Range(max(base,cb.dimension(Start,axis)*rf[axis]), min(bound,cb.dimension(End,axis)*rf[axis]));

        base =min(cr.dimension(Start,axis),base);
	bound=max(cr.dimension(End  ,axis),bound);
        Jv[axis]=Range(base,bound);
      }

      intArray mask(J1,J2,J3);              // ** mask for refinement grid (with extra space)
      getIndex(cr.dimension(),J1,J2,J3);
      mask=MappedGrid::ISdiscretizationPoint; // =0; ************* wdh 000709
      mask(J1,J2,J3)=maskr(J1,J2,J3);       // default values.

      // getIndex(cr.indexRange(),I1,I2,I3);
      if( debug & 4 )
      {
        fPrintF(logFile,"\n ******** updateRefinement: start a new grid *********\n\n");
        fPrintF(logFile,"refinement level=%i, g=%i, indexRange=(%i,%i)X(%i,%i) Iv[0]=(%i,%i)\n",l,g,
              cr.indexRange()(0,0),
		cr.indexRange()(1,0),cr.indexRange()(0,1),cr.indexRange()(1,1),Iv[0].getBase(),Iv[0].getBound());
      }
      

      for( axis=0; axis<3; axis++ )
      {
	Ivr[axis]=Range(Iv[axis].getBase(),Iv[axis].getBound(),rf[axis]);
	Ivb[axis]=Range(floorDiv(Iv[axis].getBase(),rf[axis]),
                        floorDiv(Iv[axis].getBound(),rf[axis]));
      }
      if( debug & 4 )
        fPrintF(logFile," grid=%i : Iv=[%i,%i], Ivr=[%i,%i] Ivb=[%i,%i] rf=%i \n",grid,
              Iv[0].getBase(),Iv[0].getBound(),
              Ivr[0].getBase(),Ivr[0].getBound(),
	      Ivb[0].getBase(),Ivb[0].getBound(),rf[0]);
      
      // 
      //       X--.--X--.--X
      //       |  |  |  |  |
      //       .  0  0  0  .
      //       |  |  |  |  |
      //       X--0--0--0--X
      //       |  |  |  |  |
      //       .  0  0  0  .
      //       |  |  |  |  |
      //       X--.--X--.--X
      //

      //       if( FALSE && g==1 )
      //       {
      //         maskb.display("g=1, maskb");
      //         maskb(I1b,I2b,I3b).display("g=1, b(I1b,I2b,I3b)");
      //         mask(I1,I2,I3).display("g=1, mask after 1");
      //       }
      
      // special case if refinement aligns with the extendedIndexRange of a base grid
      // interpolation side.
      for( axis=0; axis<numberOfDimensions; axis++ )
      {
	for( int side=Start; side<=End; side++ )
	{
	  if( cb.boundaryCondition(side,axis)==0 && 
              (cr.indexRange(side,axis) % rf[axis])==0 && // *wdh* 000630
	      floorDiv(cr.indexRange(side,axis),rf[axis])==cb.extendedIndexRange(side,axis) )
	  {
	    getBoundaryIndex(cr.dimension(),side,axis,I1,I2,I3);
	    Iv[axis]=cr.indexRange(side,axis);

	    getBoundaryIndex(cr.dimension(),side,axis,J1,J2,J3);
	    for( int ghost=1; ghost<=cr.numberOfGhostPoints(side,axis); ghost++ )
	    {
	      Jv[axis]=cr.indexRange(side,axis)-ghost*(1-2*side);
	      mask(J1,J2,J3)=0;
	    }
	  }
	}
      }

      if( debug & 4 )
      {
        fPrintF(logFile," after: grid=%i : Ivr=[%i,%i] Ivb=[%i,%i] \n",grid,Ivr[0].getBase(),Ivr[0].getBound(),
		Ivb[0].getBase(),Ivb[0].getBound());
        displayMask(mask,"After mark interp boundaries: mask (1)",logFile);
      }
      
    int * maskp = mask.Array_Descriptor.Array_View_Pointer2;
    const int maskDim0=mask.getRawDataSize(0);
    const int maskDim1=mask.getRawDataSize(1);
#undef MASK
#define MASK(i0,i1,i2) maskp[i0+maskDim0*(i1+maskDim1*(i2))]
    const int * maskbp = maskb.Array_Descriptor.Array_View_Pointer2;
    const int maskbDim0=maskb.getRawDataSize(0);
    const int maskbDim1=maskb.getRawDataSize(1);
#undef MASKB
#define MASKB(i0,i1,i2) maskbp[i0+maskbDim0*(i1+maskbDim1*(i2))]
    int * maskrp = maskr.Array_Descriptor.Array_View_Pointer2;
    const int maskrDim0=maskr.getRawDataSize(0);
    const int maskrDim1=maskr.getRawDataSize(1);
#undef MASKR
#define MASKR(i0,i1,i2) maskrp[i0+maskrDim0*(i1+maskrDim1*(i2))]


      // ---- mark refinement holes that coincide with base grid holes. ----
      // Note: I1b : no stride, I1r: stride
      if( !useOpt ) 
      {
	where( maskb(I1b,I2b,I3b)==0 )
	{
	  mask(I1r,I2r,I3r)=0;
	}
      }
      else
      {
        FOR_3BR()
	{
	  if( MASKB(i1b,i2b,i3b)==0 )
	  {
	    MASK(i1r,i2r,i3r)=0;
	  }
	}
      }
      
      if( debug & 4 )
      {
        displayMask(mask,"After mark holes that coincide with base grid holes: mask (2)",logFile);
      }

      int r;
      // Now mark refinement holes that lie directly between
      // base grid holes along each axis OR next to a hole point along an axis !!

//        intArray maskSave1,maskSave2; // ***wdh***
//        maskSave1=mask;

      if( !useOpt )
      {
	for( axis=0; axis<numberOfDimensions; axis++ )
	{
	  // decrease ranges by "1" in the axis direction. -- needed if rf[axis]>number of ghost lines
	  Ivr[axis]=Range(Ivr[axis].getBase(),Ivr[axis].getBound()-rf[axis],rf[axis]);
	  Ivb[axis]=Range(Ivb[axis].getBase(),Ivb[axis].getBound()-1);

	  const intArray & maskb0 = evaluate(maskb(I1b,I2b,I3b)==0);
	  Ivb[axis]=Ivb[axis]+1;
	  where( maskb0 || maskb(I1b,I2b,I3b)==0 )
	  {
	    for( r=1; r<rf[axis]; r++ )
	    {
	      Ivr[axis]=Ivr[axis]+1;
	      mask(I1r,I2r,I3r)=0;
	    }
	    Ivr[axis]=Ivr[axis]-(rf[axis]-1);
	  }
	  Ivb[axis]=Ivb[axis]-1;

        // reset    
	  Ivr[axis]=Range(Ivr[axis].getBase(),Ivr[axis].getBound()+rf[axis],rf[axis]);
	  Ivb[axis]=Range(Ivb[axis].getBase(),Ivb[axis].getBound()+1);
	}
	
      }
      else if( useOpt )
      {
        // Mark the mask at refinement grid points that lie directly between base grid holes
        if( numberOfDimensions==2 )
	{
          if( rf[0]==2 && rf[1]==2 )
	  {
    	    setMaskAtAlignedHoles(2,2);
	  }
	  else if( rf[0]==4 && rf[1]==4 )
	  {
            setMaskAtAlignedHoles(2,4);
	  }
          else
	  {
            setMaskAtAlignedHoles(2,general);
	  }
	}
	else if( numberOfDimensions==3 )
	{
          if( rf[0]==2 && rf[1]==2 && rf[2]==2 )
	  {
    	    setMaskAtAlignedHoles(3,2);
	  }
	  else if( rf[0]==4 && rf[1]==4 && rf[2]==4 )
	  {
            setMaskAtAlignedHoles(3,4);
	  }
          else
	  {
            setMaskAtAlignedHoles(3,general);
	  }
	}
	
      }
      

      if( debug & 4 )
      {
        displayMask(mask,"After mark holes aligned holes: mask (3)",logFile);
      }


//        if( false )
//        {
//  	if( max(abs(mask-maskSave2))!=0 )
//  	{
//  	  printf("**** ERROR in setMaskAtAlignedHoles ****\n");
       
//  	  if( debug & 4 )
//  	  {
//  	    fPrintF(logFile,"**** ERROR in setMaskAtAlignedHoles ****\n");
//  	    displayMask(maskSave2,"maskSave2 (old way)",logFile);
//  	    displayMask(mask,"mask (new way)",logFile);
//  	    mask=abs(mask-maskSave2);
//  	    displayMask(mask,"diff",logFile);
//  	  }

//  	  mask=maskSave2;
//  	}
//  	else
//  	{
//  	  printf("**** PASSED setMaskAtAlignedHoles ****\n");
//  	}
//        }
      

      // Now mark off-axis points as holes if any corner of the cell is a hole.
      real timea=getCPU();
      #ifndef USE_PPP
        markOffAxisRefinementMask( numberOfDimensions,Ivr,Ivb,rf,mask,maskb );
      #else
        Overture::abort("ERROR: this version no implemented for parallel");
      #endif
      timeForMarkOffAxis+=getCPU()-timea;

      if( debug & 4 )
        displayMask(mask,"After mark off axis refinement pts, mask (4)",logFile);

      // Finally mark extra ghost line values of the refinement.

//        maskSave1=mask;  // ***wdh***
      
//        for( int jj=0; jj<=1; jj++ )
//        {
//  	useOpt = jj==0;
	
      for( axis=0; axis<numberOfDimensions; axis++ )
      {
	for( int side=Start; side<=End; side++ )
	{
          // there may be some hanging points for rrf > 2
          //  --------X
          //          |    / this point needs to be marked as interpolation
          //          |   /
          //      + + +  +  x x          <--- ghost line on refinement (no refinement patch above)
          //  --------X--+--+-x-X        <--- top edge of refinement
          //      + + +  +  + + x x
          //          |       + | x x<----- interp pts on refinement
          //                  + | + x
          if( rrf[axis]>2 && cr.boundaryCondition(side,axis)==0  )
	  {
            for( int ghost=1; ghost<=1; ghost++ )
	    {
  	      getBoundaryIndex(cr.gridIndexRange(),side,axis,I1,I2,I3);

	      // printf(" ===== grid=%i (side,axis)=(%i,%i) baseGrid=%i \n",grid,side,axis,bg);
	      // displayMask(mask(I1,I2,I3),"mask(I1,I2,I3) (boundary line)");

	      const int axisp1 = (axis+1) % numberOfDimensions;

	      Iv[axis] = cr.indexRange(side,axis)-ghost*(1-2*side);
	      // displayMask(mask(I1,I2,I3),"mask(I1,I2,I3) (ghost line)");

              // *wdh* 000709 Iv[axisp1]=Range(Iv[axisp1].getBase(),Iv[axisp1].getBound()-rrf[axisp1],rrf[axisp1]);
              Iv[axisp1]=Range(Iv[axisp1].getBase()-rrf[axisp1],Iv[axisp1].getBound(),rrf[axisp1]);
	      // displayMask(mask(I1,I2,I3),"mask(I1,I2,I3) (every 4th pt)");

	      J1=I1, J2=I2, J3=I3;
	      if( numberOfDimensions==2 )
	      {
                // Mark intermediate points on ghost lines when exactly one coarse grid point is an interior point
                //         ----X-+-+-+-0----
                if( useOpt )
		{
  		  Jv[axisp1]+=rrf[axisp1];
		  intArray m;
		  m=((mask(I1,I2,I3)==0)+(mask(J1,J2,J3)==0))==1;
		  // display(m,"m","%2i");

		  where( m )
		  {
		    for( int r1=1; r1<rrf[axisp1]; r1++ )
		    {
		      Iv[axisp1]+=1;
		      mask(I1,I2,I3)=0;
		    }
		  }
		}
		else
		{
                  if( axis==0 )
		  {
		    FOR_3S(i1,i2,i3,I1,I2,I3)
		    {
		      if( ((MASK(i1,i2,i3)==0)+(MASK(i1,i2+rrf[1],i3)==0)) ==1 )
		      {
			for( int r=1; r<rrf[1]; r++ )
			{
			  MASK(i1,i2+r,i3)=0;
			}
		      }
		    }
		  }
		  else
		  {
		    FOR_3S(i1,i2,i3,I1,I2,I3)
		    {
		      if( ((MASK(i1,i2,i3)==0)+(MASK(i1+rrf[0],i2,i3)==0)) ==1 )
		      {
			for( int r=1; r<rrf[0]; r++ )
			{
			  MASK(i1+r,i2,i3)=0;
			}
		      }
		    }
		  }
		  
		}
		
	      }
	      else if( numberOfDimensions==3 )
	      {
                const int axisp2 = (axis+2) % numberOfDimensions;
                Iv[axisp2]=Range(Iv[axisp2].getBase(),Iv[axisp2].getBound()-rrf[axisp2],rrf[axisp2]);
                Jv[axisp2]=Iv[axisp2];
		
                // Mark intermediate points on ghost lines when exactly one coarse grid point is an interior point
                // check the 4 corners of the face.
		if( !useOpt )
		{
		  intArray m;
		  m=mask(I1,I2,I3)==0;
		  Jv[axisp1]+=rrf[axisp1];
		  m+=(mask(J1,J2,J3)==0);
		  Jv[axisp2]+=rrf[axisp2];
		  m+=(mask(J1,J2,J3)==0);
		  Jv[axisp1]-=rrf[axisp1];
		  m+=(mask(J1,J2,J3)==0);
		  m = m==1;
		  where( m  )
		  {
		    for( int r2=1; r2<rrf[axisp2]; r2++ )
		    {
		      Iv[axisp2]+=r2;
		    
		      for( int r1=1; r1<rrf[axisp1]; r1++ )
		      {
			Iv[axisp1]+=r1;
			mask(I1,I2,I3)=0;
			Iv[axisp1]-=r1;
		      }
		      Iv[axisp2]-=r2;
		    }
		  }
		}
		else // opt version
		{
                  if( axis==0 )
		  {
		    FOR_3S(i1,i2,i3,I1,I2,I3)
		    {
		      if( ((MASK(i1,i2       ,i3       )==0)+(MASK(i1,i2+rrf[1],i3       )==0)+
                           (MASK(i1,i2       ,i3+rrf[2])==0)+(MASK(i1,i2+rrf[1],i3+rrf[2])==0)) ==1 )
		      {
			for( int r3=1; r3<rrf[2]; r3++ )
			for( int r2=1; r2<rrf[1]; r2++ )
			{
			  MASK(i1,i2+r2,i3+r3)=0;
			}
		      }
		    }
		  }
                  else if( axis==1 )
		  {
		    FOR_3S(i1,i2,i3,I1,I2,I3)
		    {
		      if( ((MASK(i1,i2       ,i3       )==0)+(MASK(i1+rrf[0],i2,i3       )==0)+
                           (MASK(i1,i2       ,i3+rrf[2])==0)+(MASK(i1+rrf[0],i2,i3+rrf[2])==0)) ==1 )
		      {
			for( int r3=1; r3<rrf[2]; r3++ )
			for( int r1=1; r1<rrf[0]; r1++ )
			{
			  MASK(i1+r1,i2,i3+r3)=0;
			}
		      }
		    }
		  }
		  else
		  {
		    FOR_3S(i1,i2,i3,I1,I2,I3)
		    {
		      if( ((MASK(i1       ,i2       ,i3)==0)+(MASK(i1       ,i2+rrf[1],i3)==0)+
                           (MASK(i1+rrf[0],i2       ,i3)==0)+(MASK(i1+rrf[0],i2+rrf[1],i3)==0)) ==1 )
		      {
			for( int r2=1; r2<rrf[1]; r2++ )
			for( int r1=1; r1<rrf[0]; r1++ )
			{
			  MASK(i1+r1,i2+r2,i3)=0;
			}
		      }
		    }
		  }
		  

		}
		  
	      }
	    }
	  }  // end if( rrf[axis]>2 && ..

	  getBoundaryIndex(cr.dimension(),side,axis,I1,I2,I3);
          Iv[axis]=cr.indexRange(side,axis);

          getBoundaryIndex(cr.dimension(),side,axis,J1,J2,J3);
          for( int ghost=2; ghost<=cr.numberOfGhostPoints(side,axis); ghost++ )
	  {
            Jv[axis]=cr.indexRange(side,axis)-ghost*(1-2*side);
            // special case if refinement aligns with the extendedIndexRange of a base grid
            // interpolation side.
	    where( mask(I1,I2,I3)==0 )
	    {
	      mask(J1,J2,J3)=0;
	    }
	    elsewhere( mask(J1,J2,J3)!=0 )  // *wdh* 981017
	    {
	      mask(J1,J2,J3)=MappedGrid::ISghostPoint;
	    }
	  }
	}
      }  // end for axis
      
//        if( jj==0 ) 
//        { maskSave2=mask; // new way
//          mask=maskSave1;  // reset 
//        }
//        } // end for jj
      
//        if( max(abs(mask-maskSave2))!=0 )
//        {
//  	printf("**** ERROR in setMaskAtAlignedHoles ****\n");
       
//  	if( debug & 4 )
//  	{
//            fPrintF(logFile,"**** ERROR in setMaskAtAlignedHoles ****\n");
//  	  displayMask(mask,"mask (old way)",logFile);
//  	  displayMask(maskSave2,"maskSave2 (new way)",logFile);
//            maskSave1=abs(mask-maskSave2);
//  	  displayMask(maskSave1,"diff",logFile);
//  	}
//        }
//        else
//        {
//  	printf("**** PASSED set Hanging nodes ****\n");
//        }

      real timei=getCPU();
      // mark interpolation points on the refinement
      intArray & ip = interpolationPoints[l][g];
      int maxInterpNew=cg.numberOfInterpolationPoints(bg)*(max(rf[0],rf[1],rf[2])+numberOfDimensions-1)+100;
      ip.redim(maxInterpNew,3);

      int * ipp = ip.Array_Descriptor.Array_View_Pointer1;
      int ipDim0=ip.getRawDataSize(0);
#undef IP
#define IP(i0,i1) ipp[i0+ipDim0*(i1)]

      // *wdh* 981102 getIndex(cr.indexRange(),I1,I2,I3);
      getIndex(cr.extendedIndexRange(),I1,I2,I3);

      // build maskI(i1,i2,i3) : ==1 at an interpolation point.
      if( max(abs(cr.discretizationWidth()(Rx)-3))!=0 )
      {
	printf("updateRefinement:ERROR:sorry, not implemented yet for this discretizationWidth\n");
	cr.discretizationWidth().display("discretizationWidth");
	throw "error";   
      }

      intArray maskI;
      if( !useOpt ) 
      { // The opt version does this step below...
	maskI.redim(I1,I2,I3);  
	if( max(abs(cr.discretizationWidth()(Rx)-3))==0 )
	{
	  if( numberOfDimensions==2 )
	  {
	    maskI = mask(I1,I2,I3)>0 && 
	      (mask(I1-1,I2-1,I3)==0 || mask(I1,I2-1,I3)==0 || mask(I1+1,I2-1,I3)==0 ||
	       mask(I1-1,I2  ,I3)==0 ||                         mask(I1+1,I2  ,I3)==0 ||
	       mask(I1-1,I2+1,I3)==0 || mask(I1,I2+1,I3)==0 || mask(I1+1,I2+1,I3)==0 );
	  }
	  else
	  {
	    maskI = mask(I1,I2,I3)>0 &&
	      (mask(I1-1,I2-1,I3-1)==0 || mask(I1,I2-1,I3-1)==0 || mask(I1+1,I2-1,I3-1)==0 ||
	       mask(I1-1,I2  ,I3-1)==0 || mask(I1,I2  ,I3-1)==0 || mask(I1+1,I2  ,I3-1)==0 ||
	       mask(I1-1,I2+1,I3-1)==0 || mask(I1,I2+1,I3-1)==0 || mask(I1+1,I2+1,I3-1)==0 ||

	       mask(I1-1,I2-1,I3  )==0 || mask(I1,I2-1,I3  )==0 || mask(I1+1,I2-1,I3  )==0 ||
	       mask(I1-1,I2  ,I3  )==0 ||                           mask(I1+1,I2  ,I3  )==0 ||
	       mask(I1-1,I2+1,I3  )==0 || mask(I1,I2+1,I3  )==0 || mask(I1+1,I2+1,I3  )==0 ||

	       mask(I1-1,I2-1,I3+1)==0 || mask(I1,I2-1,I3+1)==0 || mask(I1+1,I2-1,I3+1)==0 ||
	       mask(I1-1,I2  ,I3+1)==0 || mask(I1,I2  ,I3+1)==0 || mask(I1+1,I2  ,I3+1)==0 ||
	       mask(I1-1,I2+1,I3+1)==0 || mask(I1,I2+1,I3+1)==0 || mask(I1+1,I2+1,I3+1)==0 );
	  }
	}
	else
	{
	  printf("updateRefinement:ERROR:sorry, not implemented yet for this discretizationWidth\n");
	  cr.discretizationWidth().display("discretizationWidth");
	  throw "error";
	}
      }
      
      getIndex(cr.dimension(),J1,J2,J3);
      
      maskr(J1,J2,J3)=mask(J1,J2,J3);   // copy back to the original mask.

      if( debug & 4  )
        displayMask(maskr,"************ maskr after marking holes ***************",logFile);

      // useOpt=false;  // ***wdh***

      int numberOfInterpolationPoints=0;
      if( !useOpt )
      {
        FOR_3D(i1,i2,i3,I1,I2,I3)
	{
	  if( maskI(i1,i2,i3)>0 )
	  {
	    maskr(i1,i2,i3)=numberOfInterpolationPoints+1; 
	    // make a list of overlapping grid style interpolation points
	    for( axis=0; axis<3; axis++ )
	      ip(numberOfInterpolationPoints,axis)=iv[axis];

	    numberOfInterpolationPoints++;
	    if( numberOfInterpolationPoints>=maxInterpNew )
	    {
	      maxInterpNew=int(max(maxInterpNew*1.25,maxInterpNew+1000));
	      ip.resize(maxInterpNew,3);
	    }
	  }
	}
      }

//        maskSave1.redim(0);
//        maskSave2.redim(0);
//        maskSave1=maskr;  // ***wdh***
      
      if( useOpt )
      {
	numberOfInterpolationPoints=0;  // reset ***wdh***
	
        if( numberOfDimensions==2 )
	{
	  FOR_3D(i1,i2,i3,I1,I2,I3)
	  {
	    if( MASK(i1,i2,i3)>0 && 
		(MASK(i1-1,i2-1,i3)==0 || MASK(i1,i2-1,i3)==0 || MASK(i1+1,i2-1,i3)==0 ||
		 MASK(i1-1,i2  ,i3)==0 ||                        MASK(i1+1,i2  ,i3)==0 ||
		 MASK(i1-1,i2+1,i3)==0 || MASK(i1,i2+1,i3)==0 || MASK(i1+1,i2+1,i3)==0 ) )
	    {
	      MASKR(i1,i2,i3)=numberOfInterpolationPoints+1; 
	      // make a list of overlapping grid style interpolation points
	      for( axis=0; axis<3; axis++ )
		IP(numberOfInterpolationPoints,axis)=iv[axis];

	      numberOfInterpolationPoints++;
	      if( numberOfInterpolationPoints>=maxInterpNew )
	      {
		maxInterpNew=int(max(maxInterpNew*1.25,maxInterpNew+1000));
		ip.resize(maxInterpNew,3);
                // recompute pointers to ip
		ipp = ip.Array_Descriptor.Array_View_Pointer1;
		ipDim0=ip.getRawDataSize(0);

	      }
	    }
	  }
	}
	else
	{
	  FOR_3D(i1,i2,i3,I1,I2,I3)
	  {
	    if( MASK(i1,i2,i3)>0 &&
		(MASK(i1-1,i2-1,i3-1)==0 || MASK(i1,i2-1,i3-1)==0 || MASK(i1+1,i2-1,i3-1)==0 ||
		 MASK(i1-1,i2  ,i3-1)==0 || MASK(i1,i2  ,i3-1)==0 || MASK(i1+1,i2  ,i3-1)==0 ||
		 MASK(i1-1,i2+1,i3-1)==0 || MASK(i1,i2+1,i3-1)==0 || MASK(i1+1,i2+1,i3-1)==0 ||

		 MASK(i1-1,i2-1,i3  )==0 || MASK(i1,i2-1,i3  )==0 || MASK(i1+1,i2-1,i3  )==0 ||
		 MASK(i1-1,i2  ,i3  )==0 ||                          MASK(i1+1,i2  ,i3  )==0 ||
		 MASK(i1-1,i2+1,i3  )==0 || MASK(i1,i2+1,i3  )==0 || MASK(i1+1,i2+1,i3  )==0 ||

		 MASK(i1-1,i2-1,i3+1)==0 || MASK(i1,i2-1,i3+1)==0 || MASK(i1+1,i2-1,i3+1)==0 ||
		 MASK(i1-1,i2  ,i3+1)==0 || MASK(i1,i2  ,i3+1)==0 || MASK(i1+1,i2  ,i3+1)==0 ||
		 MASK(i1-1,i2+1,i3+1)==0 || MASK(i1,i2+1,i3+1)==0 || MASK(i1+1,i2+1,i3+1)==0 ) )
	    {
	      MASKR(i1,i2,i3)=numberOfInterpolationPoints+1; 
	      // make a list of overlapping grid style interpolation points
	      for( axis=0; axis<3; axis++ )
		IP(numberOfInterpolationPoints,axis)=iv[axis];

	      numberOfInterpolationPoints++;
	      if( numberOfInterpolationPoints>=maxInterpNew )
	      {
		maxInterpNew=int(max(maxInterpNew*1.25,maxInterpNew+1000));
		ip.resize(maxInterpNew,3);
                // recompute pointers to ip
		ipp = ip.Array_Descriptor.Array_View_Pointer1;
		ipDim0=ip.getRawDataSize(0);
	      }
	    }
	  }
	}
      }
      
//        if( max(abs(maskSave1-maskr))!=0 )
//        {
//  	printf("**** ERROR in marking interp ****\n");
       
//  	if( debug & 4 )
//  	{
//            fPrintF(logFile,"**** ERROR in setMaskAtAlignedHoles ****\n");
//  	  displayMask(maskSave1,"maskSave1 (old way)",logFile);
//  	  displayMask(maskr,"maskr (new way)",logFile);
//            maskSave2=abs(maskr-maskSave1);
//  	  displayMask(maskSave2,"diff",logFile);
//            maskr=maskSave1;
//  	}
//        }
//        else
//        {
//  	printf("**** PASSED marking interp ****\n");
//        }

//      useOpt=true;  // ***wdh***


      // throw away any unnecessary interpolation points.
      int dw[3];
      dw[0]=cr.discretizationWidth(axis1)/2;
      dw[1]=cr.discretizationWidth(axis2)/2;
      dw[2]=cr.discretizationWidth(axis3)/2;
      const int ISneeded = MappedGrid::ISinterpolationPoint | MappedGrid::ISdiscretizationPoint;
      i3=cr.indexRange(Start,axis3);
      iBase[2]=iBound[2]=i3;
      
      int i, ii=0;
      if( !useOpt ) 
      {
	for( i=0; i<numberOfInterpolationPoints; i++ )
	{
	  bool pointIsNeeded=FALSE;
	  for( axis=0; axis<3; axis++ )
	  {
	    iBase[axis] =max(cr.indexRange(Start,axis),ip(i,axis)-dw[axis]);
	    iBound[axis]=min(cr.indexRange(End,  axis),ip(i,axis)+dw[axis]);
	  }
	  for( int s3=iBase[2]; s3<=iBound[2]; s3++ )
	    for( int s2=iBase[1]; s2<=iBound[1]; s2++ )
	      for( int s1=iBase[0]; s1<=iBound[0]; s1++ )
	      {
		if( maskr(s1,s2,s3) & ISneeded )
		{
		  pointIsNeeded=TRUE;
		  break;
		}
	      }

	  if( pointIsNeeded )
	  {
	    ip(ii,Rx)=ip(i,Rx);
	    ii++;
	  }
	  else
	  {
	    // printf(" ***** throw away an unneeded point\n");
	    maskr(ip(i,0),ip(i,1),ip(i,2))=0;
	  }
	}
      }
      else
      {  // opt version
	
	const int irMin[3]={cr.indexRange(0,0),cr.indexRange(0,1),cr.indexRange(0,2)}; //
	const int irMax[3]={cr.indexRange(1,0),cr.indexRange(1,1),cr.indexRange(1,2)}; //
        if( numberOfDimensions==2 )
	{
	  for( i=0; i<numberOfInterpolationPoints; i++ )
	  {
	    bool pointIsNeeded=MASKR(IP(i,0),IP(i,1),0) & ISneeded;
            if( !pointIsNeeded )
	    {
	      for( axis=0; axis<2; axis++ )
	      {
		iBase[axis] =max(irMin[axis],IP(i,axis)-dw[axis]);
		iBound[axis]=min(irMax[axis],IP(i,axis)+dw[axis]);
	      }
	      const int s3=0;
	      for( int s2=iBase[1]; s2<=iBound[1] && !pointIsNeeded; s2++ )
		for( int s1=iBase[0]; s1<=iBound[0]; s1++ )
		{
		  if( MASKR(s1,s2,s3) & ISneeded )
		  {
		    pointIsNeeded=true;
		    break;
		  }
		}
	    }
	    
	    if( pointIsNeeded )
	    {
	      IP(ii,0)=IP(i,0);
	      IP(ii,1)=IP(i,1);
	      ii++;
	    }
	    else
	    {
	      // printf(" ***** throw away an unneeded point\n");
	      MASKR(IP(i,0),IP(i,1),0)=0;
	    }
	  }
	}
	else
	{
	  for( i=0; i<numberOfInterpolationPoints; i++ )
	  {
	    bool pointIsNeeded=MASKR(IP(i,0),IP(i,1),IP(i,2)) & ISneeded;
            if( !pointIsNeeded )
	    {
	      for( axis=0; axis<3; axis++ )
	      {
		iBase[axis] =max(irMin[axis],IP(i,axis)-dw[axis]);
		iBound[axis]=min(irMax[axis],IP(i,axis)+dw[axis]);
	      }
	      for( int s3=iBase[2]; s3<=iBound[2] && !pointIsNeeded; s3++ )
		for( int s2=iBase[1]; s2<=iBound[1] && !pointIsNeeded; s2++ )
		  for( int s1=iBase[0]; s1<=iBound[0]; s1++ )
		  {
		    if( MASKR(s1,s2,s3) & ISneeded )
		    {
		      pointIsNeeded=TRUE;
		      break;
		    }
		  }
	    }
	    
	    if( pointIsNeeded )
	    {
	      IP(ii,0)=IP(i,0);
	      IP(ii,1)=IP(i,1);
	      IP(ii,2)=IP(i,2);
	      ii++;
	    }
	    else
	    {
	      // printf(" ***** throw away an unneeded point\n");
	      MASKR(IP(i,0),IP(i,1),IP(i,2))=0;
	    }
	  }
	}
	
      } // end opt version
      
//      useOpt=true;  // ***wdh***
      if( debug & 4  )
      {
        displayMask(maskr,"******** maskr after throw away un-needed interp pts **********",plogFile);
        fflush(plogFile);
      } 
      
      if( numberOfInterpolationPoints!=ii )
      {
        // Some un-necessary points were removed.
	// Make sure ghost line values are marked properly. This is needed if we
	// removed un-necessary interpolation points
	for( axis=0; axis<numberOfDimensions; axis++ )
	{
	  for( int side=Start; side<=End; side++ )
	  {
	    getBoundaryIndex(cr.dimension(),side,axis,I1,I2,I3);
	    Iv[axis]=cr.indexRange(side,axis);

	    getBoundaryIndex(cr.dimension(),side,axis,J1,J2,J3);
	    for( int ghost=1; ghost<=cr.numberOfGhostPoints(side,axis); ghost++ )
	    {
	      Jv[axis]=cr.indexRange(side,axis)-ghost*(1-2*side);
	      where( maskr(I1,I2,I3)==0 )
	      {
		maskr(J1,J2,J3)=0;
	      }
	    }
	  }
	}
      }
      numberOfInterpolationPoints=ii;
      if( numberOfInterpolationPoints>0 )
      {
        if( !useOpt ) 
	{
	  if( numberOfDimensions==2 )
	    for( i=0; i<numberOfInterpolationPoints; i++ )
	      maskr(ip(i,0),ip(i,1),i3)=-(i+1);
	  else    
	    for( i=0; i<numberOfInterpolationPoints; i++ )
	      maskr(ip(i,0),ip(i,1),ip(i,2))=-(i+1);
	}
	else
	{
	  if( numberOfDimensions==2 )
	    for( i=0; i<numberOfInterpolationPoints; i++ )
	      MASKR(IP(i,0),IP(i,1),i3)=-(i+1);
	  else    
	    for( i=0; i<numberOfInterpolationPoints; i++ )
	      MASKR(IP(i,0),IP(i,1),IP(i,2))=-(i+1);
	}
	
      }

      if( debug & 4 )
        fPrintF(logFile,"number of interpolation points on grid=%i is %i \n",grid,numberOfInterpolationPoints);
      cg.numberOfInterpolationPoints(grid)=numberOfInterpolationPoints;

    
      if( Ogen::debug & 4 )
        displayMask(maskr,"*********updateRefinement: mask for refinement after marking interpolation *************",
                    logFile);

//      useOpt=false;  // ***wdh***

      timeForMarkInterp+=getCPU()-timei;
    }
    
  }

  real timeForMarkMask=getCPU()-time1;

  // printf(" cg.interpoleeGrid[0]: min=%i, max=%i (before update)\n",min(cg.interpoleeGrid[0]),max(cg.interpoleeGrid[0]));

  // we can build the interpolation arrays now that we know how many interpolation points points we have.
  cg.update(
    CompositeGrid::THEinterpolationPoint       |
    CompositeGrid::THEinterpoleeGrid           |
    CompositeGrid::THEinterpoleeLocation       |
    CompositeGrid::THEinterpolationCoordinates, 
    CompositeGrid::COMPUTEnothing);
  
  // printf(" cg.interpoleeGrid[0]: min=%i, max=%i (after update)\n",min(cg.interpoleeGrid[0]),max(cg.interpoleeGrid[0]));
  for( l=1; l<cg.numberOfRefinementLevels(); l++ )
  {
    GridCollection & rl = cg.refinementLevel[l];
    for( int g=0; g<rl.numberOfComponentGrids(); g++ )
    {
      int grid =rl.gridNumber(g);        // index into cg
      Range R(0,cg.numberOfInterpolationPoints(grid)-1);
      cg.interpolationPoint[grid](R,Rx)=interpolationPoints[l][g](R,Rx);
      cg.interpoleeGrid[grid](R)=-1;
      cg.interpoleeLocation[grid](R,Rx)=notAssigned;
      cg.interpolationCoordinates[grid](R,Rx)=0.;
    }
  }
  // delete temp arrays
  for( l=1; l<cg.numberOfRefinementLevels(); l++ )
    delete [] interpolationPoints[l];
  delete [] interpolationPoints;
  

  real timeForInterpData=getCPU();
  // ********************************************
  // **** Now fill in the interpolation data ****
  // ********************************************
  int pShift[3]={0,0,0};

  IntegerArray baseGridMarked(cg.numberOfBaseGrids());
  baseGridMarked=FALSE;
  
  int iv0[3]={0,0,0};
  real dx[3]={0.,0.,0.},xab[2][3]={0.,0.,0.,0.,0.,0.};
#define VERTEX0(i0,i1,i2) xab[0][0]+dx[0]*(i0-iv0[0])
#define VERTEX1(i0,i1,i2) xab[0][1]+dx[1]*(i1-iv0[1])
#define VERTEX2(i0,i1,i2) xab[0][2]+dx[2]*(i2-iv0[2])

  // cg.update(MappedGrid::THEvertex | MappedGrid::THEcenter ); // ***wdh***

  for( l=1; l<cg.numberOfRefinementLevels(); l++ )
  {
    GridCollection & rl = cg.refinementLevel[l];
    int g;

    
    for( g=0; g<rl.numberOfComponentGrids(); g++ )
    {
      int grid =rl.gridNumber(g);           // index into cg
      int bg = cg.baseGridNumber(grid);     // base grid for this refinement
      MappedGrid & cr = rl[g];              // refined grid
      MappedGrid & cb = cg[bg];             // base grid
      const intArray & maskb = cb.mask();
      intArray & maskr = cr.mask();
      const realArray & vertex = cr.vertex();
      if( cr.isRectangular() )
      {
	cr.getRectangularGridParameters( dx, xab );
	iv0[0]=cr.gridIndexRange(0,0);
	iv0[1]=cr.gridIndexRange(0,1);
	iv0[2]=cr.gridIndexRange(0,2);

      }
      if( debug & 4 )
      {
	if( !cb.isRectangular() ) display(cb.vertex(),sPrintF("vertex on the base grid=%i",bg),logFile,"%3.1f ");
	if( !cr.isRectangular() ) display(vertex,sPrintF("vertex on the refinement grid=%i",grid),logFile,"%3.1f ");
      }
      
      intArray & ipBG = cg.interpolationPoint[bg];
      intArray & interpoleeGridBG = cg.interpoleeGrid[bg];
      realArray & interpolationCoordinatesBG = cg.interpolationCoordinates[bg];

      if( debug & 4 )
        fPrintF(logFile,"\n =============== interpolate grid=%i (g=%i) at refinement level=%i ============\n",
		grid,g,l);

      // printf(" interpoleeGridBG: bg=%i, min=%i, max=%i (before update)\n",bg,min(interpoleeGridBG),max(interpoleeGridBG));


      // these next temporary arrays hold...
      // interpoleeRefinementBG(i) = interpolee grid chosen for a refinement point near this interpolee point
      // interpolationCoordinatesRefinement : corresponding coordinates.
      intArray interpoleeRefinementBG(max(1,cg.numberOfInterpolationPoints(bg)));
      interpoleeRefinementBG=notAssigned;
      realArray interpolationCoordinatesRefinement(max(1,cg.numberOfInterpolationPoints(bg)),numberOfDimensions);

      int rf[3];  // refinement factors (to the BASE GRID!)
      rf[0]=rl.refinementFactor(0,g);
      rf[1]=rl.refinementFactor(1,g);
      rf[2]=rl.refinementFactor(2,g);

      const real ccOffset= !cr.isAllCellCentered() ? 0. : .5;

      intArray & ip = cg.interpolationPoint[grid];
      intArray & interpoleeGrid = cg.interpoleeGrid[grid];
      intArray & interpoleeLocation = cg.interpoleeLocation[grid];
      intArray & variableInterpolationWidth= cg.variableInterpolationWidth[grid];
      
      realArray & interpolationCoordinates = cg.interpolationCoordinates[grid];
      const IntegerArray & indexRange = cr.indexRange();

      int * maskbp = maskb.Array_Descriptor.Array_View_Pointer2;
      const int maskbDim0=maskb.getRawDataSize(0);
      const int maskbDim1=maskb.getRawDataSize(1);
#undef MASKB
#define MASKB(i0,i1,i2) maskbp[i0+maskbDim0*(i1+maskbDim1*(i2))]

      int * ipp = ip.Array_Descriptor.Array_View_Pointer1;
      int ipDim0=ip.getRawDataSize(0);
#undef IP
#define IP(i0,i1) ipp[i0+ipDim0*(i1)]

      int * ipbgp = ipBG.Array_Descriptor.Array_View_Pointer1;
      int ipbgDim0=ipBG.getRawDataSize(0);
#undef IPBG
#define IPBG(i0,i1) ipbgp[i0+ipbgDim0*(i1)]

      const int isRectangular = cr.isRectangular();
      bool isPeriodic[3]={false,false,false}; //
      for( axis=0; axis<numberOfDimensions; axis++ )
	isPeriodic[axis]=  cb.isPeriodic(axis)==Mapping::functionPeriodic;

      // mark base grid interpolation points with an index into its interpolation arrays
      // this let's us go from a mask<0 point to the index in the interpolationPoint array.
      if( !baseGridMarked(bg) )
      {
        baseGridMarked(bg)=TRUE;
        i3=cb.indexRange(Start,axis3);
        if( !useOpt ) 
	{
	  if( numberOfDimensions==2 )
	  {
	    for( int i=0; i<cg.numberOfInterpolationPoints(bg); i++ )
	      maskb(ipBG(i,0),ipBG(i,1),i3)=-(i+1);
	  }
	  else
	  {
	    for( int i=0; i<cg.numberOfInterpolationPoints(bg); i++ )
	      maskb(ipBG(i,0),ipBG(i,1),ipBG(i,2))=-(i+1);
	  }
	}
	else
	{
          const int ni=cg.numberOfInterpolationPoints(bg);
	  if( numberOfDimensions==2 )
	  {
	    for( int i=0; i<ni; i++ )
	      MASKB(IPBG(i,0),IPBG(i,1),i3)=-(i+1);
	  }
	  else
	  {
	    for( int i=0; i<ni; i++ )
	      MASKB(IPBG(i,0),IPBG(i,1),IPBG(i,2))=-(i+1);
	  }
	}
	
        cb.mask().periodicUpdate();
	
      }
      if( false && debug & 4 )
      {
	fPrintF(logFile,"*** cg.numberOfInterpolationPoints(bg)=%i\n",cg.numberOfInterpolationPoints(bg));
	display(ipBG,"ipBG",logFile);
	displayMask(maskb,sPrintF(buff,"Here is maskb for grid %i",bg),logFile);
      }
      

      i3=j3=k3=l3=cr.indexRange(Start,axis3);
      rr=0.;
      bool multipleInterpoleeGrids=FALSE;  // keep track if we interpolate from more than one other grid.
      int i;

      const int *girp = cb.gridIndexRange().getDataPointer();
#define GIR(side,axis) girp[side+2*(axis)]

      const int maximumNumberOfPossibleBaseGrids=20;
      int interpoleeBaseGrid[maximumNumberOfPossibleBaseGrids];  
      int interpolationPointBaseGrid[maximumNumberOfPossibleBaseGrids];

      const int ni=cg.numberOfInterpolationPoints(grid);
      bool retry=false;  // gets set to true if we need to redo a point since we couldn't interp on the first attempt
      for( i=0; i<ni; i++ ) // refinement interpolation points
      {
        // int interpoleeFound=0; // 0=not found, 1=found but from a base grid, 2=found from a refinement (done)
	int interpolee=-1;     // best guess so far for an interpolee grid 
      
        bool coincident=TRUE;
        for( axis=0; axis<numberOfDimensions; axis++ )
	{
          iv[axis]=IP(i,axis);    
          if( iv[axis] % rf[axis] != 0 )
	    coincident=false;     // this pt does not lie on a base grid pt
          
	  kv[axis]=floorDiv(iv[axis],rf[axis]);              // base grid pt <= iv
          if( isPeriodic[axis] )
	  { // adjust for periodicity
            int period=GIR(End,axis)-GIR(Start,axis);
	    kv[axis] =((kv[axis]+period-GIR(Start,axis)) % period)+GIR(Start,axis);
	  }
          // lv[axis]=(iv[axis]+rf[axis]-1)/rf[axis];  // base grid pt >= iv
          lv[axis]=kv[axis] + ((iv[axis]%rf[axis]) !=0); // add 1 if iv is not coincident
          if( retry )
	  { // If we are re-doing this point, increase the size of the base grid region that we search.
	    if( kv[axis]==lv[axis] )
	      lv[axis]+=1;
            coincident=false; // assume this
	  }
	  
	}
	if( debug & 4)
	  fPrintF(logFile,"\n>>Interp. pt %i=(%i,%i,%i) (grid %i, base=%i) base coords=kv=(%i,%i):lv=(%i,%i)"
                     " Trying to interpolate...\n",i,i1,i2,i3,grid,bg,kv[0],kv[1],lv[0],lv[1]);
        // bool notDone=TRUE;

        // --- loop over all neighbouring base grid points, checking for which one are interp. pts.
        //     o if we find an interpolation point then we look up the interpolee grid and then
        //       try to interpolate from any refinements of this interpolee grid.
        //
        // ** we could also look at parent grids ***


	// *new* way:
	// 1. Make a list of possible base grids (usually only one).
	// 2. For each possible base grid: invert actual point (unless co-incident)
	//    3. -> find the appropriate refinement grid.

	int numberOfPossibleInterpoleeBaseGrids=0;
	for( j3=kv[2]; j3<=lv[2]; j3++ ) // loop over neighbouring base grid points.
	{
	  for( j2=kv[1]; j2<=lv[1]; j2++ )
	  {
	    for( j1=kv[0]; j1<=lv[0]; j1++ )
	    {
	      int ib=-maskb(j1,j2,j3)-1;
	      if( ib>=0 && ib<cg.numberOfInterpolationPoints(bg) )
	      {
		// the base grid point jv is an interpolation point.
		int ipbg=interpoleeGridBG(ib);
		// make sure we don't already have this one in the list.
		bool alreadyFound=false;
		for( int nb=0; nb<numberOfPossibleInterpoleeBaseGrids; nb++ )
		{
		  if( interpoleeBaseGrid[nb]==ipbg )
		  {
		    alreadyFound=true;
		    break;
		  }
		}
		if( !alreadyFound )
		{
		  if( debug & 4)
		    fPrintF(logFile,"  ..interp. pt %i=(%i,%i,%i) (grid %i, base=%i). Base interp pt %i is close"
			    " ipBG=(%i,%i) =? jv=(%i,%i), interpolee=%i.\n",
			    i,i1,i2,i3,grid,bg,ib,ipBG(ib,0),ipBG(ib,1),j1,j2,interpoleeGridBG(ib));
	
		  interpolationPointBaseGrid[numberOfPossibleInterpoleeBaseGrids]=ib;
		  interpoleeBaseGrid[numberOfPossibleInterpoleeBaseGrids]=ipbg;
		  numberOfPossibleInterpoleeBaseGrids++;
		  assert( numberOfPossibleInterpoleeBaseGrids<=maximumNumberOfPossibleBaseGrids );
		}
	      }
	    }
	  }
	} // end for j3
	  

	// check the possible base grids.
	// *** we should try to check the last valid choice ****
	bool canInterpolate=FALSE;
	bool backupCanInterpolate=false;
	for( int nb=0; nb<numberOfPossibleInterpoleeBaseGrids; nb++ )
	{
	  if( debug & 4)
	    fPrintF(logFile," ...check base grid %i (grid=%i isRectangular=%i)\n",interpoleeBaseGrid[nb], 
                  grid,isRectangular);
	    
	    // find the coordinates the interpolation point on this base grid:
	  int baseGridInterpolee=interpoleeBaseGrid[nb];
	  
	  if( !coincident )
	  {
	    // invert the mapping to locate the point.
	    if( isRectangular )
	    {
	      xx(0,0)=VERTEX0(i1,i2,i3);
	      xx(0,1)=VERTEX1(i1,i2,i3);
	      xx(0,2)=VERTEX2(i1,i2,i3);
	    }
	    else
	    {
	      for( dir=0; dir<numberOfDimensions; dir++ )
		xx(0,dir)=vertex(i1,i2,i3,dir);
	    }
            // ***** we need to do more than one point at a time ****
            rb=-1.;  // *wdh* 040324
	    cg[baseGridInterpolee].mapping().getMapping().inverseMap(xx(0,Rx),rb);
	  }
	  else
	  {
	    int ib=interpolationPointBaseGrid[nb];
	    for( dir=0; dir<numberOfDimensions; dir++ )
	      rb(0,dir)=interpolationCoordinatesBG(ib,dir);
	      
	  }
	  MappedGrid & ibg = cg[baseGridInterpolee]; // the interpolee base grid.
	    
	    // now check to see if we can interpolate from any refinement grids on this base grid
	  for( int level=l; level>=0 && !canInterpolate ; level-- )
	  {
	    GridCollection & rll = cg.refinementLevel[level];

	    for( int g2=0; g2<rll.numberOfComponentGrids() && !canInterpolate; g2++ )
	    {
	      int grid2=rll.gridNumber(g2);
	      if( rll.baseGridNumber(g2)==baseGridInterpolee )
	      {
		// ie[3]=={ie1,ie2,ie3} : nearest point on the interpolee grid
		for( axis=0; axis<numberOfDimensions; axis++ )
		{
		  ie[axis]=int( (rb(0,axis)/ibg.gridSpacing(axis))*rll.refinementFactor(axis,g2)+
				ibg.indexRange(Start,axis)+.5 );  // closest point (cell centered??)
		  // adjust points for periodicity -- the refinement patch may go from [-10,10] for example.
		  if( ibg.isPeriodic(axis)==Mapping::functionPeriodic )
		  {
		    int period=(ibg.gridIndexRange(End,axis)-ibg.gridIndexRange(Start,axis))*
		      rll.refinementFactor(axis,g2);
		    int ieNew =( (ie[axis]-rll[g2].indexRange(Start,axis)+period) % period ) +
		      rll[g2].indexRange(Start,axis);
		    pShift[axis]=ieNew-ie[axis];

		    // fPrintF(logFile,"periodic shift: ie[%i]=%i ieNew=%i, period=%i\n",axis,ie[axis],
		    //        ieNew,period);
			    
		    ie[axis]=ieNew;
		  }
		  else
		    pShift[axis]=0;
		}
		if( debug & 2 )
		{
		  fPrintF(logFile,"  ..check refinement grid2=%i level=%i ie=(%i,%i) rb=(%4.2f,%4.2f) xx=(%8.2e,%8.2e)"
                          "bounds=[%i,%i]x[%i,%i]\n",
			  grid2,level,ie1,ie2,rb(0,0),rb(0,1),xx(0,0),xx(0,1),
                          rll[g2].indexRange(Start,0),rll[g2].indexRange(End,0),
			  rll[g2].indexRange(Start,1),rll[g2].indexRange(End,1) );
		}
			
                // const IntegerArray & g2IndexRange = rll[g2].indexRange();
                const IntegerArray & g2IndexRange = rll[g2].extendedIndexRange(); // *wdh* 040804 

		if( ie1<g2IndexRange(Start,0) || ie1>g2IndexRange(End,0) ||
		    ie2<g2IndexRange(Start,1) || ie2>g2IndexRange(End,1) )        
		  continue;
		if( numberOfDimensions==3 && 
		    (ie3<g2IndexRange(Start,2) || ie3>g2IndexRange(End,2)) )
		  continue;

		// we are inside this refinement grid.
		if( debug & 4)
		  fPrintF(logFile,"  ..pt is inside refinement grid g2=%i (grid2=%i) at level %i\n",
			  g2,grid2,level);

		interpolee=rll.gridNumber(g2);
		MappedGrid & ig = cg[interpolee];  
		for( axis=0; axis<numberOfDimensions; axis++ )
		{
		  const int rf = rll.refinementFactor(axis,g2);
		  rr(0,axis)=(rb(0,axis)*rf/ibg.gridSpacing(axis)+pShift[axis]
			      -(ig.indexRange(Start,axis)-ibg.indexRange(Start,axis)*rf) )*ig.gridSpacing(axis);
		}
		if( interpolee==baseGridInterpolee )
		{
                  for( axis=0; axis<numberOfDimensions; axis++ )
		    if( ig.isPeriodic(axis) )
		    {
		      rr(0,axis)=fmod(rr(0,axis)+1.,1.);   // base grid may be periodic, shift to [0,1]
		    }
		}
		
                // *** implicit interpolation parameters should be ok to use ****
                // we need to allow for interpolation from the boundary of two refinement grids.

//                 if( debug & 4 && i==17 && grid==3 && interpolee==0 )
// 		{
// 		  char a;
// 		  cin >> a;
// 		}
		

		interpolates(0)=TRUE;
		cg.rcData->canInterpolate(grid,interpolee, rr, interpolates, useBackupRules, 
					  checkForOneSided );

		if( interpolates(0) )
		{
		  canInterpolate=TRUE;
		  if( debug & 4)
		    fPrintF(logFile,"  ..pt %i can interp from refine grid %i, r=(%6.2e,%6.2e), rb=(%6.2e,%6.2e)"
                            " coincident=%i\n",
			    i,rll.gridNumber(g2),rr(0,0),rr(0,1),rb(0,0),rb(0,1),coincident);

		  // assign all these below : interpoleeLocation(i,Rx)=0;  // ******
		  break;
		}
		else 
		{
		  if( level==0 
  		         || retry ) // *wdh* added 040804
		  {
		    // try lower order interpolation as a backup : backupCanInterpolate=true
		    const int width=cg.interpolationWidth(0,grid,grid2,0);
		    const real ov = cg.interpolationOverlap(0,grid,grid2,0);

                    // temporarily change these for the canInterpolate function:
		    cg.interpolationWidth(Rx,grid,grid2,0)=max(2,width-1);  // *wdh* max added 040804
		    cg.interpolationOverlap(Rx,grid,grid2,0)-=max(0.,.5);   // *wdh* max added 040804 

		    interpolates(0)=true;
		    cg.rcData->canInterpolate(grid,interpolee, rr, interpolates, useBackupRules, 
					      checkForOneSided );
 

		    if( interpolates(0) )
		    {
		      if( debug & 4)
			fPrintF(logFile,"  ..pt %i can backup interp from refine grid %i, r=(%6.2e,%6.2e) width=%i\n",
				i,rll.gridNumber(g2),rr(0,0),rr(0,1),width-1);

		      backupCanInterpolate=true;                 // *** we keep looking in this case
		      interpoleeGrid(i)=interpolee;
		      variableInterpolationWidth(i)=width-1;
		      interpolationCoordinates(i,Rx)=rr(0,Rx);
		    }
		    else // cannot interpolate
		    {
		      // Allow interpolation if we are just outside a physical boundary
                      // This case can happen, for e.g., when a cartesian grid has a higher priority
                      // than a boundary fitted grid (cicd.cmd) and the stair-step boundary lies
                      // very close to the physical boundary

                      // *NOTE* if there is a refinement grid on this interpolee grid we should probably
                      //        use it instead

                      realArray rp(1,3);  // will hold the projected interp point
                      const IntegerArray & bc = cg[interpolee].boundaryCondition();
                      bool pointWasProjected=false;
                      for( dir=0; dir<numberOfDimensions; dir++ )
		      {
                        rp(0,dir)=rr(0,dir);
                        for( int side=0; side<=1; side++ )
			{
			  if( bc(side,dir)>0  && ( (side==0 && rr(0,dir)<0.) || (side==1 && rr(0,dir)>1.) ) )
			  {
                            pointWasProjected=true;
                            rp(0,dir)=side;  // move the interpolation location to be on the boundary
                            break;
			  }
			}
		      }
		      if( pointWasProjected )
		      {
			if( debug & 4)
                          fPrintF(logFile,"  ..pt %i try to interp pt from just? outside a boundary,"
			       "r=(%6.2e,%6.2e,%6.2e) r(projected)=(%6.2e,%6.2e,%6.2e)\n",
			       i,rr(0,0),rr(0,1),rr(0,2),rp(0,0),rp(0,1),rp(0,2) );

			interpolates(0)=true;
			cg.rcData->canInterpolate(grid,interpolee, rp, interpolates, useBackupRules, 
						  checkForOneSided );

                        if( interpolates(0) )
			{
                          if( debug & 4)
			    printf("updateRefinement:INFO: backup interpolation from just? outside a boundary,"
				   "grid=%i interpolee=%i r=(%6.2e,%6.2e,%6.2e) r(projected)=(%6.2e,%6.2e,%6.2e)\n",
                                   grid,interpolee,rr(0,0),rr(0,1),rr(0,2),rp(0,0),rp(0,1),rp(0,2) );
			  if( debug & 4)
			    fPrintF(logFile,"  ..pt %i is just outside a boundary, "
                                   "can backup interp from refine grid %i, r=(%6.2e,%6.2e,%6.2e) "
                                    "r(projected)=(%6.2e,%6.2e,%6.2e) width=%i\n",
				    i,rll.gridNumber(g2),rr(0,0),rr(0,1),rr(0,2),rp(0,0),rp(0,1),rp(0,2),width-1);

			  backupCanInterpolate=true;                 // *** we keep looking in this case
			  interpoleeGrid(i)=interpolee;
			  variableInterpolationWidth(i)=width-1;
			  interpolationCoordinates(i,Rx)=rp(0,Rx);
			}

		      }
		      
		      
		    } // end cannot interpolate

		    cg.interpolationWidth(Rx,grid,grid2,0)=width; // reset
		    cg.interpolationOverlap(Rx,grid,grid2,0)=ov;
    
		  }
		  if( !backupCanInterpolate )
		  {
		    if( debug & 4 )
		      fPrintF(logFile,"  ..pt %i can NOT interp from refine grid %i, r=(%6.2e,%6.2e), rb=(%6.2e,%6.2e)"
                            " coincident=%i\n",
			      i,rll.gridNumber(g2),rr(0,0),rr(0,1),rb(0,0),rb(0,1),coincident);
		  }
		    
		}
			
	      }
	    } // end for( g2 )
	  } // for level
	} // for( nb... : for possible base grids

	if( canInterpolate )
	{
	  // interpoleeFound=2; // found but from a base grid.
	  interpoleeGrid(i)=interpolee;
	  interpolationCoordinates(i,Rx)=rr(0,Rx);
	  variableInterpolationWidth(i)=cg.interpolationWidth(0,grid,interpolee,mgLevel);
	  if( debug & 4)
	    fPrintF(logFile,"  >>pt %i can interp from interpolee grid %i, r=(%6.2e,%6.2e) width=%i\n",
		    i,interpoleeGrid(i),interpolationCoordinates(i,0),interpolationCoordinates(i,1),
		    variableInterpolationWidth(i));
		  
	  if( debug & 4)
	  {
	    if( coincident ) 
	    {

	      fPrintF(logFile,"<<interp pt %6i=(%i,%i,%i) (grid %i, base=%i) is coincident and interps from grid %i,"
		      " r=(%6.2e,%6.2e,%6.2e) \n",
		      i,i1,i2,i3,grid,bg,interpolee,rr(0,0),rr(0,1),rr(0,2));
	    }
	    else
	    {
	      fPrintF(logFile,"  ..inbetween interp.point %5i (refine=%i, base=%i) can interp "
		      "from grid %i, r=(%6.2e,%6.2e), width=%i \n",i,grid,bg,interpolee,rr(0,0),rr(0,1),
		      variableInterpolationWidth(i));
	    }
	  }
	}
	else if( backupCanInterpolate )
	{
	  // canInterpolate=true;
	  if( debug & 4)
	    fPrintF(logFile,"  >>pt %i can backup interp from interpolee grid %i, r=(%6.2e,%6.2e) width=%i\n",
		    i,interpoleeGrid(i),interpolationCoordinates(i,0),interpolationCoordinates(i,1),
		    variableInterpolationWidth(i));
          
	  // interpoleeFound=1; // found but from a base grid.
	}
	else
	{
          if( !retry )
	  { // We failed to interpolate -- try again
	    if( debug & 4 ) 
	    {
              fPrintF(logFile,"  ***Unable to interp the refinement pt on the first try. Try again"
		      " checking a larger region on the base grid...");
	    }
	    retry=true;
	    i--;   // redo this value of i
	    continue;
	  }
          else
	  {
            fPrintF(logFile,"Unable to interp even with a retry!\n");
	  }
	  
	  printf("updateRefinement:ERROR: refinement patch interpolation point cannot interpolate! \n");
	  fPrintF(logFile,"updateRefinement:ERROR: refinement patch interpolation point cannot interpolate! \n");
	  fPrintF(logFile,"Mask on the base grid (bg=%i), pts [%i,%i][%i,%i][%i,%i]:\n",bg,
                    kv[0],lv[0],kv[1],lv[1],kv[2],lv[2]);
	  for( j3=kv[2]; j3<=lv[2]; j3++ ) // loop over neighbouring base grid points.
	  {
	    for( j2=kv[1]; j2<=lv[1]; j2++ )
	    {
	      for( j1=kv[0]; j1<=lv[0]; j1++ )
	      {
                int mm=maskb(j1,j2,j3);  // int ib=-maskb(j1,j2,j3)-1;
		fPrintF(logFile,"%6i ",mm); 
	      }
              fPrintF(logFile,"\n");
	    }
	  }
          for( int dir=0; dir<numberOfDimensions; dir++ )
	  {
	    if( kv[dir]==lv[dir] )
	    {
	      lv[dir]+=1;
	    }
	  }
	  fPrintF(logFile,"*** show more pts: Mask on the base grid (bg=%i), pts [%i,%i][%i,%i][%i,%i]:\n",bg,
		  kv[0],lv[0],kv[1],lv[1],kv[2],lv[2]);
	  for( j3=kv[2]; j3<=lv[2]; j3++ ) // loop over neighbouring base grid points.
	  {
	    for( j2=kv[1]; j2<=lv[1]; j2++ )
	    {
	      for( j1=kv[0]; j1<=lv[0]; j1++ )
	      {
                int mm=maskb(j1,j2,j3);  // int ib=-maskb(j1,j2,j3)-1;
		fPrintF(logFile,"%6i ",mm); 
	      }
              fPrintF(logFile,"\n");
	    }
	  } 
	  for( j3=kv[2]; j3<=lv[2]; j3++ ) // loop over neighbouring base grid points.
	  {
	    for( j2=kv[1]; j2<=lv[1]; j2++ )
	    {
	      for( j1=kv[0]; j1<=lv[0]; j1++ )
	      {
		int ib=-maskb(j1,j2,j3)-1;
		if( ib>=0 && ib<cg.numberOfInterpolationPoints(bg) )
		{
		  // the base grid point jv is an interpolation point.
		  int ipbg=interpoleeGridBG(ib);
                  fPrintF(logFile," ** The refinement grid point is close to base grid "
                                  "interpolation pt=%i, donor grid=%i\n",
			  ib,ipbg);
		}
	      }
	    }
	  }
	  
	  if( true )
	  {
            printf("I will save a file `updateRefinementDebug.cmd' that can be used with the `refine' test\n"
                   " program in order to regenerate the adaptive grid and test it.\n");
            outputRefinementInfo( cg, "bugGrid.hdf","updateRefinementDebug.cmd" );

	    fclose(logFile);
	    throw "error";
	  }
	  else
	  {
	    interpoleeGrid(i)=interpolee;
	    interpolationCoordinates(i,Rx)=rr(0,Rx);
	    variableInterpolationWidth(i)=cg.interpolationWidth(0,grid,interpolee,mgLevel);
	  }
	  // throw "error";
	}
	

	if( i>0 && !multipleInterpoleeGrids )
	  multipleInterpoleeGrids=interpoleeGrid(i)!=interpoleeGrid(i-1);

	retry=false;
      } // end for i :  loop over interp points
      

      if( cg.numberOfInterpolationPoints(grid)>0 )
      {
	Range R(0,cg.numberOfInterpolationPoints(grid)-1);
	if( numberOfDimensions==2 )
	{
	  i3=cr.indexRange(Start,axis3);
	  maskr(ip(R,0),ip(R,1),i3)=MappedGrid::ISinterpolationPoint;   
	}
	else
	  maskr(ip(R,0),ip(R,1),ip(R,2))=MappedGrid::ISinterpolationPoint;   
      }
      // sort the interpolation points by interpolee grid.
      cg.interpolationStartEndIndex(all,grid,all)=-1; // ***020220 
      if( multipleInterpoleeGrids )
      {
        if( debug & 4 )
          fPrintF(logFile," ************* computeOverlap: Sorting interpolation points... ********************\n");
        // First count the number of interpolee points for each grid.
        IntegerArray ng(cg.numberOfComponentGrids()+1);
        intArray ig(interpoleeGrid);  // we do need copies of these
	intArray ipt(ip);
	intArray il(interpoleeLocation);
	realArray ic(interpolationCoordinates);
        intArray iw(variableInterpolationWidth);
	
	ng=0;
	for( i=0; i<cg.numberOfInterpolationPoints(grid); i++ )
	  ng(interpoleeGrid(i)+1)+=1;
	
        //  for( int g=2; g<cg.numberOfComponentGrids(); g++ )  // *wdh* 020219
        for( int gg=2; gg<=cg.numberOfComponentGrids(); gg++ )  // note <=
	  ng(gg)+=ng(gg-1); // ng(g) now points to the starting position for interpolee grid "g"
	  
        if( true )
	{
          // printf(" grid=%i ni=%i\n",grid,cg.numberOfInterpolationPoints(grid));
	  for( int grid2=0; grid2<cg.numberOfComponentGrids(); grid2++ )
	  {
	    if( ng(grid2+1)-ng(grid2)>0 )
	    {
	      cg.interpolationStartEndIndex(0,grid,grid2)=ng(grid2);      // start value
	      cg.interpolationStartEndIndex(1,grid,grid2)=ng(grid2+1)-1;  // end value
	      // end value for implicit points: (could sort to put any implicit points first)
	      cg.interpolationStartEndIndex(2,grid,grid2)= cg.interpolationStartEndIndex(1,grid,grid2);
	    }
//             printf("     grid=%i, grid2=%i, ng(grid2)=%i, ng(grid2+1)=%i SE=[%i,%i]\n",
//                      grid,grid2,ng(grid2),ng(grid2+1),cg.interpolationStartEndIndex(0,grid,grid2),
//                       cg.interpolationStartEndIndex(1,grid,grid2));
	  }
	}
	
        // Now fill in the points
	for( i=0; i<cg.numberOfInterpolationPoints(grid); i++ )
	{
          int pos=ng(ig(i)); ng(ig(i))+=1;
	  interpoleeGrid(pos)=ig(i);
	  ip(pos,Rx)=ipt(i,Rx);
	  interpolationCoordinates(pos,Rx)=ic(i,Rx);
	  interpoleeLocation(pos,Rx)=il(i,Rx);
          variableInterpolationWidth(pos)=iw(i);
	}
      }
      else
      {
        if( cg.numberOfInterpolationPoints(grid)>0 )
	{
	  int grid2=interpoleeGrid(0);
          //  printf(" grid=%i, grid2=%i, ng(grid2)=%i, ni=%i\n",grid,grid2,cg.numberOfInterpolationPoints(grid));

	  cg.interpolationStartEndIndex(0,grid,grid2)=0;      // start value
	  cg.interpolationStartEndIndex(1,grid,grid2)=cg.numberOfInterpolationPoints(grid)-1;  // end value
	  // end value for implicit points: (could sort to put any implicit points first)
	  cg.interpolationStartEndIndex(2,grid,grid2)= cg.interpolationStartEndIndex(1,grid,grid2);
	}
	
      }
      
      // assign interpolationLocations for this grid:  ******
      IntegerArray interpolationWidth(3);
      interpolationWidth=1;
      for( i=0; i<cg.numberOfInterpolationPoints(grid); i++ )
      {
	int grid2=interpoleeGrid(i);
	// const IntegerArray & interpolationWidth = cg.interpolationWidth(Rx,grid,grid2,mgLevel);
        interpolationWidth(Rx)=variableInterpolationWidth(i);
	MappedGrid & g2 = cg[grid2];
	for( int axis=0; axis<numberOfDimensions; axis++ )
	{
          if( interpoleeLocation(i,axis)==notAssigned )
	  {
	    // Get the lower-left corner of the interpolation cube.
	    int intLoc=int(floor(interpolationCoordinates(i,axis)/g2.gridSpacing(axis) + g2.indexRange(0,axis) -
				 .5 * interpolationWidth(axis) + (g2.isCellCentered(axis) ? .5 : 1.)));
	    if (!g2.isPeriodic(axis)) 
	    {
	      if( (intLoc < g2.extendedIndexRange(0,axis)) && (g2.boundaryCondition(Start,axis)>0) )
	      {
		//                        Point is close to a BC side.
		//                        One-sided interpolation used.
		intLoc = g2.extendedIndexRange(0,axis);
	      }
	      if( (intLoc + interpolationWidth(axis) - 1 > g2.extendedIndexRange(1,axis))
		  && (g2.boundaryCondition(End,axis)>0) )
	      {
		//                        Point is close to a BC side.
		//                        One-sided interpolation used.
		intLoc = g2.extendedIndexRange(1,axis) - interpolationWidth(axis) + 1;
	      }
	    } // end if
	    interpoleeLocation(i,axis) = intLoc;
	  }
	} // end for_1
      }


      cr->computedGeometry |= CompositeGrid::THEmask; // *wdh* 000424

    } // done refinement grids
      
  } // done refinement levels

  timeForInterpData=getCPU()-timeForInterpData;

  // reset interpolation points on the base grids.
  for( int bg=0; bg<cg.numberOfBaseGrids(); bg++ )
  {
    if( baseGridMarked(bg) && cg.numberOfInterpolationPoints(bg)>0 )
    {
      intArray & ip = cg.interpolationPoint[bg];
      Range R(0,cg.numberOfInterpolationPoints(bg)-1);
      intArray & mask = cg[bg].mask();
      if( numberOfDimensions==2 )
      {
        i3=cg[bg].indexRange(Start,axis3);
        mask(ip(R,0),ip(R,1),i3)=MappedGrid::ISinterpolationPoint;  
      }
      else
        mask(ip(R,0),ip(R,1),ip(R,2))=MappedGrid::ISinterpolationPoint;   

      cg[bg].mask().periodicUpdate();
    }
    if( FALSE )
      displayMask(cg[bg].mask(),"updateRefinement: base grid mask at end");


  }
  
  if( debug & 4 )
  {
    for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
    {
      display(cg.interpolationPoint[grid],sPrintF(buff,"cg.interpolationPoint[%i]",grid),logFile);
      display(cg.interpoleeGrid[grid],sPrintF(buff,"cg.interpoleeGrid[%i]",grid),logFile);
      display(cg.variableInterpolationWidth[grid],sPrintF(buff,"cg.variableInterpolationWidth[%i]",grid),logFile);
      display(cg.interpolationCoordinates[grid],sPrintF(buff,"cg.interpolationCoordinates[%i]",grid),logFile);
      displayMask(cg[grid].mask(),sPrintF(buff,"cg[%i].mask",grid),logFile);
    }
  }

  //  *wdh* 000424 Tell the CompositeGrid that the interpolation data have been computed:
  cg->computedGeometry |=
    CompositeGrid::THEmask                     |
    CompositeGrid::THEinterpolationCoordinates |
    CompositeGrid::THEinterpolationPoint       |
    CompositeGrid::THEinterpoleeLocation       |
    CompositeGrid::THEinterpoleeGrid;
  // ** CompositeGrid::THEmultigridLevel;  // *wdh*

  // assign mask values at points hidden by finer patches
  cg.setMaskAtRefinements();

  // double check that we have computed the interpolation points on refinements
  // properly.


  if( debug & 2  )
  {
    printf("check interpolation on refinements...\n");
    int numberOfErrors=checkRefinementInterpolation( cg );
    if( numberOfErrors==0 )
    {
      printf("...no errors found\n");
    }
  }
  
  // for testing: 
  if( false )
  {
    printf("I will save a file `updateRefinementDebug.cmd' that can be used with the `refine' test\n"
	   " program in order to regenerate the adaptive grid and test it.\n");
    outputRefinementInfo( cg, "bugGrid.hdf","updateRefinementDebug.cmd" );

    fclose(logFile);
    throw "error";
  }

  real totalTime=getCPU()-timeStart;
  if( debug & 1 )
  {
    printf("updateRefinement: total cpu=%8.2e, update=%5.3f%% mark-mask=%5.3f%% (off-axis=%5.3f%%, interp=%5.3f%%) "
	   "interp-update=%5.3f%% \n",totalTime,
	   100.*timeForUpdate/totalTime,
	   100.*timeForMarkMask/totalTime,
	   100.*timeForMarkOffAxis/totalTime,
	   100.*timeForMarkInterp/totalTime,
	   100.*timeForInterpData/totalTime);
  }
  
  return 0;
}

// #beginMacro beginFaceLoops(AXIS)
// #If #AXIS == "AXIS3"
//  r3=0;
//  for( r2=1; r2<=rf[1]-1; r2++ )
//  for( r1=1; r1<=rf[0]-1; r1++ )
// #Elif #AXIS == "AXIS2"
//  r2=0;
//  for( r3=1; r3<=rf[2]-1; r3++ )
//  for( r1=1; r1<=rf[0]-1; r1++ )
// #Elif #AXIS == "AXIS1"
//  r1=0;
//  for( r3=1; r3<=rf[2]-1; r3++ )
//  for( r2=1; r2<=rf[1]-1; r2++ )
// #Else
//   Overture::abort("error: unknown value [AXIS] (axis)");
// #End

// #endMacro

// // ================================================================================
// //  DIM : 2,3
// //  RATIO: 2,4, general
// //  AXIS: AXIS1,AXIS2,AXIS3
// //  rv1,rv2: 2 or (r1,r2,r3)
// // ================================================================================
// #beginMacro setMaskOnFace(DIM,RATIO,mask00,mask10,mask01,mask11,AXIS,rv1,rv2)
//   if( mask00+mask10+mask01+mask11 > 1 )
//   {
//     // more than one corner of this cell has a zero -- all points in cell are zeroed.
//     beginFaceLoops(AXIS)
//     {
//       MASK(i1r+r1,i2r+r2,i3r+r3)=0;
//     }
//   }
//   else if( mask00 )  // only lower left corner is zero
//   {
//     beginFaceLoops(AXIS)
//     {
//       if( rv1+rv2 < rf[0] ) 
// 	MASK(i1r+r1,i2r+r2,i3r+r3)=0;
//     }
//   }
//   else if( mask10 ) // only lower right corner is zero.
//   {
//     beginFaceLoops(AXIS)
//     {
//       if( rv1>rv2 )
// 	MASK(i1r+r1,i2r+r2,i3r+r3)=0;
//     }
//   }
//   else if( mask01 )
//   {
//     beginFaceLoops(AXIS)
//     {
//       if( rv1<rv2 )
// 	MASK(i1r+r1,i2r+r2,i3r+r3)=0;
//     }
//   }
//   else if( mask11 )
//   {
//     beginFaceLoops(AXIS)
//     {
//       if( rv1+rv2 > rf[0] )
// 	MASK(i1r+r1,i2r+r2,i3r+r3)=0;
//     }
//   }
// #endMacro

// int Ogen::
// markOffAxisRefinementMask( int numberOfDimensions, Range Ivr[3], Range Ivb[3], int rf[3],
//                     intArray & mask, const intArray & maskb )
// // =====================================================================================
// // /Description: 
// //     Mark off-axis mask points -- i.e. mark points that do not aligh exactly with
// // coarse grid points.
// //
// //                   
// // 
// // =====================================================================================
// {
//   bool useNewAlgorithm=true;
//   bool useOpt=true;

//   int * maskp = mask.Array_Descriptor.Array_View_Pointer2;
//   const int maskDim0=mask.getRawDataSize(0);
//   const int maskDim1=mask.getRawDataSize(1);
// #undef MASK
// #define MASK(i0,i1,i2) maskp[i0+maskDim0*(i1+maskDim1*(i2))]
//   const int * maskbp = maskb.Array_Descriptor.Array_View_Pointer2;
//   const int maskbDim0=maskb.getRawDataSize(0);
//   const int maskbDim1=maskb.getRawDataSize(1);
// #undef MASKB
// #define MASKB(i0,i1,i2) maskbp[i0+maskbDim0*(i1+maskbDim1*(i2))]

//   Range &I1r = Ivr[0], &I2r=Ivr[1], &I3r=Ivr[2];
//   Range &I1b = Ivb[0], &I2b=Ivb[1], &I3b=Ivb[2];
  
//   int i1b,i2b,i3b,i1r,i2r,i3r;
//   int I1bBase,I2bBase,I3bBase; 
//   int I1bBound,I2bBound, I3bBound;
//   int I1rBase,I2rBase,I3rBase; 
//   int I1rBound,I2rBound,I3rBound;
//   int I1rStride,I2rStride,I3rStride;

//   int axis;
//   for( axis=0; axis<numberOfDimensions; axis++ )
//   {
//     Ivr[axis]=Range(Ivr[axis].getBase(),Ivr[axis].getBound()-rf[axis],rf[axis]);
//     Ivb[axis]=Range(Ivb[axis].getBase(),Ivb[axis].getBound()-1);
//   }
//   if( numberOfDimensions==2 )
//   {
//     // only zero middle points with 2 or more 0 neighbours
//     //        X---O   O---O
//     //        | x |   | o |
//     //        X---X   X---X
//     if( rf[0]==2 && rf[1]==2 )
//     {
//       if( !useOpt )
//       {
// 	const intArray & maskb0 = evaluate(maskb(I1b,I2b,I3b)==0);
// 	where(  maskb0+(maskb(I1b+1,I2b  ,I3b)==0)+(maskb(I1b,I2b+1,I3b)==0)+(maskb(I1b+1,I2b+1,I3b)==0) > 1)
// 	{
// 	  for( int r2=1; r2<rf[1]; r2++ )
// 	  {
// 	    for( int r1=1; r1<rf[0]; r1++ )
// 	    {
// 	      mask(I1r+r1,I2r+r2,I3r)=0;
// 	    }
// 	  }
// 	}
//       }
//       else
//       {
// 	FOR_3BR()
// 	{
// 	  if( (MASKB(i1b,i2b,i3b)==0)+(MASKB(i1b+1,i2b,i3b)==0)+(MASKB(i1b,i2b+1,i3b)==0)+(MASKB(i1b+1,i2b+1,i3b)==0) > 1)
// 	  {
//             MASK(i1r+1,i2r+1,i3r)=0;
// 	  }
// 	}
//       }
      
//     }
//     else
//     {

//       const intArray mask00=maskb(I1b  ,I2b  ,I3b)==0;
//       const intArray mask10=maskb(I1b+1,I2b  ,I3b)==0;
//       const intArray mask01=maskb(I1b  ,I2b+1,I3b)==0;
//       const intArray mask11=maskb(I1b+1,I2b+1,I3b)==0;
      
//       setRefinementMaskFace(mask,Start,axis3,numberOfDimensions,rf,I1r,I2r,I3r,mask00,mask10,mask01,mask11);

//     }
//   }
//   else // numberOfDimensions == 3
//   {

//     if( useNewAlgorithm )
//     {
//       if( rf[0]==2 && rf[1]==2 && rf[2]==2 )
//       {
// 	// new way 
// 	if( !useOpt )
// 	{
// 	  Ivr[axis3]=Range(Ivr[axis3].getBase(),Ivr[axis3].getBound()+rf[axis3],rf[axis3]);
// 	  Ivb[axis3]=Range(Ivb[axis3].getBase(),Ivb[axis3].getBound()+1);
// 	  where( (maskb(I1b,I2b  ,I3b)==0)+(maskb(I1b+1,I2b  ,I3b)==0)+
// 		 (maskb(I1b,I2b+1,I3b)==0)+(maskb(I1b+1,I2b+1,I3b)==0) > 1 )
// 	  {
// 	    for( int r2=1; r2<rf[1]; r2++ )
// 	    {
// 	      for( int r1=1; r1<rf[0]; r1++ )
// 	      {
// 		mask(I1r+r1,I2r+r2,I3r)=0;
// 	      }
// 	    }
// 	  }
// 	  Ivr[axis3]=Range(Ivr[axis3].getBase(),Ivr[axis3].getBound()-rf[axis3],rf[axis3]);
// 	  Ivb[axis3]=Range(Ivb[axis3].getBase(),Ivb[axis3].getBound()-1);

// 	  Ivr[axis1]=Range(Ivr[axis1].getBase(),Ivr[axis1].getBound()+rf[axis1],rf[axis1]);
// 	  Ivb[axis1]=Range(Ivb[axis1].getBase(),Ivb[axis1].getBound()+1);
// 	  where( (maskb(I1b,I2b,I3b  )==0)+(maskb(I1b  ,I2b+1,I3b  )==0)+
// 		 (maskb(I1b,I2b,I3b+1)==0)+(maskb(I1b  ,I2b+1,I3b+1)==0) > 1 )
// 	  {
// 	    for( int r3=1; r3<rf[2]; r3++ )
// 	    {
// 	      for( int r2=1; r2<rf[1]; r2++ )
// 	      {
// 		mask(I1r,I2r+r2,I3r+r3)=0;
// 	      }
// 	    }
// 	  }
// 	  Ivr[axis1]=Range(Ivr[axis1].getBase(),Ivr[axis1].getBound()-rf[axis1],rf[axis1]);
// 	  Ivb[axis1]=Range(Ivb[axis1].getBase(),Ivb[axis1].getBound()-1);

// 	  Ivr[axis2]=Range(Ivr[axis2].getBase(),Ivr[axis2].getBound()+rf[axis2],rf[axis2]);
// 	  Ivb[axis2]=Range(Ivb[axis2].getBase(),Ivb[axis2].getBound()+1);
// 	  where( (maskb(I1b,I2b,I3b  )==0)+(maskb(I1b+1,I2b,I3b  )==0)+
// 		 (maskb(I1b,I2b,I3b+1)==0)+(maskb(I1b+1,I2b,I3b+1)==0) > 1 )
// 	  {
// 	    for( int r3=1; r3<rf[2]; r3++ )
// 	    {
// 	      for( int r1=1; r1<rf[0]; r1++ )
// 	      {
// 		mask(I1r+r1,I2r,I3r+r3)=0;
// 	      }
// 	    }
// 	  }
// 	  Ivr[axis2]=Range(Ivr[axis2].getBase(),Ivr[axis2].getBound()-rf[axis2],rf[axis2]);
// 	  Ivb[axis2]=Range(Ivb[axis2].getBase(),Ivb[axis2].getBound()-1);


// 	  // center remains if 2 or more face centers remain.
// 	  where(  (mask(I1r+1,I2r+1,I3r  )==0)+(mask(I1r+1,I2r+1,I3r+2)==0)+
// 		  (mask(I1r+1,I2r  ,I3r+1)==0)+(mask(I1r+1,I2r+2,I3r+1)==0)+
// 		  (mask(I1r  ,I2r+1,I3r+1)==0)+(mask(I1r+2,I2r+1,I3r+1)==0) > 4 )
// 	  {
// 	    for( int r3=1; r3<rf[2]; r3++ )
// 	    {
// 	      for( int r2=1; r2<rf[1]; r2++ )
// 	      {
// 		for( int r1=1; r1<rf[0]; r1++ )
// 		{
// 		  mask(I1r+r1,I2r+r2,I3r+r3)=0;
// 		}
// 	      }
// 	    }
// 	  }
// 	}
// 	else 
// 	{ // ************* opt version ***********************

//           for( int axis=0; axis<numberOfDimensions; axis++ )
// 	  {
// 	    Ivr[axis]=Range(Ivr[axis].getBase(),Ivr[axis].getBound()+rf[axis],rf[axis]);
// 	    Ivb[axis]=Range(Ivb[axis].getBase(),Ivb[axis].getBound()+1);
// 	  }
	  
//           FOR_3BR()
// 	  {
//             // mark a face i3=const if there are at least 2 holes on the face
// 	    if( i1b<I1bBound && i2b<I2bBound &&
//                 (MASKB(i1b,i2b  ,i3b)==0)+(MASKB(i1b+1,i2b  ,i3b)==0)+
// 		(MASKB(i1b,i2b+1,i3b)==0)+(MASKB(i1b+1,i2b+1,i3b)==0) > 1 )
// 	    {
// 	      MASK(i1r+1,i2r+1,i3r)=0;
// 	    }
//             // mark a face i1=const if there are at least 2 holes on the face
// 	    if( i2b<I2bBound && i3b<I3bBound &&
//                 (MASKB(i1b,i2b  ,i3b)==0)+(MASKB(i1b,i2b  ,i3b+1)==0)+
// 		(MASKB(i1b,i2b+1,i3b)==0)+(MASKB(i1b,i2b+1,i3b+1)==0) > 1 )
// 	    {
// 	      MASK(i1r,i2r+1,i3r+1)=0;
// 	    }
//             // mark a face i2=const if there are at least 2 holes on the face
// 	    if( i1b<I1bBound && i3b<I3bBound &&
//                 (MASKB(i1b  ,i2b,i3b)==0)+(MASKB(i1b  ,i2b,i3b+1)==0)+
// 		(MASKB(i1b+1,i2b,i3b)==0)+(MASKB(i1b+1,i2b,i3b+1)==0) > 1 )
// 	    {
// 	      MASK(i1r+1,i2r,i3r+1)=0;
// 	    }

// 	  }
	  
//           for( int axis=0; axis<numberOfDimensions; axis++ )
// 	  {
// 	    Ivr[axis]=Range(Ivr[axis].getBase(),Ivr[axis].getBound()-rf[axis],rf[axis]);
// 	    Ivb[axis]=Range(Ivb[axis].getBase(),Ivb[axis].getBound()-1);
// 	  }
//           // center remains if 2 or more face centers remain.
//           FOR_3R()
// 	  {
// 	    if(  (MASK(i1r+1,i2r+1,i3r  )==0)+(MASK(i1r+1,i2r+1,i3r+2)==0)+
// 		 (MASK(i1r+1,i2r  ,i3r+1)==0)+(MASK(i1r+1,i2r+2,i3r+1)==0)+
// 		 (MASK(i1r  ,i2r+1,i3r+1)==0)+(MASK(i1r+2,i2r+1,i3r+1)==0) > 4 )
// 	    {
// 	      MASK(i1r+1,i2r+1,i3r+1)=0;
// 	    }
// 	  }
	  
// 	} // end opt
	
//       }
//       else
//       {
// 	// refinement factors > 2 

//         if( !useOpt )
// 	{
// 	  // -- first assign faces --
// 	  Ivr[axis3]=Range(Ivr[axis3].getBase(),Ivr[axis3].getBound()+rf[axis3],rf[axis3]);
// 	  Ivb[axis3]=Range(Ivb[axis3].getBase(),Ivb[axis3].getBound()+1);
	
// 	  if( true )
// 	  {
// 	    const intArray mask00=maskb(I1b  ,I2b  ,I3b)==0;
// 	    const intArray mask10=maskb(I1b+1,I2b  ,I3b)==0;
// 	    const intArray mask01=maskb(I1b  ,I2b+1,I3b)==0;
// 	    const intArray mask11=maskb(I1b+1,I2b+1,I3b)==0;
      
// 	    setRefinementMaskFace(mask,Start,axis3,numberOfDimensions,rf,I1r,I2r,I3r,mask00,mask10,mask01,mask11);
// 	  }
      

// 	  Ivr[axis3]=Range(Ivr[axis3].getBase(),Ivr[axis3].getBound()-rf[axis3],rf[axis3]);
// 	  Ivb[axis3]=Range(Ivb[axis3].getBase(),Ivb[axis3].getBound()-1);

// 	  Ivr[axis1]=Range(Ivr[axis1].getBase(),Ivr[axis1].getBound()+rf[axis1],rf[axis1]);
// 	  Ivb[axis1]=Range(Ivb[axis1].getBase(),Ivb[axis1].getBound()+1);

// 	  if( true )
// 	  {
// 	    const intArray mask00=maskb(I1b  ,I2b  ,I3b  )==0;
// 	    const intArray mask10=maskb(I1b  ,I2b+1,I3b  )==0;
// 	    const intArray mask01=maskb(I1b  ,I2b  ,I3b+1)==0;
// 	    const intArray mask11=maskb(I1b  ,I2b+1,I3b+1)==0;
      
// 	    setRefinementMaskFace(mask,Start,axis1,numberOfDimensions,rf,I1r,I2r,I3r,mask00,mask10,mask01,mask11);
// 	  }

// 	  Ivr[axis1]=Range(Ivr[axis1].getBase(),Ivr[axis1].getBound()-rf[axis1],rf[axis1]);
// 	  Ivb[axis1]=Range(Ivb[axis1].getBase(),Ivb[axis1].getBound()-1);

// 	  Ivr[axis2]=Range(Ivr[axis2].getBase(),Ivr[axis2].getBound()+rf[axis2],rf[axis2]);
// 	  Ivb[axis2]=Range(Ivb[axis2].getBase(),Ivb[axis2].getBound()+1);
// 	  if( true )
// 	  {
// 	    const intArray mask00=maskb(I1b  ,I2b  ,I3b  )==0;
// 	    const intArray mask10=maskb(I1b  ,I2b  ,I3b+1)==0;
// 	    const intArray mask01=maskb(I1b+1,I2b  ,I3b  )==0;
// 	    const intArray mask11=maskb(I1b+1,I2b  ,I3b+1)==0;
      
// 	    setRefinementMaskFace(mask,Start,axis2,numberOfDimensions,rf,I1r,I2r,I3r,mask00,mask10,mask01,mask11);
// 	  }


// 	  Ivr[axis2]=Range(Ivr[axis2].getBase(),Ivr[axis2].getBound()-rf[axis2],rf[axis2]);
// 	  Ivb[axis2]=Range(Ivb[axis2].getBase(),Ivb[axis2].getBound()-1);
    
// 	}
//         else 
// 	{
// 	  // optimized version
// 	  int mask000,mask100,mask010,mask110,mask001,mask101,mask011,mask111;
//           int r1,r2,r3;

//           for( int axis=0; axis<numberOfDimensions; axis++ )
// 	  {
// 	    Ivr[axis]=Range(Ivr[axis].getBase(),Ivr[axis].getBound()+rf[axis],rf[axis]);
// 	    Ivb[axis]=Range(Ivb[axis].getBase(),Ivb[axis].getBound()+1);
// 	  }
	  
//           if( numberOfDimensions==2 )
// 	  {
// 	    FOR_3BR()
// 	    {
// 	      // mark a face i3=const if there are at least 2 holes on the face
// 	      if( i1b<I1bBound && i2b<I2bBound )
// 	      {
//   	        mask000=MASKB(i1b  ,i2b  ,i3b  )==0;
// 		mask100=MASKB(i1b+1,i2b  ,i3b  )==0;
// 		mask010=MASKB(i1b  ,i2b+1,i3b  )==0;
// 		mask110=MASKB(i1b+1,i2b+1,i3b  )==0;

// 		setMaskOnFace(2,general,mask000,mask100,mask010,mask110,AXIS3,r1,r2);
// 	      }
// 	    }
	    
// 	  }
// 	  else // 3D
// 	  {
//             // if( rf[0]==4 && rf[1]==4 && rf[2]==4 )
	    
// 	    FOR_3BR()
// 	    {
// 	      // mark a face i3=const if there are at least 2 holes on the face
// 	      mask000=MASKB(i1b  ,i2b  ,i3b  )==0;

// 	      if( i1b<I1bBound && i2b<I2bBound )
// 	      {
// 		mask100=MASKB(i1b+1,i2b  ,i3b  )==0;
//     	        mask010=MASKB(i1b  ,i2b+1,i3b  )==0;
// 		mask110=MASKB(i1b+1,i2b+1,i3b  )==0;

// 		setMaskOnFace(3,general,mask000,mask100,mask010,mask110,AXIS3,r1,r2);
// 	      }
// 	      if( i2b<I2bBound && i3b<I3bBound )
// 	      {
    
// 		mask010=MASKB(i1b  ,i2b+1,i3b  )==0;
// 		mask001=MASKB(i1b  ,i2b  ,i3b+1)==0;
// 		mask011=MASKB(i1b  ,i2b+1,i3b+1)==0;
// 		setMaskOnFace(3,general,mask000,mask010,mask001,mask011,AXIS1,r2,r3);
// 	      }
//               if( i1b<I1bBound && i3b<I3bBound )
// 	      {

// 		mask001=MASKB(i1b  ,i2b  ,i3b+1)==0;
// 		mask100=MASKB(i1b+1,i2b  ,i3b  )==0;
// 		mask101=MASKB(i1b+1,i2b  ,i3b+1)==0;
// 		setMaskOnFace(3,general,mask000,mask001,mask100,mask101,AXIS2,r3,r1);  // **** 070601 *** r1,r3 -> r3,r1
// 	      }
	      
// 	    } // end for3
	    

// 	  }

//           for( int axis=0; axis<numberOfDimensions; axis++ )
// 	  {
// 	    Ivr[axis]=Range(Ivr[axis].getBase(),Ivr[axis].getBound()-rf[axis],rf[axis]);
// 	    Ivb[axis]=Range(Ivb[axis].getBase(),Ivb[axis].getBound()-1);
// 	  }
// 	} // end optimized version
	
	
// 	// *** interior points: 
//         //        We need to mark the ? points below:
//         //
//         //            x--0--0--0--0
//         //            |  |  |  |  |
//         //            x--?--?--?--0
//         //            |  |  |  |  |
//         //            x--?--?--?--0
//         //            |  |  |  |  |
//         //            x--?--?--?--0
//         //            |  |  |  |  |
//         //            x--x--x--x--x
//         //
//         //   to discretize:
//         ///   1) there must be a valid point on a face in each direction:
//         //       (mask(left face)!=0 || mask(right face)!=0) && (mask(bottom face)!=0 || mask(top face)!=0) && ...
//         //   and
//         //    2) one of the closests face(s) must be valid:
//         //        mask(closest face)!=0   ( if more than one closest face then at least one should be !=0 )

//         if( !useOpt )
// 	{
// 	  intArray maskd,maskc;
// 	  maskc.redim(I1r.getLength(),I2r.getLength(),I3r.getLength());
// 	  for( int r3=1; r3<rf[2]; r3++ )
// 	  {
// 	    for( int r2=1; r2<rf[1]; r2++ )
// 	    {
// 	      for( int r1=1; r1<rf[0]; r1++ )
// 	      {
// 		// set maskd = true if there is at least one face in each direction that is valid:
// 		maskd=(( (mask(I1r   ,I2r+r2,I3r+r3)!=0) || (mask(I1r+rf[0],I2r+r2   ,I3r+r3   )!=0) ) &&
// 		       ( (mask(I1r+r1,I2r   ,I3r+r3)!=0) || (mask(I1r+r1   ,I2r+rf[1],I3r+r3   )!=0) ) &&
// 		       ( (mask(I1r+r1,I2r+r2,I3r   )!=0) || (mask(I1r+r1   ,I2r+r2   ,I3r+rf[2])!=0) ));

// 		// set maskc = true if there is a valid point on one of the closest face(s)
// 		const int r1d = min(r1,rf[0]-r1); // distance to nearest face along axis1
// 		const int r2d = min(r2,rf[1]-r2);
// 		const int r3d = min(r3,rf[2]-r3);
// 		maskc=0;
// 		if( r1d <= min(r2d,r3d) )
// 		{ // there is a nearest face along axis1
// 		  if( r1<=rf[0]/2 )
// 		    maskc=maskc || (mask(I1r      ,I2r+r2,I3r+r3)!=0);
// 		  if( r1>=rf[0]/2 )
// 		    maskc=maskc || (mask(I1r+rf[0],I2r+r2,I3r+r3)!=0);
// 		}
// 		if( r2d <=min(r1d,r3d) )
// 		{ // there is a nearest face along axis2
// 		  if( r2<=rf[1]/2 )
// 		    maskc=maskc || (mask(I1r+r1,I2r+rf[1],I3r+r3)!=0);
// 		  if( r2>=rf[1]/2 )
// 		    maskc=maskc || (mask(I1r+r1,I2r+rf[1],I3r+r3)!=0);
// 		}
// 		if( r3d <=min(r1d,r2d) )
// 		{ // there is a nearest face along axis3
// 		  if( r3<=rf[2]/2 )
// 		    maskc=maskc || (mask(I1r+r1,I2r+r2,I3r+rf[2])!=0);
// 		  if( r3>=rf[2]/2 )
// 		    maskc=maskc || (mask(I1r+r1,I2r+r2,I3r+rf[2])!=0);
// 		}
// 		where( !(maskd && maskc) )
// 		{
// 		  mask(I1r+r1,I2r+r2,I3r+r3)=0;
// 		}
	      
// 	      }
// 	    }
// 	  }
// 	}
// 	else 
// 	{
// 	  // ----- opt version with bug fix-----
//           //   *** I think that this can be re-worked to be faster ***
//           int maskd,maskc;
//           FOR_3R()
// 	  {
// 	    for( int r3=1; r3<rf[2]; r3++ )
// 	    {
//    	      const int r3d = min(r3,rf[2]-r3); // distance to nearest face along axis3
// 	      for( int r2=1; r2<rf[1]; r2++ )
// 	      {
// 		const int r2d = min(r2,rf[1]-r2); // distance to nearest face along axis2
// 		for( int r1=1; r1<rf[0]; r1++ )
// 		{

// 		  // set maskd = true if there is at least one face in each direction that is valid:
// 		  maskd=(( (MASK(i1r   ,i2r+r2,i3r+r3)!=0) || (MASK(i1r+rf[0],i2r+r2   ,i3r+r3   )!=0) ) &&
// 			 ( (MASK(i1r+r1,i2r   ,i3r+r3)!=0) || (MASK(i1r+r1   ,i2r+rf[1],i3r+r3   )!=0) ) && 
// 			 ( (MASK(i1r+r1,i2r+r2,i3r   )!=0) || (MASK(i1r+r1   ,i2r+r2   ,i3r+rf[2])!=0) ));
		
// 		  if( !maskd )
// 		  {
// 		    MASK(i1r+r1,i2r+r2,i3r+r3)=0;
//                     continue;
// 		  }
//                   // Some adjacent faces are valid -- we need to check more carefully

// 		  const int r1d = min(r1,rf[0]-r1); // distance to nearest face along axis1
// 		  // set maskc = true if there is a valid point on one of the closest face(s)
// 		  maskc=0;
// 		  if( r1d <= min(r2d,r3d) )
// 		  { // there is a nearest face along axis1
// 		    if( r1<=rf[0]/2 )
// 		      maskc=maskc || (MASK(i1r      ,i2r+r2,i3r+r3)!=0);
// 		    if( r1>=rf[0]/2 )
// 		      maskc=maskc || (MASK(i1r+rf[0],i2r+r2,i3r+r3)!=0);
//                     if( maskc ) continue;
// 		  } 
// 		  if( r2d <=min(r1d,r3d) )
// 		  { // there is a nearest face along axis2
// 		    if( r2<=rf[1]/2 )
// 		      maskc=maskc || (MASK(i1r+r1,i2r      ,i3r+r3)!=0);   // bug found here *wdh* 030913
// 		    if( r2>=rf[1]/2 )
// 		      maskc=maskc || (MASK(i1r+r1,i2r+rf[1],i3r+r3)!=0);
//                     if( maskc ) continue;
// 		  }
// 		  if( r3d <=min(r1d,r2d) )
// 		  { // there is a nearest face along axis3
// 		    if( r3<=rf[2]/2 )
// 		      maskc=maskc || (MASK(i1r+r1,i2r+r2,i3r      )!=0);  // bug found here *wdh* 030913
// 		    if( r3>=rf[2]/2 )
// 		      maskc=maskc || (MASK(i1r+r1,i2r+r2,i3r+rf[2])!=0);
//                     if( maskc ) continue;
// 		  }
// 		  if( !maskc )
// 		  {
// 		    MASK(i1r+r1,i2r+r2,i3r+r3)=0;
// 		  }
// 		}
// 	      }
// 	    }
// 	  } // end for

//         } // end opt version
	
//       }
      

//     }
//     else // ************************OLD WAY**************************************************
//     {
//       // old way: refinement region matches coarse grid
//       Ivr[axis3]=Range(Ivr[axis3].getBase(),Ivr[axis3].getBound()+rf[axis3],rf[axis3]);
//       Ivb[axis3]=Range(Ivb[axis3].getBase(),Ivb[axis3].getBound()+1);
//       where( (maskb(I1b,I2b,I3b)==0)   || (maskb(I1b+1,I2b  ,I3b)==0) ||
// 	     (maskb(I1b,I2b+1,I3b)==0) || (maskb(I1b+1,I2b+1,I3b)==0) )
//       {
// 	for( int r2=1; r2<rf[1]; r2++ )
// 	{
// 	  for( int r1=1; r1<rf[0]; r1++ )
// 	  {
// 	    mask(I1r+r1,I2r+r2,I3r)=0;
// 	  }
// 	}
//       }
//       Ivr[axis3]=Range(Ivr[axis3].getBase(),Ivr[axis3].getBound()-rf[axis3],rf[axis3]);
//       Ivb[axis3]=Range(Ivb[axis3].getBase(),Ivb[axis3].getBound()-1);

//       Ivr[axis1]=Range(Ivr[axis1].getBase(),Ivr[axis1].getBound()+rf[axis1],rf[axis1]);
//       Ivb[axis1]=Range(Ivb[axis1].getBase(),Ivb[axis1].getBound()+1);
//       where( (maskb(I1b,I2b,I3b)==0)   || (maskb(I1b  ,I2b+1,I3b)==0) ||
// 	     (maskb(I1b,I2b,I3b+1)==0) || (maskb(I1b  ,I2b+1,I3b+1)==0) )
//       {
// 	for( int r3=1; r3<rf[2]; r3++ )
// 	{
// 	  for( int r2=1; r2<rf[1]; r2++ )
// 	  {
// 	    mask(I1r,I2r+r2,I3r+r3)=0;
// 	  }
// 	}
//       }
//       Ivr[axis1]=Range(Ivr[axis1].getBase(),Ivr[axis1].getBound()-rf[axis1],rf[axis1]);
//       Ivb[axis1]=Range(Ivb[axis1].getBase(),Ivb[axis1].getBound()-1);

//       Ivr[axis2]=Range(Ivr[axis2].getBase(),Ivr[axis2].getBound()+rf[axis2],rf[axis2]);
//       Ivb[axis2]=Range(Ivb[axis2].getBase(),Ivb[axis2].getBound()+1);
//       where( (maskb(I1b,I2b,I3b)==0)   || (maskb(I1b+1,I2b,I3b)==0) ||
// 	     (maskb(I1b,I2b,I3b+1)==0) || (maskb(I1b+1,I2b,I3b+1)==0) )
//       {
// 	for( int r3=1; r3<rf[2]; r3++ )
// 	{
// 	  for( int r1=1; r1<rf[0]; r1++ )
// 	  {
// 	    mask(I1r+r1,I2r,I3r+r3)=0;
// 	  }
// 	}
//       }
//       Ivr[axis2]=Range(Ivr[axis2].getBase(),Ivr[axis2].getBound()-rf[axis2],rf[axis2]);
//       Ivb[axis2]=Range(Ivb[axis2].getBase(),Ivb[axis2].getBound()-1);


//       where( (maskb(I1b,I2b,I3b)==0)       || (maskb(I1b+1,I2b  ,I3b  )==0) ||
// 	     (maskb(I1b  ,I2b+1,I3b  )==0) || (maskb(I1b+1,I2b+1,I3b  )==0) ||
// 	     (maskb(I1b  ,I2b  ,I3b+1)==0) || (maskb(I1b+1,I2b  ,I3b+1)==0) ||
// 	     (maskb(I1b  ,I2b+1,I3b+1)==0) || (maskb(I1b+1,I2b+1,I3b+1)==0) )
//       {
// 	for( int r3=1; r3<rf[2]; r3++ )
// 	{
// 	  for( int r2=1; r2<rf[1]; r2++ )
// 	  {
// 	    for( int r1=1; r1<rf[0]; r1++ )
// 	    {
// 	      mask(I1r+r1,I2r+r2,I3r+r3)=0;
// 	    }
// 	  }
// 	}
//       }
//     }

//   }
//   return 0;
// }



// int Ogen::
// setRefinementMaskFace(intArray & mask,
//                       int side, int axis, 
//                       int numberOfDimensions, int rf[3],
//                       Range & I1r, Range & I2r, Range & I3r,
//                       const intArray & mask00, 
//                       const intArray & mask10,
//                       const intArray & mask01,
//                       const intArray & mask11)
// // =============================================================================================
// // /Description:
// //    Assign the mask values for a refinement grid on a face (side,axis).
// // /side,axis (input): defines the face to assign. For a 2d grid axis should equal 2.
// // /mask00,mask01,maks10,mask11 (input): values of (mask==0) on the corners of the face.
// // =============================================================================================
// {
//   assert( rf[0]==rf[1] && ( numberOfDimensions==2 || rf[1]==rf[2]) );
	    
//   int rStart[3]= {0,0,0}; //
//   int rEnd[3]= {0,0,0}; //

//   for( int dir=0; dir<numberOfDimensions; dir++ )
//   {
//     rStart[dir]=1;
//     rEnd[dir]=rf[dir]-1;
//   }
//   rStart[axis]=0;
//   rEnd[axis]=0;

//   int rv[3], &r1=rv[0], &r2=rv[1], &r3=rv[2];

//   const int dir1 = (axis+1) % 3;
//   const int dir2 = (axis+2) % 3;
  
//   where( mask00+mask10+mask01+mask11 > 1 )
//   {
//     // more than one corner of this cell has a zero -- all points in cell are zeroed.
//     for( r3=rStart[2]; r3<=rEnd[2]; r3++ )
//     for( r2=rStart[1]; r2<=rEnd[1]; r2++ )
//     for( r1=rStart[0]; r1<=rEnd[0]; r1++ )
//     {
//       mask(I1r+r1,I2r+r2,I3r+r3)=0;
//     }
//   }
//   elsewhere( mask00 )  // only lower left corner is zero
//   {
//     for( r3=rStart[2]; r3<=rEnd[2]; r3++ )
//     for( r2=rStart[1]; r2<=rEnd[1]; r2++ )
//     for( r1=rStart[0]; r1<=rEnd[0]; r1++ )
//     {
//       if( rv[dir1]+rv[dir2] < rf[0] ) 
// 	mask(I1r+r1,I2r+r2,I3r+r3)=0;
//     }
//   }
//   elsewhere( mask10 ) // only lower right corner is zero.
//   {
//     for( r3=rStart[2]; r3<=rEnd[2]; r3++ )
//     for( r2=rStart[1]; r2<=rEnd[1]; r2++ )
//     for( r1=rStart[0]; r1<=rEnd[0]; r1++ )
//     {
//       if( rv[dir1]>rv[dir2] )
// 	mask(I1r+r1,I2r+r2,I3r+r3)=0;
//     }
//   }
//   elsewhere( mask01 )
//   {
//     for( r3=rStart[2]; r3<=rEnd[2]; r3++ )
//     for( r2=rStart[1]; r2<=rEnd[1]; r2++ )
//     for( r1=rStart[0]; r1<=rEnd[0]; r1++ )
//     {
//       if( rv[dir1]<rv[dir2] )
// 	mask(I1r+r1,I2r+r2,I3r+r3)=0;
//     }
//   }
//   elsewhere( mask11 )
//   {
//     for( r3=rStart[2]; r3<=rEnd[2]; r3++ )
//     for( r2=rStart[1]; r2<=rEnd[1]; r2++ )
//     for( r1=rStart[0]; r1<=rEnd[0]; r1++ )
//     {
//       if( rv[dir1]+rv[dir2] > rf[0] )
// 	mask(I1r+r1,I2r+r2,I3r+r3)=0;
//     }
//   }

//   return 0;
// }



int Ogen::
checkRefinementInterpolation( CompositeGrid & cg )
// ==========================================================================================
// /Description
//    Here we check the new interpolation added for refinements
// ==========================================================================================
{
  int numberOfErrors=0;
  const int numberOfDimensions=cg.numberOfDimensions();
  
  Range Rx=numberOfDimensions;
  realArray x(1,3),r(1,3);
  const real eps = REAL_EPSILON*100.;
  
  int iv0[3]={0,0,0};
  real dx[3]={0.,0.,0.},xab[2][3]={0.,0.,0.,0.,0.,0.};
  for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
  {
    if( grid!=cg.baseGridNumber(grid) )
    {
      // this is not a base grid 
      if( cg.numberOfInterpolationPoints(grid)>0 )
      {
        MappedGrid & mg = cg[grid];
	const IntegerArray & extended = extendedGridIndexRange(mg);
	const realArray & vertex = mg.vertex();
	if( mg.isRectangular() )
	{
	  mg.getRectangularGridParameters( dx, xab );
	  iv0[0]=mg.gridIndexRange(0,0);
	  iv0[1]=mg.gridIndexRange(0,1);
	  iv0[2]=mg.gridIndexRange(0,2);
	}
	const intArray & ip = cg.interpolationPoint[grid];
	const intArray & interpoleeGrid = cg.interpoleeGrid[grid];
	const realArray & ci = cg.interpolationCoordinates[grid];
	
	int i;
        int i3=extended(Start,axis3);
	for( i=0; i<cg.numberOfInterpolationPoints(grid); i++ )
	{
	  int interpolee=interpoleeGrid(i);
	  if( interpolee<0 || interpolee>cg.numberOfComponentGrids() )
	  {
            numberOfErrors++;
	    printf("checkRefinementInterpolation: ERROR: grid=%i, i=%i, invalid interpolee=%i\n",grid,i,interpolee);
	  }
          int axis;
	  for( axis=0; axis<numberOfDimensions; axis++ )
	  {
	    if( ip(i,axis)<extended(Start,axis) || ip(i,axis)>extended(End,axis) )
	    {
              numberOfErrors++;
	      printf("checkRefinementInterpolation: ERROR: grid=%i, i=%i, invalid interpolation point\n",grid,i);
	    }
            if( ci(i,axis)<-.25 || ci(i,axis)>1.25 )
	    {
              numberOfErrors++;
	      printf("checkRefinementInterpolation: ERROR: grid=%i, i=%i, invalid interpolation coords\n",grid,i);
	    }
	    
            if( mg.isRectangular() )
	    {
	      if( numberOfDimensions==2 )
	      {
		x(0,0)=VERTEX0(ip(i,0),ip(i,1),i3);
		x(0,1)=VERTEX1(ip(i,0),ip(i,1),i3);
	      }
	      else
	      {
		x(0,0)=VERTEX0(ip(i,0),ip(i,1),ip(i,2));
		x(0,1)=VERTEX1(ip(i,0),ip(i,1),ip(i,2));
		x(0,2)=VERTEX2(ip(i,0),ip(i,1),ip(i,2));
	      }
	    }
	    else
	    {
	      if( numberOfDimensions==2 )
		x(0,axis)=vertex(ip(i,0),ip(i,1),i3,axis);
	      else
		x(0,axis)=vertex(ip(i,0),ip(i,1),ip(i,2),axis);
	    }
	    
	  }
	  r=-1.;
	  cg[interpolee].mapping().inverseMap(x,r);
           
	  if( max(fabs(r(0,Rx)-ci(i,Rx)))> eps )
	  {
            numberOfErrors++;
	    printf("checkRefinementInterpolation: ERROR: grid=%i, i=%i, incorrect interpolation coords. "
                   " ip=(%i,%i,%i) interpolee=%i\n",grid,i,ip(i,0),ip(i,1),(numberOfDimensions==2 ? 0 : ip(i,2)),
                     interpolee);
            printf("   interpolationCoordinates=(%9.3e,%9.3e,%9.3e) inverseMap=(%9.3e,%9.3e,%9.3e) \n",
		   ci(i,0),ci(i,1),(numberOfDimensions==2 ? 0. : ci(i,2)),r(0,0),r(0,1),r(0,2));
	  }
	}
      }
    }
  }

  return numberOfErrors;
}

#undef VERTEX0
#undef VERTEX1
#undef VERTEX2


#define FOR_3IJD(i1,i2,i3,I1,I2,I3,j1,j2,j3,J1,J2,J3) \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
int I1Stride=I1.getStride(),  I2Stride=I2.getStride(), I3Stride=I3.getStride(); \
int J1Base =J1.getBase(),   J2Base =J2.getBase(),  J3Base =J3.getBase();  \
int J1Stride =J1.getStride(),   J2Stride =J2.getStride(),  J3Stride =J3.getStride();  \
for(i3=I3Base,j3=J3Base; i3<=I3Bound; i3+=I3Stride, j3+=J3Stride) \
for(i2=I2Base,j2=J2Base; i2<=I2Bound; i2+=I2Stride, j2+=J2Stride) \
for(i1=I1Base,j1=J1Base; i1<=I1Bound; i1+=I1Stride, j1+=J1Stride)

static Box 
intersects( const Box & box1, const Box & box2 )
//=========================================================================================
// /Description:
//    Protected routine for intersecting two boxes.
//
// /box1, box2 (input) : intersect these boxes.
// /return value: box defining the region of intersection.
//
//\end{InterpolateRefinementsInclude.tex} 
//=========================================================================================
{
  Box box; box.convert(box1.ixType());
  for( int axis=0; axis<3; axis++ )
  {
    box.setSmall(axis,max(box1.smallEnd(axis),box2.smallEnd(axis)));
    box.setBig  (axis,min(box1.bigEnd(axis),box2.bigEnd(axis)));
  }
  return box;
}

//\begin{>>InterpolateRefinementsInclude.tex}{\subsection{getIndex}} 
static int 
getIndex( const BOX & box, Index Iv[3] )
//=========================================================================================
// /Description:
//    Convert a box to an array of Index's.
// /box (input):
// /Iv (output): 
//\end{InterpolateRefinementsInclude.tex} 
//=========================================================================================
{
  for( int axis=0; axis<3; axis++ )
    Iv[axis]=Range(box.smallEnd(axis),box.bigEnd(axis));

  return 0;
}

int Ogen::
checkUpdateRefinement( GridCollection & gc )
// ======================================================================================================
// /Description:
//    A static function that will check the overlapping grid that was created from updateRefinement.
//
// Currently we check the following:
// 
//   (1) Check that a coarse grid discretization point (mask>0) is convered by a
//       refinement grid discretization point. 
//
// Return value: number of errors found.
//=========================================================================================
{
  #ifdef USE_PPP
    printF("\n **** checkUpdateRefinement: WARNING: not implemented in parallel\n");
    return 0;
  #endif

  int numberOfErrors=0;

  int debug=3;
  
  
  Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
  Index Jv[3], &J1=Jv[0], &J2=Jv[1], &J3=Jv[2];
  
  // we assume the refinement ratio is the same for all grids
  IntegerArray refinementRatio(3);
  refinementRatio=gc.refinementLevel[1].refinementFactor(Range(0,2),0);

  int levelStart = 0;
  int levelEnd   = gc.numberOfRefinementLevels()-2;

  for( int level=levelEnd; level>=levelStart; level-- )  
  {
    GridCollection & rl = gc.refinementLevel[level+1];  // finer level
    for( int g=0; g<rl.numberOfComponentGrids(); g++ )
    {
      // interpolate this grid
      const int grid=rl.gridNumber(g);
      const int baseGrid=rl.baseGridNumber(g);
      MappedGrid & mg=gc[grid];
      const intArray & mask = mg.mask();
      
      GridCollection & rlm1 = gc.refinementLevel[level];  // coarser level

      int ratio=refinementRatio(0); // *** fix this ***

      Box box = rl[g].box();
      Box box0 = box;
      box0.coarsen(ratio);

      int c,g2;
      for( g2=0; g2<rlm1.numberOfComponentGrids(); g2++ )
      {
	if( rlm1.baseGridNumber(g2)==baseGrid && box0.intersects( rlm1[g2].box() ) )
	{
	  BOX intersection = intersects(box0,rlm1[g2].box());
	  getIndex(intersection,Iv);
	  int grid2=rlm1.gridNumber(g2);

	  J1=Range(I1.getBase()*ratio,I1.getBound()*ratio,ratio);
	  J2=Range(I2.getBase()*ratio,I2.getBound()*ratio,ratio);
	  J3=Range(I3.getBase()*ratio,I3.getBound()*ratio,ratio);
	  
	  if( debug & 2 )
	    printf("checkUpdateRefinement:  coarse grid %i (level %i) [%i,%i][%i,%i][%i,%i]\n"
                   "           lies below the fine grid %i (level %i) [%i,%i][%i,%i][%i,%i]\n",
		   grid2,level,I1.getBase(),I1.getBound(),I2.getBase(),I2.getBound(),I3.getBase(),I3.getBound(),
                   grid,level+1,J1.getBase(),J1.getBound(),J2.getBase(),J2.getBound(),J3.getBase(),J3.getBound());



          #ifdef USE_PPP
            intSerialArray mask2; getLocalArrayWithGhostBoundaries(gc[grid2].mask(),mask2);
          #else
	    intSerialArray & mask2 = gc[grid2].mask();
          #endif

	  const IntegerArray & gid = gc[grid].gridIndexRange();
	  const IntegerArray & gid2 = gc[grid2].gridIndexRange();
	    
	  int i1,i2,i3, j1,j2,j3;
          FOR_3IJD(i1,i2,i3,I1,I2,I3,j1,j2,j3,J1,J2,J3)
	  {
            // printF(" coarse-mask(%i,%i,%i)=%i , fine-mask(%i,%i,%i)=%i\n",
	    //	   i1,i2,i3,mask2(i1,i2,i3),j1,j2,j3, mask(j1,j2,j3));
	    
	    if( mask2(i1,i2,i3)>0 && !(mask(j1,j2,j3)>0) )
	    {
	      printF("\n"
                     " ***** checkUpdateRefinement:ERROR: there is an invalid point. *****\n"
                     "   refinement grid=%i, bg=%i, level=%i, gid=[%i,%i][%i,%i][%i,%i], mask(%i,%i,%i)=%i\n"
                     "   coarse grid    =%i, bg=%i, level=%i, gid=[%i,%i][%i,%i][%i,%i], mask(%i,%i,%i)=%i "
                     "(discretization) \n"
                     "  A coarse grid discretization point should not be covered by a refinement grid interp point!\n",
		     grid,baseGrid,level+1,
                     gid(0,0),gid(1,0),gid(0,1),gid(1,1),gid(0,2),gid(1,2), j1,j2,j3,mask(j1,j2,j3), 
                     grid2,baseGrid,level, 
                     gid2(0,0),gid2(1,0),gid2(0,1),gid2(1,1),gid2(0,2),gid2(1,2),i1,i2,i3,mask2(i1,i2,i3));

	      numberOfErrors++;
	    }
	  }
	  
	  if( intersection == box || level==0 ) // we are done in these cases (only 1 parent on level 0)
	    break;
	}
      }
    }
  }
  printF("\n **** checkUpdateRefinement: There were %i errors found. ***\n\n",numberOfErrors);
  
  return numberOfErrors;
}

